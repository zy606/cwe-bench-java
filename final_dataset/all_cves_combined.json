[
  {
    "cve_id": "CVE-2016-10726",
    "project_slug": "DSpace__DSpace_CVE-2016-10726_4.4",
    "buggy_commit_id": "ca4c86b1baa4e0b07975b1da86a34a6e7170b3b7",
    "github_url": "https://github.com/DSpace/DSpace",
    "nvd_metadata": {
      "description": "The XMLUI feature in DSpace before 3.6, 4.x before 4.5, and 5.x before 5.5 allows directory traversal via the themes/ path in an attack with two or more arbitrary characters and a colon before a pathname, as demonstrated by a themes/Reference/aa:etc/passwd URI.",
      "published_date": "2018-07-10T11:29:00.223",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "dspace-xmlui/src/main/java/org/dspace/app/xmlui/cocoon/SafeResourceReader.java",
        "class_name": "SafeResourceReader",
        "method_name": "setup",
        "signature": "void setup(SourceResolver,Map,String,Parameters)",
        "lines_hint_csv": [
          34,
          65
        ],
        "code": "    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)\n            throws ProcessingException, SAXException, IOException {\n\n        // If the requested path includes any of the following strings/characters\n        // then block access and return \"Resource Not Found\"\n        if(src != null && (\n            // %252e = double encoded dot (.)\n            src.toLowerCase().contains(\"%252e\") ||\n            // %2e = encoded dot (.)\n            src.toLowerCase().contains(\"%2e\") ||\n            // %2f = encoded slash (/)\n            src.toLowerCase().contains(\"%2f\") ||\n            // block public access to all Cocoon Sitemaps (*.xmap)\n            src.toLowerCase().contains(\".xmap\") ||\n            // block public access to all Theme XSLs\n            src.toLowerCase().contains(\".xsl\")\n        ))\n        {\n            // Block access by throwing a ResourceNotFound (triggers a 404)\n            throw new ResourceNotFoundException(\"Resource not found (\" + src + \")\");\n        }\n\n        // See if this resource actually exists by attempting to resolve it\n        // If not, throw a ResourceNotFound (triggers a 404)\n        Source resource = resolver.resolveURI(src);\n        if(!resource.exists())\n        {\n            throw new ResourceNotFoundException(\"Resource not found (\" + src + \")\");\n        }    \n        \n        // Otherwise, simply load the requested resource via ResourceReader\n        super.setup(resolver, objectModel, src, par);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          34,
          66
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-9159",
    "project_slug": "perwendel__spark_CVE-2018-9159_2.7.1",
    "buggy_commit_id": "5316c0d0f057daaf556c3907c20df975f7bf8a8a",
    "github_url": "https://github.com/perwendel/spark",
    "nvd_metadata": {
      "description": "In Spark before 2.7.2, a remote attacker can read unintended static files via various representations of absolute or relative pathnames, as demonstrated by file: URLs and directory traversal sequences. NOTE: this product is unrelated to Ignite Realtime Spark.",
      "published_date": "2018-03-31T21:29:00.373",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "ClassPathResource",
        "signature": "ClassPathResource(String,ClassLoader)",
        "lines_hint_csv": [
          75,
          86
        ],
        "code": "    public ClassPathResource(String path, ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        String pathToUse = StringUtils.cleanPath(path);\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n        this.path = pathToUse;\n        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          75,
          83
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "getPath",
        "signature": "String getPath()",
        "lines_hint_csv": [
          112,
          113
        ],
        "code": "    public final String getPath() {\n        return this.path;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          104,
          106
        ]
      },
      {
        "file_path": "src/test/java/spark/embeddedserver/jetty/EmbeddedJettyFactoryTest.java",
        "class_name": "EmbeddedJettyFactoryTest",
        "method_name": "create",
        "signature": "void create()",
        "lines_hint_csv": [
          17,
          30
        ],
        "code": "    public void create() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100,10,10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 100,10,10000);\n\n        verify(jettyServerFactory, times(1)).create(100,10,10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          17,
          31
        ]
      },
      {
        "file_path": "src/test/java/spark/embeddedserver/jetty/EmbeddedJettyFactoryTest.java",
        "class_name": "EmbeddedJettyFactoryTest",
        "method_name": "create_withNullThreadPool",
        "signature": "void create_withNullThreadPool()",
        "lines_hint_csv": [
          52,
          65
        ],
        "code": "    public void create_withNullThreadPool() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100,10,10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(null);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 100,10,10000);\n\n        verify(jettyServerFactory, times(1)).create(100,10,10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          52,
          66
        ]
      },
      {
        "file_path": "src/test/java/spark/embeddedserver/jetty/EmbeddedJettyFactoryTest.java",
        "class_name": "EmbeddedJettyFactoryTest",
        "method_name": "create_withThreadPool",
        "signature": "void create_withThreadPool()",
        "lines_hint_csv": [
          34,
          48
        ],
        "code": "    public void create_withThreadPool() throws Exception {\n        final QueuedThreadPool threadPool = new QueuedThreadPool(100);\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(threadPool)).thenReturn(new Server(threadPool));\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(threadPool);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 0,0,0);\n\n        verify(jettyServerFactory, times(1)).create(threadPool);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          34,
          49
        ]
      },
      {
        "file_path": "src/test/java/spark/examples/staticresources/StaticResources.java",
        "class_name": "StaticResources",
        "method_name": "main",
        "signature": "void main(String)",
        "lines_hint_csv": [
          27,
          33
        ],
        "code": "    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFileLocation(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          27,
          35
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "getPath",
        "signature": "String getPath()",
        "lines_hint_csv": [
          112,
          113
        ],
        "code": "    public final String getPath() {\n        return this.path;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          104,
          106
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "ClassPathResource",
        "signature": "ClassPathResource(String,ClassLoader)",
        "lines_hint_csv": [
          75,
          86
        ],
        "code": "    public ClassPathResource(String path, ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        String pathToUse = StringUtils.cleanPath(path);\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n        this.path = pathToUse;\n        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          75,
          83
        ]
      },
      {
        "file_path": "src/test/java/spark/embeddedserver/jetty/EmbeddedJettyFactoryTest.java",
        "class_name": "EmbeddedJettyFactoryTest",
        "method_name": "create",
        "signature": "void create()",
        "lines_hint_csv": [
          17,
          30
        ],
        "code": "    public void create() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100,10,10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 100,10,10000);\n\n        verify(jettyServerFactory, times(1)).create(100,10,10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          17,
          31
        ]
      },
      {
        "file_path": "src/test/java/spark/embeddedserver/jetty/EmbeddedJettyFactoryTest.java",
        "class_name": "EmbeddedJettyFactoryTest",
        "method_name": "create_withNullThreadPool",
        "signature": "void create_withNullThreadPool()",
        "lines_hint_csv": [
          52,
          65
        ],
        "code": "    public void create_withNullThreadPool() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100,10,10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(null);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 100,10,10000);\n\n        verify(jettyServerFactory, times(1)).create(100,10,10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          52,
          66
        ]
      },
      {
        "file_path": "src/test/java/spark/embeddedserver/jetty/EmbeddedJettyFactoryTest.java",
        "class_name": "EmbeddedJettyFactoryTest",
        "method_name": "create_withThreadPool",
        "signature": "void create_withThreadPool()",
        "lines_hint_csv": [
          34,
          48
        ],
        "code": "    public void create_withThreadPool() throws Exception {\n        final QueuedThreadPool threadPool = new QueuedThreadPool(100);\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(threadPool)).thenReturn(new Server(threadPool));\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(threadPool);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 0,0,0);\n\n        verify(jettyServerFactory, times(1)).create(threadPool);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          34,
          49
        ]
      },
      {
        "file_path": "src/test/java/spark/examples/staticresources/StaticResources.java",
        "class_name": "StaticResources",
        "method_name": "main",
        "signature": "void main(String)",
        "lines_hint_csv": [
          27,
          33
        ],
        "code": "    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFileLocation(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          27,
          35
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "ClassPathResource",
        "signature": "ClassPathResource(String,ClassLoader,Class)",
        "lines_hint_csv": [
          93,
          96
        ],
        "code": "    protected ClassPathResource(String path, ClassLoader classLoader, Class<?> clazz) {\n        this.path = StringUtils.cleanPath(path);\n        this.classLoader = classLoader;\n        this.clazz = clazz;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          93,
          97
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "getInputStream",
        "signature": "InputStream getInputStream()",
        "lines_hint_csv": [
          136,
          146
        ],
        "code": "    public InputStream getInputStream() throws IOException {\n        InputStream is;\n        if (this.clazz != null) {\n            is = this.clazz.getResourceAsStream(this.path);\n        } else {\n            is = this.classLoader.getResourceAsStream(this.path);\n        }\n        if (is == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n        }\n        return is;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          136,
          147
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "getURL",
        "signature": "URL getURL()",
        "lines_hint_csv": [
          158,
          168
        ],
        "code": "    public URL getURL() throws IOException {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        if (url == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\n        }\n        return url;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          158,
          169
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "exists",
        "signature": "boolean exists()",
        "lines_hint_csv": [
          117,
          124
        ],
        "code": "    public boolean exists() {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        return (url != null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          117,
          125
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ClassPathResource.java",
        "class_name": "ClassPathResource",
        "method_name": "equals",
        "signature": "boolean equals(Object)",
        "lines_hint_csv": [
          225,
          239
        ],
        "code": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof ClassPathResource) {\n            ClassPathResource otherRes = (ClassPathResource) obj;\n\n            ClassLoader thisLoader = this.classLoader;\n            ClassLoader otherLoader = otherRes.classLoader;\n\n            return (this.path.equals(otherRes.path) &&\n                    thisLoader.equals(otherLoader) &&\n                    this.clazz.equals(otherRes.clazz));\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          225,
          240
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2016-9177",
    "project_slug": "perwendel__spark_CVE-2016-9177_2.5.1",
    "buggy_commit_id": "ce57dfb949ed183405f75dee8cf3262b45c9b3b5",
    "github_url": "https://github.com/perwendel/spark",
    "nvd_metadata": {
      "description": "Directory traversal vulnerability in Spark 2.5 allows remote attackers to read arbitrary files via a .. (dot dot) in the URI.",
      "published_date": "2016-11-04T10:59:00.177",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/spark/resource/ClassPathResourceHandler.java",
        "class_name": "ClassPathResourceHandler",
        "method_name": "getResource",
        "signature": "AbstractFileResolvingResource getResource(String)",
        "lines_hint_csv": [
          60,
          87
        ],
        "code": "    protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {\n        if (path == null || !path.startsWith(\"/\")) {\n            throw new MalformedURLException(path);\n        }\n\n        try {\n            path = UriPath.canonical(path);\n\n            final String addedPath = addPaths(baseResource, path);\n\n            ClassPathResource resource = new ClassPathResource(addedPath);\n\n            if (resource.exists() && resource.getFile().isDirectory()) {\n                if (welcomeFile != null) {\n                    resource = new ClassPathResource(addPaths(resource.getPath(), welcomeFile));\n                } else {\n                    //  No welcome file configured, serve nothing since it's a directory\n                    resource = null;\n                }\n            }\n\n            return (resource != null && resource.exists()) ? resource : null;\n        } catch (Exception e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getClass().getSimpleName() + \" when trying to get resource. \" + e.getMessage());\n            }\n        }\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          60,
          88
        ]
      },
      {
        "file_path": "src/main/java/spark/resource/ExternalResourceHandler.java",
        "class_name": "ExternalResourceHandler",
        "method_name": "getResource",
        "signature": "AbstractFileResolvingResource getResource(String)",
        "lines_hint_csv": [
          59,
          86
        ],
        "code": "    protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {\n        if (path == null || !path.startsWith(\"/\")) {\n            throw new MalformedURLException(path);\n        }\n\n        try {\n            path = UriPath.canonical(path);\n\n            final String addedPath = addPaths(baseResource, path);\n\n            ExternalResource resource = new ExternalResource(addedPath);\n\n            if (resource.exists() && resource.isDirectory()) {\n                if (welcomeFile != null) {\n                    resource = new ExternalResource(addPaths(resource.getPath(), welcomeFile));\n                } else {\n                    //  No welcome file configured, serve nothing since it's a directory\n                    resource = null;\n                }\n            }\n\n            return (resource != null && resource.exists()) ? resource : null;\n        } catch (Exception e) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(e.getClass().getSimpleName() + \" when trying to get resource. \" + e.getMessage());\n            }\n        }\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          59,
          87
        ]
      },
      {
        "file_path": "src/main/java/spark/staticfiles/StaticFilesConfiguration.java",
        "class_name": "StaticFilesConfiguration",
        "method_name": "consumeWithFileResourceHandlers",
        "signature": "boolean consumeWithFileResourceHandlers(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          85,
          106
        ],
        "code": "    private boolean consumeWithFileResourceHandlers(HttpServletRequest httpRequest,\n                                                    HttpServletResponse httpResponse) throws IOException {\n        if (staticResourceHandlers != null) {\n\n            for (AbstractResourceHandler staticResourceHandler : staticResourceHandlers) {\n\n                AbstractFileResolvingResource resource = staticResourceHandler.getResource(httpRequest);\n\n                if (resource != null && resource.isReadable()) {\n                    httpResponse.setHeader(MimeType.CONTENT_TYPE, MimeType.fromResource(resource));\n                    customHeaders.forEach(httpResponse::setHeader); //add all user-defined headers to response\n                    OutputStream wrappedOutputStream = GzipUtils.checkAndWrap(httpRequest, httpResponse, false);\n                    IOUtils.copy(resource.getInputStream(), wrappedOutputStream);\n                    wrappedOutputStream.flush();\n                    wrappedOutputStream.close();\n                    return true;\n                }\n            }\n\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          80,
          101
        ]
      },
      {
        "file_path": "src/main/java/spark/staticfiles/StaticFilesConfiguration.java",
        "class_name": "StaticFilesConfiguration",
        "method_name": "configure",
        "signature": "void configure(String)",
        "lines_hint_csv": [
          155,
          180
        ],
        "code": "    public synchronized void configure(String folder) {\n        Assert.notNull(folder, \"'folder' must not be null\");\n\n        if (!staticResourcesSet) {\n            try {\n                ClassPathResource resource = new ClassPathResource(folder);\n\n                if (configureJarCase(folder, resource)) {\n                    return;\n                }\n\n                if (!resource.getFile().isDirectory()) {\n                    LOG.error(\"Static resource location must be a folder\");\n                    return;\n                }\n\n                if (staticResourceHandlers == null) {\n                    staticResourceHandlers = new ArrayList<>();\n                }\n\n                staticResourceHandlers.add(new ClassPathResourceHandler(folder, \"index.html\"));\n                LOG.info(\"StaticResourceHandler configured with folder = \" + folder);\n            } catch (IOException e) {\n                LOG.error(\"Error when creating StaticResourceHandler\", e);\n            }\n            staticResourcesSet = true;\n        }\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          150,
          178
        ]
      },
      {
        "file_path": "src/main/java/spark/staticfiles/StaticFilesConfiguration.java",
        "class_name": "StaticFilesConfiguration",
        "method_name": "setExpireTimeSeconds",
        "signature": "void setExpireTimeSeconds(long)",
        "lines_hint_csv": [
          239,
          241
        ],
        "code": "    public void setExpireTimeSeconds(long expireTimeSeconds) {\n        customHeaders.put(\"Cache-Control\", \"private, max-age=\" + expireTimeSeconds);\n        customHeaders.put(\"Expires\", new Date(System.currentTimeMillis() + (expireTimeSeconds * 1000)).toString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          235,
          238
        ]
      },
      {
        "file_path": "src/main/java/spark/staticfiles/StaticFilesConfiguration.java",
        "class_name": "StaticFilesConfiguration",
        "method_name": "configureJarCase",
        "signature": "boolean configureJarCase(String,ClassPathResource)",
        "lines_hint_csv": [
          185,
          203
        ],
        "code": "    private boolean configureJarCase(String folder, ClassPathResource resource) throws IOException {\n        if (resource.getURL().getProtocol().equals(\"jar\")) {\n\n            InputStream stream = StaticFilesConfiguration.class.getResourceAsStream(folder);\n\n            if (stream != null) {\n                if (jarResourceHandlers == null) {\n                    jarResourceHandlers = new ArrayList<>();\n                }\n\n                // Add jar file resource handler\n                jarResourceHandlers.add(new JarResourceHandler(folder, \"index.html\"));\n                staticResourcesSet = true;\n                return true;\n            } else {\n                LOG.error(\"Static file configuration failed.\");\n            }\n\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          180,
          200
        ]
      },
      {
        "file_path": "src/main/java/spark/utils/StringUtils.java",
        "class_name": "StringUtils",
        "method_name": "toString",
        "signature": "String toString(byte,String)",
        "lines_hint_csv": [
          376,
          390
        ],
        "code": "    public static String toString(byte[] bytes, String encoding) {\n        String str;\n\n        if (encoding != null && Charset.isSupported(encoding)) {\n            try {\n                str = new String(bytes, encoding);\n            } catch (UnsupportedEncodingException e) {\n                // Uses same func as Charset.isSupported (cannot happen)\n                str = new String(bytes);\n            }\n        } else {\n            str = new String(bytes);\n        }\n\n        return str;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          376,
          391
        ]
      },
      {
        "file_path": "src/test/java/spark/StaticFilesTest.java",
        "class_name": "StaticFilesTest",
        "method_name": "testCustomMimeType",
        "signature": "void testCustomMimeType()",
        "lines_hint_csv": [
          107,
          109
        ],
        "code": "    public void testCustomMimeType() throws Exception {\n        staticFiles.registerMimeType(\"cxt\", \"custom-extension-type\");\n        Assert.assertEquals(\"custom-extension-type\", doGet(\"/img/file.cxt\").headers.get(\"Content-Type\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          107,
          110
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-1047",
    "project_slug": "wildfly__wildfly_CVE-2018-1047_11.0.0.Final",
    "buggy_commit_id": "4fd7bffaf2ee73201910684f2674aa1bced7fe81",
    "github_url": "https://github.com/wildfly/wildfly",
    "nvd_metadata": {
      "description": "A flaw was found in Wildfly 9.x. A path traversal vulnerability through the org.wildfly.extension.undertow.deployment.ServletResourceManager.getResource method could lead to information disclosure of arbitrary local files.",
      "published_date": "2018-01-24T23:29:00.527",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "testsuite/integration/web/src/test/java/org/jboss/as/test/integration/web/servlet/overlays/ServletResourceOverlaysTestCase.java",
        "class_name": "ServletResourceOverlaysTestCase",
        "method_name": "single",
        "signature": "WebArchive single()",
        "lines_hint_csv": [
          52,
          62
        ],
        "code": "    public static WebArchive single() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"single.war\");\n        war.addAsWebResource(new StringAsset(\"a\"), \"a.txt\");\n        war.addAsWebResource(new StringAsset(\"b\"), \"b.txt\");\n\n        JavaArchive jar = ShrinkWrap.create(JavaArchive.class, \"test.jar\");\n        jar.addAsManifestResource(new StringAsset(\"b - overlay\"), new BasicPath(\"resources\", \"b.txt\"));\n        jar.addAsManifestResource(new StringAsset(\"c - overlay\"), new BasicPath(\"resources\", \"c.txt\"));\n\n        war.addAsLibrary(jar);\n        return war;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          52,
          63
        ]
      },
      {
        "file_path": "testsuite/integration/web/src/test/java/org/jboss/as/test/integration/web/servlet/overlays/ServletResourceOverlaysTestCase.java",
        "class_name": "ServletResourceOverlaysTestCase",
        "method_name": "testLifeCycle",
        "signature": "void testLifeCycle()",
        "lines_hint_csv": [
          71,
          77
        ],
        "code": "    public void testLifeCycle() throws Exception {\n        String result = performCall(url, \"a.txt\");\n        assertEquals(\"a\", result);\n        result = performCall(url, \"b.txt\");\n        assertEquals(\"b\", result);\n        result = performCall(url, \"c.txt\");\n        assertEquals(\"c - overlay\", result);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          71,
          78
        ]
      },
      {
        "file_path": "undertow/src/main/java/org/wildfly/extension/undertow/deployment/ServletResourceManager.java",
        "class_name": "ServletResourceManager",
        "method_name": "getResource",
        "signature": "Resource getResource(String)",
        "lines_hint_csv": [
          72,
          96
        ],
        "code": "    public Resource getResource(final String path) throws IOException {\n        Resource res = deploymentResourceManager.getResource(path);\n        if (res != null) {\n            return new ServletResource(this, res);\n        }\n        String p = path;\n        if (p.startsWith(\"/\")) {\n            p = p.substring(1);\n        }\n        if (overlays != null) {\n            for (VirtualFile overlay : overlays) {\n                VirtualFile child = overlay.getChild(p);\n                if (child.exists()) {\n                    return new ServletResource(this, new VirtualFileResource(overlay.getPhysicalFile(), child, path));\n                }\n            }\n        }\n        for (int i = 0; i < externalOverlays.length; ++i) {\n            ResourceManager manager = externalOverlays[i];\n            res = manager.getResource(path);\n            if(res != null) {\n                return res;\n            }\n        }\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          68,
          93
        ]
      },
      {
        "file_path": "testsuite/integration/web/src/test/java/org/jboss/as/test/integration/web/servlet/overlays/ServletResourceOverlaysTestCase.java",
        "class_name": "ServletResourceOverlaysTestCase",
        "method_name": "single",
        "signature": "WebArchive single()",
        "lines_hint_csv": [
          61,
          77
        ],
        "code": "    public static WebArchive single() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"single.war\");\n        war.addAsWebResource(new StringAsset(\"a\"), \"a.txt\");\n        war.addAsWebResource(new StringAsset(\"b\"), \"b.txt\");\n\n        JavaArchive jar = ShrinkWrap.create(JavaArchive.class, \"test.jar\");\n        jar.addAsManifestResource(new StringAsset(\"b - overlay\"), new BasicPath(\"resources\", \"b.txt\"));\n        jar.addAsManifestResource(new StringAsset(\"c - overlay\"), new BasicPath(\"resources\", \"c.txt\"));\n\n        war.addAsLibrary(jar);\n        return war;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          52,
          63
        ]
      },
      {
        "file_path": "testsuite/integration/web/src/test/java/org/jboss/as/test/integration/web/servlet/overlays/ServletResourceOverlaysTestCase.java",
        "class_name": "ServletResourceOverlaysTestCase",
        "method_name": "testPathAccess",
        "signature": "void testPathAccess()",
        "lines_hint_csv": [
          102,
          130
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "testsuite/integration/web/src/test/java/org/jboss/as/test/integration/web/servlet/overlays/ServletResourceOverlaysTestCase.java",
        "class_name": "ServletResourceOverlaysTestCase",
        "method_name": "testLifeCycle",
        "signature": "void testLifeCycle()",
        "lines_hint_csv": [
          86,
          92
        ],
        "code": "    public void testLifeCycle() throws Exception {\n        String result = performCall(url, \"a.txt\");\n        assertEquals(\"a\", result);\n        result = performCall(url, \"b.txt\");\n        assertEquals(\"b\", result);\n        result = performCall(url, \"c.txt\");\n        assertEquals(\"c - overlay\", result);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          71,
          78
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-12542",
    "project_slug": "vert-x3__vertx-web_CVE-2018-12542_3.5.3.CR1",
    "buggy_commit_id": "3fe3873cc28b4d833c90f8989ff797a7b463da2c",
    "github_url": "https://github.com/vert-x3/vertx-web",
    "nvd_metadata": {
      "description": "In version from 3.0.0 to 3.5.3 of Eclipse Vert.x, the StaticHandler uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '\\' (forward slashes) sequences that can resolve to a location that is outside of that directory when running on Windows Operating Systems.",
      "published_date": "2018-10-10T20:29:00.553",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "vertx-web/src/main/java/io/vertx/ext/web/handler/impl/StaticHandlerImpl.java",
        "class_name": "StaticHandlerImpl",
        "method_name": "handle",
        "signature": "void handle(RoutingContext)",
        "lines_hint_csv": [
          132,
          152
        ],
        "code": "  public void handle(RoutingContext context) {\n    HttpServerRequest request = context.request();\n    if (request.method() != HttpMethod.GET && request.method() != HttpMethod.HEAD) {\n      if (log.isTraceEnabled()) log.trace(\"Not GET or HEAD so ignoring request\");\n      context.next();\n    } else {\n      String path = Utils.removeDots(Utils.urlDecode(context.normalisedPath(), false));\n      // if the normalized path is null it cannot be resolved\n      if (path == null) {\n        log.warn(\"Invalid path: \" + context.request().path());\n        context.next();\n        return;\n      }\n\n      // only root is known for sure to be a directory. all other directories must be identified as such.\n      if (!directoryListing && \"/\".equals(path)) {\n        path = indexPage;\n      }\n\n      // can be called recursive for index pages\n      sendStatic(context, path);\n\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          132,
          155
        ]
      },
      {
        "file_path": "vertx-web/src/main/java/io/vertx/ext/web/handler/impl/StaticHandlerImpl.java",
        "class_name": "StaticHandlerImpl",
        "method_name": "sendStatic",
        "signature": "void sendStatic(RoutingContext,String)",
        "lines_hint_csv": [
          157,
          218
        ],
        "code": "  private void sendStatic(RoutingContext context, String path) {\n\n    String file = null;\n\n    if (!includeHidden) {\n      file = getFile(path, context);\n      int idx = file.lastIndexOf('/');\n      String name = file.substring(idx + 1);\n      if (name.length() > 0 && name.charAt(0) == '.') {\n        // skip\n        context.next();\n        return;\n      }\n    }\n\n    // Look in cache\n    CacheEntry entry;\n    if (cachingEnabled) {\n      entry = propsCache().get(path);\n      if (entry != null) {\n        HttpServerRequest request = context.request();\n        if ((filesReadOnly || !entry.isOutOfDate()) && entry.shouldUseCached(request)) {\n          context.response().setStatusCode(NOT_MODIFIED.code()).end();\n          return;\n        }\n      }\n    }\n\n    if (file == null) {\n      file = getFile(path, context);\n    }\n\n    final String sfile = file;\n\n    // verify if the file exists\n    isFileExisting(context, sfile, exists -> {\n      if (exists.failed()) {\n        context.fail(exists.cause());\n        return;\n      }\n\n      // file does not exist, continue...\n      if (!exists.result()) {\n        context.next();\n        return;\n      }\n\n      // Need to read the props from the filesystem\n      getFileProps(context, sfile, res -> {\n        if (res.succeeded()) {\n          FileProps fprops = res.result();\n          if (fprops == null) {\n            // File does not exist\n            context.next();\n          } else if (fprops.isDirectory()) {\n            sendDirectory(context, path, sfile);\n          } else {\n            propsCache().put(path, new CacheEntry(fprops, System.currentTimeMillis()));\n            sendFile(context, sfile, fprops);\n          }\n        } else {\n          context.fail(res.cause());\n        }\n      });\n    });\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          157,
          222
        ]
      },
      {
        "file_path": "vertx-web/src/test/java/io/vertx/ext/web/handler/StaticHandlerTest.java",
        "class_name": "StaticHandlerTest",
        "method_name": "testHandlerAfter",
        "signature": "void testHandlerAfter()",
        "lines_hint_csv": [
          703,
          705
        ],
        "code": "  public void testHandlerAfter() throws Exception {\n    router.get().handler(ctx -> ctx.response().end(\"Howdy!\"));\n    testRequest(HttpMethod.GET, \"/not-existing-file.html\", 200, \"OK\", \"Howdy!\");\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          703,
          706
        ]
      },
      {
        "file_path": "vertx-web/src/test/java/io/vertx/ext/web/handler/StaticHandlerTest.java",
        "class_name": "StaticHandlerTest",
        "method_name": "toDateTime",
        "signature": "long toDateTime(String)",
        "lines_hint_csv": [
          713,
          719
        ],
        "code": "  private long toDateTime(String header) {\n    try {\n      Date date = dateTimeFormatter.parse(header);\n      return date.getTime();\n    } catch (Exception e) {\n      fail(e.getMessage());\n      return -1;\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          713,
          721
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-8041",
    "project_slug": "apache__camel_CVE-2018-8041_2.20.3",
    "buggy_commit_id": "32bfda73ddd1ea8576bcb53dac496af9e0825f1a",
    "github_url": "https://github.com/apache/camel",
    "nvd_metadata": {
      "description": "Apache Camel's Mail 2.20.0 through 2.20.3, 2.21.0 through 2.21.1 and 2.22.0 is vulnerable to path traversal.",
      "published_date": "2018-09-17T14:29:00.920",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java",
        "class_name": "MailBinding",
        "method_name": "extractAttachmentsFromMultipart",
        "signature": "void extractAttachmentsFromMultipart(Multipart,Map)",
        "lines_hint_csv": [
          305,
          342
        ],
        "code": "    protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #\" + i + \": \" + part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #\" + i + \": is mimetype: multipart/*\");\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = part.getFileName();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          305,
          347
        ]
      },
      {
        "file_path": "components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java",
        "class_name": "MailBinding",
        "method_name": "extractAttachmentsFromMultipart",
        "signature": "void extractAttachmentsFromMultipart(Multipart,Map)",
        "lines_hint_csv": [
          305,
          342
        ],
        "code": "    protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #\" + i + \": \" + part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #\" + i + \": is mimetype: multipart/*\");\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = part.getFileName();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          305,
          347
        ]
      },
      {
        "file_path": "components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java",
        "class_name": "MailBinding",
        "method_name": "extractAttachmentsFromMultipart",
        "signature": "void extractAttachmentsFromMultipart(Multipart,Map)",
        "lines_hint_csv": [
          305,
          342
        ],
        "code": "    protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #\" + i + \": \" + part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #\" + i + \": is mimetype: multipart/*\");\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = part.getFileName();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          305,
          347
        ]
      },
      {
        "file_path": "components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java",
        "class_name": "MailBinding",
        "method_name": "extractAttachmentsFromMultipart",
        "signature": "void extractAttachmentsFromMultipart(Multipart,Map)",
        "lines_hint_csv": [
          305,
          342
        ],
        "code": "    protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #\" + i + \": \" + part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #\" + i + \": is mimetype: multipart/*\");\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = part.getFileName();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          305,
          347
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-17297",
    "project_slug": "dromara__hutool_CVE-2018-17297_4.1.11",
    "buggy_commit_id": "7687720c5125b29386d3bb9c7c2931da79664b73",
    "github_url": "https://github.com/dromara/hutool",
    "nvd_metadata": {
      "description": "The unzip function in ZipUtil.java in Hutool before 4.1.12 allows remote attackers to overwrite arbitrary files via directory traversal sequences in a filename within a ZIP archive.",
      "published_date": "2018-09-21T07:29:00.787",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "hutool-core/src/main/java/cn/hutool/core/io/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "file",
        "signature": "File file(String,String)",
        "lines_hint_csv": [
          323,
          325
        ],
        "code": "\tpublic static File file(String parent, String path) {\r\n\t\tif (StrUtil.isBlank(path)) {\r\n\t\t\tthrow new NullPointerException(\"File path is blank!\");\r\n\t\t}\r\n\t\treturn new File(parent, path);\r\n\t}\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          322,
          327
        ]
      },
      {
        "file_path": "hutool-core/src/main/java/cn/hutool/core/io/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "file",
        "signature": "File file(File,String)",
        "lines_hint_csv": [
          335,
          342
        ],
        "code": "\tpublic static File file(File parent, String path) {\r\n\t\tif (StrUtil.isBlank(path)) {\r\n\t\t\tthrow new NullPointerException(\"File path is blank!\");\r\n\t\t}\r\n\t\treturn new File(parent, path);\r\n\t}\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          336,
          341
        ]
      },
      {
        "file_path": "hutool-core/src/main/java/cn/hutool/core/io/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "file",
        "signature": "File file(File,String...)",
        "lines_hint_csv": [
          353,
          366
        ],
        "code": "\tpublic static File file(File directory, String... names) {\r\n\t\tAssert.notNull(directory, \"directorydirectory must not be null\");\r\n\t\tif (ArrayUtil.isEmpty(names)) {\r\n\t\t\treturn directory;\r\n\t\t}\r\n\r\n\t\tFile file = directory;\r\n\t\tfor (String name : names) {\r\n\t\t\tif (null != name) {\r\n\t\t\t\tfile = new File(file, name);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn file;\r\n\t}\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          351,
          364
        ]
      },
      {
        "file_path": "hutool-core/src/main/java/cn/hutool/core/io/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "file",
        "signature": "File file(String...)",
        "lines_hint_csv": [
          376,
          390
        ],
        "code": "\tpublic static File file(String... names) {\r\n\t\tif (ArrayUtil.isEmpty(names)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tFile file = null;\r\n\t\tfor (String name : names) {\r\n\t\t\tif (file == null) {\r\n\t\t\t\tfile = new File(name);\r\n\t\t\t} else {\r\n\t\t\t\tfile = new File(file, name);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn file;\r\n\t}\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          374,
          388
        ]
      },
      {
        "file_path": "hutool-core/src/main/java/cn/hutool/core/util/ZipUtil.java",
        "class_name": "ZipUtil",
        "method_name": "unzip",
        "signature": "File unzip(File,File,Charset)",
        "lines_hint_csv": [
          378,
          404
        ],
        "code": "\tpublic static File unzip(File zipFile, File outFile, Charset charset) throws UtilException {\r\n\t\tcharset = (null == charset) ? DEFAULT_CHARSET : charset;\r\n\r\n\t\tZipFile zipFileObj = null;\r\n\t\ttry {\r\n\t\t\tzipFileObj = new ZipFile(zipFile, charset);\r\n\t\t\tfinal Enumeration<ZipEntry> em = (Enumeration<ZipEntry>) zipFileObj.entries();\r\n\t\t\tZipEntry zipEntry = null;\r\n\t\t\tFile outItemFile = null;\r\n\t\t\twhile (em.hasMoreElements()) {\r\n\t\t\t\tzipEntry = em.nextElement();\r\n\t\t\t\toutItemFile = new File(outFile, zipEntry.getName());\r\n\t\t\t\tif (zipEntry.isDirectory()) {\r\n\t\t\t\t\toutItemFile.mkdirs();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tFileUtil.touch(outItemFile);\r\n\t\t\t\t\tcopy(zipFileObj, zipEntry, outItemFile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new UtilException(e);\r\n\t\t} finally {\r\n\t\t\tIoUtil.close(zipFileObj);\r\n\t\t}\r\n\t\treturn outFile;\r\n\t}\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          378,
          403
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-11762",
    "project_slug": "apache__tika_CVE-2018-11762_1.18",
    "buggy_commit_id": "38ff2a986af24ee255f1f91d654ea402f4016696",
    "github_url": "https://github.com/apache/tika",
    "nvd_metadata": {
      "description": "In Apache Tika 0.9 to 1.18, in a rare edge case where a user does not specify an extract directory on the commandline (--extract-dir=) and the input file has an embedded file with an absolute path, such as \"C:/evil.bat\", tika-app would overwrite that file.",
      "published_date": "2018-09-19T14:29:00.397",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "tika-app/src/main/java/org/apache/tika/cli/TikaCLI.java",
        "class_name": "FileEmbeddedDocumentExtractor",
        "method_name": "getOutputFile",
        "signature": "File getOutputFile(String,Metadata,MediaType)",
        "lines_hint_csv": [
          1101,
          1134
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "tika-app/src/test/java/org/apache/tika/cli/TikaCLITest.java",
        "class_name": "TikaCLITest",
        "method_name": "testConfigSerializationCustomStatic",
        "signature": "void testConfigSerializationCustomStatic()",
        "lines_hint_csv": [
          550,
          555
        ],
        "code": "    public void testConfigSerializationCustomStatic() throws Exception {\n        String[] params = new String[]{\n                \"--config=\" + testDataFile.toString() + \"/tika-config2.xml\", \"--dump-static-config\"};\n        TikaCLI.main(params);\n        String content = outContent.toString(UTF_8.name());\n        assertFalse(content.contains(\"org.apache.tika.parser.executable.Executable\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          505,
          511
        ]
      },
      {
        "file_path": "tika-app/src/main/java/org/apache/tika/cli/TikaCLI.java",
        "class_name": "TikaCLI",
        "method_name": "process",
        "signature": "void process(String)",
        "lines_hint_csv": [
          359,
          489
        ],
        "code": "    public void process(String arg) throws Exception {\n        if (arg.equals(\"-?\") || arg.equals(\"--help\")) {\n            pipeMode = false;\n            usage();\n        } else if (arg.equals(\"-V\") || arg.equals(\"--version\")) {\n            pipeMode = false;\n            version();\n        } else if (arg.equals(\"-v\") || arg.equals(\"--verbose\")) {\n            org.apache.log4j.Logger.getRootLogger().setLevel(Level.DEBUG);\n        } else if (arg.equals(\"-g\") || arg.equals(\"--gui\")) {\n            pipeMode = false;\n            if (configFilePath != null){\n                TikaGUI.main(new String[]{configFilePath});\n            } else {\n                TikaGUI.main(new String[0]);\n            }\n        } else if (arg.equals(\"--list-parser\") || arg.equals(\"--list-parsers\")) {\n            pipeMode = false;\n            displayParsers(false, false);\n        } else if (arg.equals(\"--list-detector\") || arg.equals(\"--list-detectors\")) {\n           pipeMode = false;\n           displayDetectors();\n        } else if (arg.equals(\"--list-parser-detail\") || arg.equals(\"--list-parser-details\")) {\n            pipeMode = false;\n            displayParsers(true, false);\n        } else if (arg.equals(\"--list-parser-detail-apt\") || arg.equals(\"--list-parser-details-apt\")) {\n            pipeMode = false;\n            displayParsers(true, true);\n        } else if(arg.equals(\"--list-met-models\")){\n            pipeMode = false;\n            displayMetModels();\n        } else if(arg.equals(\"--list-supported-types\")){\n            pipeMode = false;\n            displaySupportedTypes();\n        } else if (arg.startsWith(\"--compare-file-magic=\")) {\n            pipeMode = false;\n            compareFileMagic(arg.substring(arg.indexOf('=')+1));\n        } else if (arg.equals(\"--dump-minimal-config\")) {\n            pipeMode = false;\n            dumpConfig(TikaConfigSerializer.Mode.MINIMAL);\n        } else if (arg.equals(\"--dump-current-config\")) {\n            pipeMode = false;\n            dumpConfig(TikaConfigSerializer.Mode.CURRENT);\n        } else if (arg.equals(\"--dump-static-config\")) {\n            pipeMode = false;\n            dumpConfig(TikaConfigSerializer.Mode.STATIC);\n        } else if (arg.equals(\"--dump-static-full-config\")) {\n            pipeMode = false;\n            dumpConfig(TikaConfigSerializer.Mode.STATIC_FULL);\n        } else if (arg.equals(\"--container-aware\")\n                || arg.equals(\"--container-aware-detector\")) {\n            // ignore, as container-aware detectors are now always used\n        } else if (arg.equals(\"-f\") || arg.equals(\"--fork\")) {\n            fork = true;\n        } else if (arg.startsWith(\"--config=\")) {\n            configFilePath = arg.substring(\"--config=\".length());\n        } else if (arg.startsWith(\"--digest=\")) {\n            digester = new CommonsDigester(MAX_MARK,\n                    arg.substring(\"--digest=\".length()));\n        } else if (arg.startsWith(\"-e\")) {\n            encoding = arg.substring(\"-e\".length());\n        } else if (arg.startsWith(\"--encoding=\")) {\n            encoding = arg.substring(\"--encoding=\".length());\n        } else if (arg.startsWith(\"-p\") && !arg.equals(\"-p\")) {\n            password = arg.substring(\"-p\".length());\n        } else if (arg.startsWith(\"--password=\")) {\n            password = arg.substring(\"--password=\".length());\n        } else  if (arg.equals(\"-j\") || arg.equals(\"--json\")) {\n            type = JSON;\n        } else if (arg.equals(\"-J\") || arg.equals(\"--jsonRecursive\")) {\n            recursiveJSON = true;\n        } else if (arg.equals(\"-y\") || arg.equals(\"--xmp\")) {\n            type = XMP;\n        } else if (arg.equals(\"-x\") || arg.equals(\"--xml\")) {\n            type = XML;\n        } else if (arg.equals(\"-h\") || arg.equals(\"--html\")) {\n            type = HTML;\n        } else if (arg.equals(\"-t\") || arg.equals(\"--text\")) {\n            type = TEXT;\n        } else if (arg.equals(\"-T\") || arg.equals(\"--text-main\")) {\n            type = TEXT_MAIN;\n        } else if (arg.equals(\"-m\") || arg.equals(\"--metadata\")) {\n            type = METADATA;\n        } else if (arg.equals(\"-l\") || arg.equals(\"--language\")) {\n            type = LANGUAGE;\n        } else if (arg.equals(\"-d\") || arg.equals(\"--detect\")) {\n            type = DETECT;\n        } else if (arg.startsWith(\"--extract-dir=\")) {\n            extractDir = new File(arg.substring(\"--extract-dir=\".length()));\n        } else if (arg.equals(\"-z\") || arg.equals(\"--extract\")) {\n            extractInlineImagesFromPDFs();\n            type = NO_OUTPUT;\n            context.set(EmbeddedDocumentExtractor.class, new FileEmbeddedDocumentExtractor());\n        } else if (arg.equals(\"-r\") || arg.equals(\"--pretty-print\")) {\n            prettyPrint = true;\n        } else if (arg.equals(\"-p\") || arg.equals(\"--port\")\n                || arg.equals(\"-s\") || arg.equals(\"--server\")) {\n            serverMode = true;\n            pipeMode = false;\n        } else if (arg.startsWith(\"-c\")) {\n            networkURI = new URI(arg.substring(\"-c\".length()));\n        } else if (arg.startsWith(\"--client=\")) {\n            networkURI = new URI(arg.substring(\"-c\".length()));\n        } else {\n            pipeMode = false;\n            configure();\n            \n            if (serverMode) {\n                new TikaServer(Integer.parseInt(arg)).start();\n            } else if (arg.equals(\"-\")) {\n                try (InputStream stream = TikaInputStream.get(\n                        new CloseShieldInputStream(System.in))) {\n                    type.process(stream, System.out, new Metadata());\n                }\n            } else {\n                URL url;\n                File file = new File(arg);\n                if (file.isFile()) {\n                    url = file.toURI().toURL();\n                } else {\n                    url = new URL(arg);\n                }\n                if (recursiveJSON) {\n                    handleRecursiveJson(url, System.out);\n                } else {\n                    Metadata metadata = new Metadata();\n                    try (InputStream input =\n                            TikaInputStream.get(url, metadata)) {\n                        type.process(input, System.out, metadata);\n                    } finally {\n                        System.out.flush();\n                    }\n                }\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          358,
          493
        ]
      },
      {
        "file_path": "tika-app/src/main/java/org/apache/tika/cli/TikaCLI.java",
        "class_name": "FileEmbeddedDocumentExtractor",
        "method_name": "parseEmbedded",
        "signature": "void parseEmbedded(InputStream,ContentHandler,Metadata,boolean)",
        "lines_hint_csv": [
          1040,
          1098
        ],
        "code": "        public void parseEmbedded(InputStream inputStream, ContentHandler contentHandler, Metadata metadata, boolean outputHtml) throws SAXException, IOException {\n            String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n\n            if (name == null) {\n                name = \"file\" + count++;\n            }\n            if (! inputStream.markSupported()) {\n                inputStream = TikaInputStream.get(inputStream);\n            }\n            MediaType contentType = detector.detect(inputStream, metadata);\n\n            if (name.indexOf('.')==-1 && contentType!=null) {\n                try {\n                    name += config.getMimeRepository().forName(\n                            contentType.toString()).getExtension();\n                } catch (MimeTypeException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            String relID = metadata.get(Metadata.EMBEDDED_RELATIONSHIP_ID);\n            if (relID != null && !name.startsWith(relID)) {\n                name = relID + \"_\" + name;\n            }\n\n            File outputFile = new File(extractDir, FilenameUtils.normalize(name));\n            File parent = outputFile.getParentFile();\n            if (!parent.exists()) {\n                if (!parent.mkdirs()) {\n                    throw new IOException(\"unable to create directory \\\"\" + parent + \"\\\"\");\n                }\n            }\n            System.out.println(\"Extracting '\"+name+\"' (\"+contentType+\") to \" + outputFile);\n\n            try (FileOutputStream os = new FileOutputStream(outputFile)) {\n                if (inputStream instanceof TikaInputStream) {\n                    TikaInputStream tin = (TikaInputStream) inputStream;\n\n                    if (tin.getOpenContainer() != null && tin.getOpenContainer() instanceof DirectoryEntry) {\n                        POIFSFileSystem fs = new POIFSFileSystem();\n                        copy((DirectoryEntry) tin.getOpenContainer(), fs.getRoot());\n                        fs.writeFilesystem(os);\n                    } else {\n                        IOUtils.copy(inputStream, os);\n                    }\n                } else {\n                    IOUtils.copy(inputStream, os);\n                }\n            } catch (Exception e) {\n                //\n                // being a CLI program messages should go to the stderr too\n                //\n                String msg = String.format(\n                    Locale.ROOT,\n                    \"Ignoring unexpected exception trying to save embedded file %s (%s)\",\n                    name,\n                    e.getMessage()\n                );\n                LOG.warn(msg, e);\n            }\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1038,
          1098
        ]
      },
      {
        "file_path": "tika-app/src/main/java/org/apache/tika/cli/TikaCLI.java",
        "class_name": "NoDocumentXMPMetaHandler",
        "method_name": "endDocument",
        "signature": "void endDocument()",
        "lines_hint_csv": [
          1232,
          1244
        ],
        "code": "        public void endDocument() throws SAXException \n        {\n        \ttry \n        \t{\n        \t\tXMPMetadata xmp = new XMPMetadata(metadata);\n        \t\tString result;\n        \t\tresult = xmp.toString();\n        \t\twriter.write(result);\n        \t\twriter.flush();\n        \t} \n        \tcatch (TikaException e) \n        \t{\n        \t\tthrow new SAXException(e);\n        \t}\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1230,
          1244
        ]
      },
      {
        "file_path": "tika-app/src/main/java/org/apache/tika/cli/TikaCLI.java",
        "class_name": "NoDocumentMetHandler",
        "method_name": "endDocument",
        "signature": "void endDocument()",
        "lines_hint_csv": [
          1195,
          1200
        ],
        "code": "        public void endDocument() {\n            String[] names = metadata.names();\n            Arrays.sort(names);\n            outputMetadata(names);\n            writer.flush();\n            this.metOutput = true;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1193,
          1199
        ]
      },
      {
        "file_path": "tika-app/src/main/java/org/apache/tika/cli/TikaCLI.java",
        "class_name": "TikaServer",
        "method_name": "processSocketInBackground",
        "signature": "void processSocketInBackground(Socket)",
        "lines_hint_csv": [
          1151,
          1175
        ],
        "code": "        private void processSocketInBackground(final Socket socket) {\n            Thread thread = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        InputStream input = null;\n                        try {\n                            InputStream rawInput = socket.getInputStream();\n                            OutputStream output = socket.getOutputStream();\n                            input = TikaInputStream.get(rawInput);\n                            type.process(input, output, new Metadata());\n                            output.flush();\n                        } finally {\n                            if (input != null) {\n                                input.close();\n                            }\n                            socket.close();\n                        }\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            };\n            thread.setDaemon(true);\n            thread.start();\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1149,
          1174
        ]
      },
      {
        "file_path": "tika-app/src/main/java/org/apache/tika/cli/TikaCLI.java",
        "class_name": "NoDocumentXMPMetaHandler",
        "method_name": "NoDocumentXMPMetaHandler",
        "signature": "NoDocumentXMPMetaHandler(Metadata,PrintWriter)",
        "lines_hint_csv": [
          1226,
          1228
        ],
        "code": "        public NoDocumentXMPMetaHandler(Metadata metadata, PrintWriter writer){\n        \tthis.metadata = metadata;\n            this.writer = writer;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1224,
          1227
        ]
      },
      {
        "file_path": "tika-app/src/test/java/org/apache/tika/cli/TikaCLITest.java",
        "class_name": "TikaCLITest",
        "method_name": "testExtract",
        "signature": "void testExtract()",
        "lines_hint_csv": [
          248,
          282
        ],
        "code": "    public void testExtract() throws Exception {\n        File tempFile = File.createTempFile(\"tika-test-\", \"\");\n        tempFile.delete();\n        tempFile.mkdir(); // not really good method for production usage, but ok for tests\n        // google guava library has better solution\n\n        try {\n            String[] params = {\"--extract-dir=\"+tempFile.getAbsolutePath(),\"-z\", resourcePrefix + \"/coffee.xls\"};\n\n            TikaCLI.main(params);\n\n            StringBuffer allFiles = new StringBuffer();\n            for (String f : tempFile.list()) {\n                if (allFiles.length() > 0) allFiles.append(\" : \");\n                allFiles.append(f);\n            }\n\n            // ChemDraw file\n            File expectedCDX = new File(tempFile, \"MBD002B040A.cdx\");\n            // Image of the ChemDraw molecule\n            File expectedIMG = new File(tempFile, \"file4.png\");\n            // OLE10Native\n            File expectedOLE10 = new File(tempFile, \"MBD002B0FA6_file5.bin\");\n            // Something that really isnt a text file... Not sure what it is???\n            File expected262FE3 = new File(tempFile, \"MBD00262FE3.txt\");\n            // Image of one of the embedded resources\n            File expectedEMF = new File(tempFile, \"file0.emf\");\n\n            assertExtracted(expectedCDX, allFiles.toString());\n            assertExtracted(expectedIMG, allFiles.toString());\n            assertExtracted(expectedOLE10, allFiles.toString());\n            assertExtracted(expected262FE3, allFiles.toString());\n            assertExtracted(expectedEMF, allFiles.toString());\n        } finally {\n            FileUtils.deleteDirectory(tempFile);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          248,
          284
        ]
      },
      {
        "file_path": "tika-example/src/main/java/org/apache/tika/example/ExtractEmbeddedFiles.java",
        "class_name": "MyEmbeddedDocumentExtractor",
        "method_name": "parseEmbedded",
        "signature": "void parseEmbedded(InputStream,ContentHandler,Metadata,boolean)",
        "lines_hint_csv": [
          73,
          103
        ],
        "code": "        public void parseEmbedded(InputStream stream, ContentHandler handler, Metadata metadata, boolean outputHtml)\n                throws SAXException, IOException {\n\n            //try to get the name of the embedded file from the metadata\n            String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n\n            if (name == null) {\n                name = \"file_\" + fileCount++;\n            } else {\n                //make sure to select only the file name (not any directory paths\n                //that might be included in the name) and make sure\n                //to normalize the name\n                name = FilenameUtils.normalize(FilenameUtils.getName(name));\n            }\n\n            //now try to figure out the right extension for the embedded file\n            MediaType contentType = detector.detect(stream, metadata);\n\n            if (name.indexOf('.') == -1 && contentType != null) {\n                try {\n                    name += config.getMimeRepository().forName(\n                            contentType.toString()).getExtension();\n                } catch (MimeTypeException e) {\n                    e.printStackTrace();\n                }\n            }\n            //should add check to make sure that you aren't overwriting a file\n            Path outputFile = outputDir.resolve(name);\n            //do a better job than this of checking\n            Files.createDirectories(outputFile.getParent());\n            Files.copy(stream, outputFile);\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          73,
          104
        ]
      },
      {
        "file_path": "tika-server/src/main/java/org/apache/tika/server/resource/UnpackerResource.java",
        "class_name": "MyEmbeddedDocumentExtractor",
        "method_name": "parseEmbedded",
        "signature": "void parseEmbedded(InputStream,ContentHandler,Metadata,boolean)",
        "lines_hint_csv": [
          173,
          240
        ],
        "code": "        public void parseEmbedded(InputStream inputStream, ContentHandler contentHandler, Metadata metadata, boolean b) throws SAXException, IOException {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            IOUtils.copy(inputStream, bos);\n            byte[] data = bos.toByteArray();\n\n            String name = metadata.get(TikaMetadataKeys.RESOURCE_NAME_KEY);\n            String contentType = metadata.get(org.apache.tika.metadata.HttpHeaders.CONTENT_TYPE);\n\n            if (name == null) {\n                name = Integer.toString(count.intValue());\n            }\n\n            if (!name.contains(\".\") && contentType != null) {\n                try {\n                    String ext = TikaResource.getConfig().getMimeRepository().forName(contentType).getExtension();\n\n                    if (ext != null) {\n                        name += ext;\n                    }\n                } catch (MimeTypeException e) {\n                    LOG.warn(\"Unexpected MimeTypeException\", e);\n                }\n            }\n\n            if (\"application/vnd.openxmlformats-officedocument.oleObject\".equals(contentType)) {\n                POIFSFileSystem poifs = new POIFSFileSystem(new ByteArrayInputStream(data));\n                OfficeParser.POIFSDocumentType type = OfficeParser.POIFSDocumentType.detectType(poifs);\n\n                if (type == OfficeParser.POIFSDocumentType.OLE10_NATIVE) {\n                    try {\n                        Ole10Native ole = Ole10Native.createFromEmbeddedOleObject(poifs);\n                        if (ole.getDataSize() > 0) {\n                            String label = ole.getLabel();\n\n                            if (label.startsWith(\"ole-\")) {\n                                label = Integer.toString(count.intValue()) + '-' + label;\n                            }\n\n                            name = label;\n\n                            data = ole.getDataBuffer();\n                        }\n                    } catch (Ole10NativeException ex) {\n                        LOG.warn(\"Skipping invalid part\", ex);\n                    }\n                } else {\n                    name += '.' + type.getExtension();\n                }\n            }\n\n            final String finalName = name;\n\n            if (data.length > 0) {\n                zout.put(finalName, data);\n\n                count.increment();\n            } else {\n                if (inputStream instanceof TikaInputStream) {\n                    TikaInputStream tin = (TikaInputStream) inputStream;\n\n                    if (tin.getOpenContainer() != null && tin.getOpenContainer() instanceof DirectoryEntry) {\n                        POIFSFileSystem fs = new POIFSFileSystem();\n                        copy((DirectoryEntry) tin.getOpenContainer(), fs.getRoot());\n                        ByteArrayOutputStream bos2 = new ByteArrayOutputStream();\n                        fs.writeFilesystem(bos2);\n                        bos2.close();\n\n                        zout.put(finalName, bos2.toByteArray());\n                    }\n                }\n            }\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          173,
          244
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-1000850",
    "project_slug": "square__retrofit_CVE-2018-1000850_2.4.0",
    "buggy_commit_id": "7158698314daa138e993fac6a590ed19d78a8599",
    "github_url": "https://github.com/square/retrofit",
    "nvd_metadata": {
      "description": "Square Retrofit version versions from (including) 2.0 and 2.5.0 (excluding) contains a Directory Traversal vulnerability in RequestBuilder class, method addPathParameter that can result in By manipulating the URL an attacker could add or delete resources otherwise unavailable to her.. This attack appear to be exploitable via An attacker should have access to an encoded path parameter on POST, PUT or DELETE request.. This vulnerability appears to have been fixed in 2.5.0 and later.",
      "published_date": "2018-12-20T15:29:02.423",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "retrofit/src/main/java/retrofit2/RequestBuilder.java",
        "class_name": "RequestBuilder",
        "method_name": "RequestBuilder",
        "signature": "RequestBuilder(String,HttpUrl,String,Headers,MediaType,boolean,boolean,boolean)",
        "lines_hint_csv": [
          49,
          69
        ],
        "code": "  RequestBuilder(String method, HttpUrl baseUrl, @Nullable String relativeUrl,\n      @Nullable Headers headers, @Nullable MediaType contentType, boolean hasBody,\n      boolean isFormEncoded, boolean isMultipart) {\n    this.method = method;\n    this.baseUrl = baseUrl;\n    this.relativeUrl = relativeUrl;\n    this.requestBuilder = new Request.Builder();\n    this.contentType = contentType;\n    this.hasBody = hasBody;\n\n    if (headers != null) {\n      requestBuilder.headers(headers);\n    }\n\n    if (isFormEncoded) {\n      // Will be set to 'body' in 'build'.\n      formBuilder = new FormBody.Builder();\n    } else if (isMultipart) {\n      // Will be set to 'body' in 'build'.\n      multipartBuilder = new MultipartBody.Builder();\n      multipartBuilder.setType(MultipartBody.FORM);\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          49,
          71
        ]
      },
      {
        "file_path": "retrofit/src/main/java/retrofit2/RequestBuilder.java",
        "class_name": "RequestBuilder",
        "method_name": "addPathParam",
        "signature": "void addPathParam(String,String,boolean)",
        "lines_hint_csv": [
          105,
          117
        ],
        "code": "  void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          89,
          95
        ]
      },
      {
        "file_path": "retrofit/src/main/java/retrofit2/RequestBuilder.java",
        "class_name": "RequestBuilder",
        "method_name": "canonicalizeForPath",
        "signature": "String canonicalizeForPath(String,boolean)",
        "lines_hint_csv": [
          97,
          113
        ],
        "code": "  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {\n    int codePoint;\n    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Slow path: the character at i requires encoding!\n        Buffer out = new Buffer();\n        out.writeUtf8(input, 0, i);\n        canonicalizeForPath(out, input, i, limit, alreadyEncoded);\n        return out.readUtf8();\n      }\n    }\n\n    // Fast path: no characters required encoding.\n    return input;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          97,
          114
        ]
      },
      {
        "file_path": "retrofit/src/main/java/retrofit2/RequestBuilder.java",
        "class_name": "RequestBuilder",
        "method_name": "canonicalizeForPath",
        "signature": "void canonicalizeForPath(Buffer,String,int,int,boolean)",
        "lines_hint_csv": [
          116,
          141
        ],
        "code": "  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,\n      boolean alreadyEncoded) {\n    Buffer utf8Buffer = null; // Lazily allocated.\n    int codePoint;\n    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (alreadyEncoded\n          && (codePoint == '\\t' || codePoint == '\\n' || codePoint == '\\f' || codePoint == '\\r')) {\n        // Skip this character.\n      } else if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Percent encode this character.\n        if (utf8Buffer == null) {\n          utf8Buffer = new Buffer();\n        }\n        utf8Buffer.writeUtf8CodePoint(codePoint);\n        while (!utf8Buffer.exhausted()) {\n          int b = utf8Buffer.readByte() & 0xff;\n          out.writeByte('%');\n          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);\n          out.writeByte(HEX_DIGITS[b & 0xf]);\n        }\n      } else {\n        // This character doesn't need encoding. Just copy it over.\n        out.writeUtf8CodePoint(codePoint);\n      }\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          116,
          144
        ]
      },
      {
        "file_path": "retrofit/src/test/java/retrofit2/RequestFactoryTest.java",
        "class_name": "Example",
        "method_name": "method",
        "signature": "Call method()",
        "lines_hint_csv": [
          964,
          965
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "retrofit/src/test/java/retrofit2/RequestFactoryTest.java",
        "class_name": "RequestFactoryTest",
        "method_name": "getWithQuery",
        "signature": "void getWithQuery()",
        "lines_hint_csv": [
          961,
          972
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "retrofit/src/test/java/retrofit2/RequestFactoryTest.java",
        "class_name": "RequestFactoryTest",
        "method_name": "getWithEncodedPathStillPreventsRequestSplitting",
        "signature": "void getWithEncodedPathStillPreventsRequestSplitting(String)",
        "lines_hint_csv": [
          867,
          878
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2019-0225",
    "project_slug": "apache__jspwiki_CVE-2019-0225_2.11.0.M2",
    "buggy_commit_id": "d48bcef107a14dd07ecd830ab817b8df796082a4",
    "github_url": "https://github.com/apache/jspwiki",
    "nvd_metadata": {
      "description": "A specially crafted url could be used to access files under the ROOT directory of the application on Apache JSPWiki 2.9.0 to 2.11.0.M2, which could be used by an attacker to obtain registered users' details.",
      "published_date": "2019-03-28T22:29:00.683",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": []
  },
  {
    "cve_id": "CVE-2019-0194",
    "project_slug": "apache__camel_CVE-2019-0194_2.21.4",
    "buggy_commit_id": "757bc836d1d9ed11d11de73c5dc72fc53617d6a0",
    "github_url": "https://github.com/apache/camel",
    "nvd_metadata": {
      "description": "Apache Camel's File is vulnerable to directory traversal. Camel 2.21.0 to 2.21.3, 2.22.0 to 2.22.2, 2.23.0 and the unsupported Camel 2.x (2.19 and earlier) versions may be also affected.",
      "published_date": "2019-04-30T22:29:00.607",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "camel-core/src/main/java/org/apache/camel/component/file/GenericFileEndpoint.java",
        "class_name": "GenericFileEndpoint",
        "method_name": "configureMessage",
        "signature": "void configureMessage(GenericFile,Message)",
        "lines_hint_csv": [
          1271,
          1292
        ],
        "code": "    public void configureMessage(GenericFile<T> file, Message message) {\n        message.setBody(file);\n\n        if (flatten) {\n            // when flatten the file name should not contain any paths\n            message.setHeader(Exchange.FILE_NAME, file.getFileNameOnly());\n        } else {\n            // compute name to set on header that should be relative to starting directory\n            String name = file.isAbsolute() ? file.getAbsoluteFilePath() : file.getRelativeFilePath();\n\n            // skip leading endpoint configured directory\n            String endpointPath = getConfiguration().getDirectory() + getFileSeparator();\n\n            // need to normalize paths to ensure we can match using startsWith\n            endpointPath = FileUtil.normalizePath(endpointPath);\n            String copyOfName = FileUtil.normalizePath(name);\n            if (ObjectHelper.isNotEmpty(endpointPath) && copyOfName.startsWith(endpointPath)) {\n                name = name.substring(endpointPath.length());\n            }\n\n            // adjust filename\n            message.setHeader(Exchange.FILE_NAME, name);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1198,
          1221
        ]
      },
      {
        "file_path": "camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java",
        "class_name": "GenericFileProducer",
        "method_name": "createTempFileName",
        "signature": "String createTempFileName(Exchange,String)",
        "lines_hint_csv": [
          383,
          417
        ],
        "code": "    public String createTempFileName(Exchange exchange, String fileName) {\n        String answer = fileName;\n\n        String tempName;\n        if (exchange.getIn().getHeader(Exchange.FILE_NAME) == null) {\n            // its a generated filename then add it to header so we can evaluate the expression\n            exchange.getIn().setHeader(Exchange.FILE_NAME, FileUtil.stripPath(fileName));\n            tempName = endpoint.getTempFileName().evaluate(exchange, String.class);\n            // and remove it again after evaluation\n            exchange.getIn().removeHeader(Exchange.FILE_NAME);\n        } else {\n            tempName = endpoint.getTempFileName().evaluate(exchange, String.class);\n        }\n\n        // check for both windows and unix separators\n        int pos = Math.max(answer.lastIndexOf(\"/\"), answer.lastIndexOf(\"\\\\\"));\n        if (pos == -1) {\n            // no path so use temp name as calculated\n            answer = tempName;\n        } else {\n            // path should be prefixed before the temp name\n            StringBuilder sb = new StringBuilder(answer.substring(0, pos + 1));\n            sb.append(tempName);\n            answer = sb.toString();\n        }\n\n        if (endpoint.getConfiguration().needToNormalize()) {\n            // must normalize path to cater for Windows and other OS\n            answer = normalizePath(answer);\n        }\n\n        // stack path in case the temporary file uses .. paths\n        answer = FileUtil.compactPath(answer, getFileSeparator());\n\n        return answer;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          389,
          424
        ]
      },
      {
        "file_path": "camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java",
        "class_name": "GenericFileProducer",
        "method_name": "createFileName",
        "signature": "String createFileName(Exchange)",
        "lines_hint_csv": [
          306,
          380
        ],
        "code": "    public String createFileName(Exchange exchange) {\n        String answer;\n\n        // overrule takes precedence\n        Object value;\n\n        Object overrule = exchange.getIn().getHeader(Exchange.OVERRULE_FILE_NAME);\n        if (overrule != null) {\n            if (overrule instanceof Expression) {\n                value = overrule;\n            } else {\n                value = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, overrule);\n            }\n        } else {\n            value = exchange.getIn().getHeader(Exchange.FILE_NAME);\n        }\n\n        // if we have an overrule then override the existing header to use the overrule computed name from this point forward\n        if (overrule != null) {\n            exchange.getIn().setHeader(Exchange.FILE_NAME, value);\n        }\n\n        if (value != null && value instanceof String && StringHelper.hasStartToken((String) value, \"simple\")) {\n            log.warn(\"Simple expression: {} detected in header: {} of type String. This feature has been removed (see CAMEL-6748).\", value, Exchange.FILE_NAME);\n        }\n\n        // expression support\n        Expression expression = endpoint.getFileName();\n        if (value instanceof Expression) {\n            expression = (Expression) value;\n        }\n\n        // evaluate the name as a String from the value\n        String name;\n        if (expression != null) {\n            log.trace(\"Filename evaluated as expression: {}\", expression);\n            name = expression.evaluate(exchange, String.class);\n        } else {\n            name = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, value);\n        }\n\n        // flatten name\n        if (name != null && endpoint.isFlatten()) {\n            // check for both windows and unix separators\n            int pos = Math.max(name.lastIndexOf(\"/\"), name.lastIndexOf(\"\\\\\"));\n            if (pos != -1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        // compute path by adding endpoint starting directory\n        String endpointPath = endpoint.getConfiguration().getDirectory();\n        String baseDir = \"\";\n        if (endpointPath.length() > 0) {\n            // Its a directory so we should use it as a base path for the filename\n            // If the path isn't empty, we need to add a trailing / if it isn't already there\n            baseDir = endpointPath;\n            boolean trailingSlash = endpointPath.endsWith(\"/\") || endpointPath.endsWith(\"\\\\\");\n            if (!trailingSlash) {\n                baseDir += getFileSeparator();\n            }\n        }\n        if (name != null) {\n            answer = baseDir + name;\n        } else {\n            // use a generated filename if no name provided\n            answer = baseDir + endpoint.getGeneratedFileName(exchange.getIn());\n        }\n\n        if (endpoint.getConfiguration().needToNormalize()) {\n            // must normalize path to cater for Windows and other OS\n            answer = normalizePath(answer);\n        }\n\n        return answer;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          312,
          387
        ]
      },
      {
        "file_path": "camel-core/src/test/java/org/apache/camel/component/file/FileProducerExpressionTest.java",
        "class_name": "FileProducerExpressionTest",
        "method_name": "testProducerComplexByExpression",
        "signature": "void testProducerComplexByExpression()",
        "lines_hint_csv": [
          82,
          87
        ],
        "code": "    public void testProducerComplexByExpression() throws Exception {\n        String expression = \"../filelanguageinbox/myfile-${bean:myguidgenerator.guid}-${date:now:yyyyMMdd}.txt\";\n        template.sendBody(\"file://target/filelanguage?fileName=\" + expression, \"Hello World\");\n\n        String date = new SimpleDateFormat(\"yyyyMMdd\").format(new Date());\n        assertFileExists(\"target/filelanguageinbox/myfile-123-\" + date + \".txt\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          75,
          81
        ]
      },
      {
        "file_path": "components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FtpProducerExpressionTest.java",
        "class_name": "FtpProducerExpressionTest",
        "method_name": "testProducerComplexByExpression",
        "signature": "void testProducerComplexByExpression()",
        "lines_hint_csv": [
          86,
          94
        ],
        "code": "    public void testProducerComplexByExpression() throws Exception {\n        // need one extra subdirectory (=foo) to be able to start with .. in the fileName option\n        String url = \"ftp://admin@localhost:\" + getPort() + \"/filelanguage/foo?password=admin\";\n        \n        String expression = \"../filelanguageinbox/myfile-${bean:myguidgenerator.guid}-${date:now:yyyyMMdd}.txt\";\n        template.sendBody(url + \"&fileName=\" + expression, \"Hello World\");\n\n        String date = new SimpleDateFormat(\"yyyyMMdd\").format(new Date());\n        assertFileExists(FTP_ROOT_DIR + \"/filelanguage/filelanguageinbox/myfile-123-\" + date + \".txt\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          86,
          95
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-0207",
    "project_slug": "asf__tapestry-5_CVE-2019-0207_5.4.4",
    "buggy_commit_id": "d29cc6778eb0c75e45139274005bba1c4f58907f",
    "github_url": "https://github.com/apache/tapestry-5",
    "nvd_metadata": {
      "description": "Tapestry processes assets `/assets/ctx` using classes chain `StaticFilesFilter -> AssetDispatcher -> ContextResource`, which doesn't filter the character `\\`, so attacker can perform a path traversal attack to read any files on Windows platform.",
      "published_date": "2019-09-16T17:15:13.183",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "tapestry-ioc/src/main/java/org/apache/tapestry5/ioc/internal/util/AbstractResource.java",
        "class_name": "AbstractResource",
        "method_name": "forFile",
        "signature": "Resource forFile(String)",
        "lines_hint_csv": [
          93,
          142
        ],
        "code": "    public final Resource forFile(String relativePath)\n    {\n        assert relativePath != null;\n\n        List<String> terms = CollectionFactory.newList();\n\n        for (String term : getFolder().split(\"/\"))\n        {\n            terms.add(term);\n        }\n\n        for (String term : relativePath.split(\"/\"))\n        {\n            // This will occur if the relative path contains sequential slashes\n\n            if (term.equals(\"\") || term.equals(\".\"))\n            {\n                continue;\n            }\n\n            if (term.equals(\"..\"))\n            {\n                if (terms.isEmpty())\n                {\n                    throw new IllegalStateException(String.format(\"Relative path '%s' for %s would go above root.\", relativePath, this));\n                }\n\n                terms.remove(terms.size() - 1);\n\n                continue;\n            }\n\n            // TODO: term blank or otherwise invalid?\n            // TODO: final term should not be \".\" or \"..\", or for that matter, the\n            // name of a folder, since a Resource should be a file within\n            // a folder.\n\n            terms.add(term);\n        }\n\n        StringBuilder path = new StringBuilder(100);\n        String sep = \"\";\n\n        for (String term : terms)\n        {\n            path.append(sep).append(term);\n            sep = \"/\";\n        }\n\n        return createResource(path.toString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          93,
          143
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-5410",
    "project_slug": "spring-cloud__spring-cloud-config_CVE-2020-5410_2.1.8.RELEASE",
    "buggy_commit_id": "91843a9ddc7489275b679568bfce1e4c37af71e1",
    "github_url": "https://github.com/spring-cloud/spring-cloud-config",
    "nvd_metadata": {
      "description": "Spring Cloud Config, versions 2.2.x prior to 2.2.3, versions 2.1.x prior to 2.1.9, and older unsupported versions allow applications to serve arbitrary configuration files through the spring-cloud-config-server module. A malicious user, or attacker, can send a request using a specially crafted URL that can lead to a directory traversal attack.",
      "published_date": "2020-06-02T17:15:11.690",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/GenericResourceRepository.java",
        "class_name": "GenericResourceRepository",
        "method_name": "findOne",
        "signature": "Resource findOne(String,String,String,String)",
        "lines_hint_csv": [
          53,
          82
        ],
        "code": "\tpublic synchronized Resource findOne(String application, String profile, String label,\n\t\t\tString path) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\tString[] locations = this.service.getLocations(application, profile, label)\n\t\t\t\t\t.getLocations();\n\t\t\ttry {\n\t\t\t\tfor (int i = locations.length; i-- > 0;) {\n\t\t\t\t\tString location = locations[i];\n\t\t\t\t\tif (PathUtils.isInvalidEncodedLocation(location)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (String local : getProfilePaths(profile, path)) {\n\t\t\t\t\t\tif (!PathUtils.isInvalidPath(local)\n\t\t\t\t\t\t\t\t&& !PathUtils.isInvalidEncodedPath(local)) {\n\t\t\t\t\t\t\tResource file = this.resourceLoader.getResource(location)\n\t\t\t\t\t\t\t\t\t.createRelative(local);\n\t\t\t\t\t\t\tif (file.exists() && file.isReadable()) {\n\t\t\t\t\t\t\t\treturn file;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new NoSuchResourceException(\n\t\t\t\t\t\t\"Error : \" + path + \". (\" + e.getMessage() + \")\");\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchResourceException(\"Not found: \" + path);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          53,
          83
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/test/java/org/springframework/cloud/config/server/resource/GenericResourceRepositoryTests.java",
        "class_name": "GenericResourceRepositoryTests",
        "method_name": "invalidPathWithPreviousDirectoryAllEncoded",
        "signature": "void invalidPathWithPreviousDirectoryAllEncoded()",
        "lines_hint_csv": [
          119,
          120
        ],
        "code": "\tpublic void invalidPathWithPreviousDirectoryAllEncoded() {\n\t\ttestInvalidPath(\"%2E%2E%2F\");\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          119,
          121
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-5405",
    "project_slug": "spring-cloud__spring-cloud-config_CVE-2020-5405_2.1.6.RELEASE",
    "buggy_commit_id": "24e7292e5930367396461354d3f9d8ba8b94771c",
    "github_url": "https://github.com/spring-cloud/spring-cloud-config",
    "nvd_metadata": {
      "description": "Spring Cloud Config, versions 2.2.x prior to 2.2.2, versions 2.1.x prior to 2.1.7, and older unsupported versions allow applications to serve arbitrary configuration files through the spring-cloud-config-server module. A malicious user, or attacker, can send a request using a specially crafted URL that can lead a directory traversal attack.",
      "published_date": "2020-03-05T19:15:11.700",
      "cvss_v3_score": 6.5,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "spring-cloud-config-client/src/main/java/org/springframework/cloud/config/client/ConfigServicePropertySourceLocator.java",
        "class_name": "ConfigServicePropertySourceLocator",
        "method_name": "getRemoteEnvironment",
        "signature": "Environment getRemoteEnvironment(RestTemplate,ConfigClientProperties,String,String)",
        "lines_hint_csv": [
          223,
          292
        ],
        "code": "\tprivate Environment getRemoteEnvironment(RestTemplate restTemplate,\n\t\t\tConfigClientProperties properties, String label, String state) {\n\t\tString path = \"/{name}/{profile}\";\n\t\tString name = properties.getName();\n\t\tString profile = properties.getProfile();\n\t\tString token = properties.getToken();\n\t\tint noOfUrls = properties.getUri().length;\n\t\tif (noOfUrls > 1) {\n\t\t\tlogger.info(\"Multiple Config Server Urls found listed.\");\n\t\t}\n\n\t\tObject[] args = new String[] { name, profile };\n\t\tif (StringUtils.hasText(label)) {\n\t\t\tif (label.contains(\"/\")) {\n\t\t\t\tlabel = label.replace(\"/\", \"(_)\");\n\t\t\t}\n\t\t\targs = new String[] { name, profile, label };\n\t\t\tpath = path + \"/{label}\";\n\t\t}\n\t\tResponseEntity<Environment> response = null;\n\n\t\tfor (int i = 0; i < noOfUrls; i++) {\n\t\t\tCredentials credentials = properties.getCredentials(i);\n\t\t\tString uri = credentials.getUri();\n\t\t\tString username = credentials.getUsername();\n\t\t\tString password = credentials.getPassword();\n\n\t\t\tlogger.info(\"Fetching config from server at : \" + uri);\n\n\t\t\ttry {\n\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\taddAuthorizationToken(properties, headers, username, password);\n\t\t\t\tif (StringUtils.hasText(token)) {\n\t\t\t\t\theaders.add(TOKEN_HEADER, token);\n\t\t\t\t}\n\t\t\t\tif (StringUtils.hasText(state) && properties.isSendState()) {\n\t\t\t\t\theaders.add(STATE_HEADER, state);\n\t\t\t\t}\n\t\t\t\theaders.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));\n\n\t\t\t\tfinal HttpEntity<Void> entity = new HttpEntity<>((Void) null, headers);\n\t\t\t\tresponse = restTemplate.exchange(uri + path, HttpMethod.GET, entity,\n\t\t\t\t\t\tEnvironment.class, args);\n\t\t\t}\n\t\t\tcatch (HttpClientErrorException e) {\n\t\t\t\tif (e.getStatusCode() != HttpStatus.NOT_FOUND) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ResourceAccessException e) {\n\t\t\t\tlogger.info(\"Connect Timeout Exception on Url - \" + uri\n\t\t\t\t\t\t+ \". Will be trying the next url if available\");\n\t\t\t\tif (i == noOfUrls - 1) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (response == null || response.getStatusCode() != HttpStatus.OK) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tEnvironment result = response.getBody();\n\t\t\treturn result;\n\t\t}\n\n\t\treturn null;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          188,
          257
        ]
      },
      {
        "file_path": "spring-cloud-config-client/src/main/java/org/springframework/cloud/config/environment/Environment.java",
        "class_name": "Environment",
        "method_name": "getProfiles",
        "signature": "String getProfiles()",
        "lines_hint_csv": [
          107,
          108
        ],
        "code": "\tpublic String[] getProfiles() {\n\t\treturn this.profiles;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          107,
          109
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/EnvironmentController.java",
        "class_name": "EnvironmentController",
        "method_name": "getEnvironment",
        "signature": "Environment getEnvironment(String,String,String,boolean)",
        "lines_hint_csv": [
          132,
          150
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/GenericResourceRepository.java",
        "class_name": "GenericResourceRepository",
        "method_name": "isInvalidEncodedPath",
        "signature": "boolean isInvalidEncodedPath(String)",
        "lines_hint_csv": [
          116,
          134
        ],
        "code": "\tprivate boolean isInvalidEncodedPath(String path) {\n\t\tif (path.contains(\"%\")) {\n\t\t\ttry {\n\t\t\t\t// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8\n\t\t\t\t// chars\n\t\t\t\tString decodedPath = URLDecoder.decode(path, \"UTF-8\");\n\t\t\t\tif (isInvalidPath(decodedPath)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tdecodedPath = processPath(decodedPath);\n\t\t\t\tif (isInvalidPath(decodedPath)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException | UnsupportedEncodingException ex) {\n\t\t\t\t// Should never happen...\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          116,
          135
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/GenericResourceRepository.java",
        "class_name": "GenericResourceRepository",
        "method_name": "findOne",
        "signature": "Resource findOne(String,String,String,String)",
        "lines_hint_csv": [
          60,
          85
        ],
        "code": "\tpublic synchronized Resource findOne(String application, String profile, String label,\n\t\t\tString path) {\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\tString[] locations = this.service.getLocations(application, profile, label)\n\t\t\t\t\t.getLocations();\n\t\t\ttry {\n\t\t\t\tfor (int i = locations.length; i-- > 0;) {\n\t\t\t\t\tString location = locations[i];\n\t\t\t\t\tfor (String local : getProfilePaths(profile, path)) {\n\t\t\t\t\t\tif (!isInvalidPath(local) && !isInvalidEncodedPath(local)) {\n\t\t\t\t\t\t\tResource file = this.resourceLoader.getResource(location)\n\t\t\t\t\t\t\t\t\t.createRelative(local);\n\t\t\t\t\t\t\tif (file.exists() && file.isReadable()) {\n\t\t\t\t\t\t\t\treturn file;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new NoSuchResourceException(\n\t\t\t\t\t\t\"Error : \" + path + \". (\" + e.getMessage() + \")\");\n\t\t\t}\n\t\t}\n\t\tthrow new NoSuchResourceException(\"Not found: \" + path);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          60,
          86
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/GenericResourceRepository.java",
        "class_name": "GenericResourceRepository",
        "method_name": "getProfilePaths",
        "signature": "Collection getProfilePaths(String,String)",
        "lines_hint_csv": [
          88,
          108
        ],
        "code": "\tprivate Collection<String> getProfilePaths(String profiles, String path) {\n\t\tSet<String> paths = new LinkedHashSet<>();\n\t\tfor (String profile : StringUtils.commaDelimitedListToSet(profiles)) {\n\t\t\tif (!StringUtils.hasText(profile) || \"default\".equals(profile)) {\n\t\t\t\tpaths.add(path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString ext = StringUtils.getFilenameExtension(path);\n\t\t\t\tString file = path;\n\t\t\t\tif (ext != null) {\n\t\t\t\t\text = \".\" + ext;\n\t\t\t\t\tfile = StringUtils.stripFilenameExtension(path);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\text = \"\";\n\t\t\t\t}\n\t\t\t\tpaths.add(file + \"-\" + profile + ext);\n\t\t\t}\n\t\t}\n\t\tpaths.add(path);\n\t\treturn paths;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          88,
          109
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java",
        "class_name": "ResourceController",
        "method_name": "binary",
        "signature": "byte binary(ServletWebRequest,String,String,String,String)",
        "lines_hint_csv": [
          200,
          212
        ],
        "code": "\tprivate synchronized byte[] binary(ServletWebRequest request, String name,\n\t\t\tString profile, String label, String path) throws IOException {\n\t\tname = resolveName(name);\n\t\tlabel = resolveLabel(label);\n\t\tResource resource = this.resourceRepository.findOne(name, profile, label, path);\n\t\tif (checkNotModified(request, resource)) {\n\t\t\t// Content was not modified. Just return.\n\t\t\treturn null;\n\t\t}\n\t\t// TODO: is this line needed for side effects?\n\t\tprepareEnvironment(this.environmentRepository.findOne(name, profile, label));\n\t\ttry (InputStream is = resource.getInputStream()) {\n\t\t\treturn StreamUtils.copyToByteArray(is);\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          154,
          168
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java",
        "class_name": "ResourceController",
        "method_name": "resolveName",
        "signature": "String resolveName(String)",
        "lines_hint_csv": [
          226,
          232
        ],
        "code": "\tprivate String resolveName(String name) {\n\t\tif (name != null && name.contains(\"(_)\")) {\n\t\t\t// \"(_)\" is uncommon in a git repo name, but \"/\" cannot be matched\n\t\t\t// by Spring MVC\n\t\t\tname = name.replace(\"(_)\", \"/\");\n\t\t}\n\t\treturn name;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          180,
          187
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java",
        "class_name": "ResourceController",
        "method_name": "retrieve",
        "signature": "String retrieve(ServletWebRequest,String,String,String,String,boolean)",
        "lines_hint_csv": [
          136,
          164
        ],
        "code": "\tsynchronized String retrieve(ServletWebRequest request, String name, String profile,\n\t\t\tString label, String path, boolean resolvePlaceholders) throws IOException {\n\t\tname = resolveName(name);\n\t\tlabel = resolveLabel(label);\n\t\tResource resource = this.resourceRepository.findOne(name, profile, label, path);\n\t\tif (checkNotModified(request, resource)) {\n\t\t\t// Content was not modified. Just return.\n\t\t\treturn null;\n\t\t}\n\t\t// ensure InputStream will be closed to prevent file locks on Windows\n\t\ttry (InputStream is = resource.getInputStream()) {\n\t\t\tString text = StreamUtils.copyToString(is, Charset.forName(\"UTF-8\"));\n\t\t\tif (resolvePlaceholders) {\n\t\t\t\tEnvironment environment = this.environmentRepository.findOne(name,\n\t\t\t\t\t\tprofile, label);\n\t\t\t\ttext = resolvePlaceholders(prepareEnvironment(environment), text);\n\t\t\t}\n\t\t\treturn text;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          103,
          122
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java",
        "class_name": "ResourceController",
        "method_name": "checkNotModified",
        "signature": "boolean checkNotModified(ServletWebRequest,Resource)",
        "lines_hint_csv": [
          216,
          223
        ],
        "code": "\tprivate boolean checkNotModified(ServletWebRequest request, Resource resource) {\n\t\ttry {\n\t\t\treturn request != null && request.checkNotModified(resource.lastModified());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// Ignore the exception since caching is optional.\n\t\t}\n\t\treturn false;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          170,
          178
        ]
      },
      {
        "file_path": "spring-cloud-config-server/src/test/java/org/springframework/cloud/config/server/resource/GenericResourceRepositoryTests.java",
        "class_name": "GenericResourceRepositoryTests",
        "method_name": "invalidPath",
        "signature": "void invalidPath()",
        "lines_hint_csv": [
          99,
          105
        ],
        "code": "\tpublic void invalidPath() {\n\t\tthis.exception.expect(NoSuchResourceException.class);\n\t\tthis.nativeRepository\n\t\t\t\t.setSearchLocations(\"file:./src/test/resources/test/{profile}\");\n\t\tthis.repository.findOne(\"blah\", \"local\", \"master\", \"..%2F..%2Fdata-jdbc.sql\");\n\t\tthis.output.expect(containsString(\n\t\t\t\t\"Path contains \\\"../\\\" after call to StringUtils#cleanPath\"));\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          99,
          106
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-17572",
    "project_slug": "apache__rocketmq_CVE-2019-17572_4.6.0",
    "buggy_commit_id": "d1b4e47c26576cf4fa543bbdd8c6f09643220bed",
    "github_url": "https://github.com/apache/rocketmq",
    "nvd_metadata": {
      "description": "In Apache RocketMQ 4.2.0 to 4.6.0, when the automatic topic creation in the broker is turned on by default, an evil topic like ../../../../topic2020 is sent from rocketmq-client to the broker, a topic folder will be created in the parent directory in brokers, which leads to a directory traversal vulnerability. Users of the affected versions should apply one of the following: Upgrade to Apache RocketMQ 4.6.1 or later.",
      "published_date": "2020-05-14T17:15:11.977",
      "cvss_v3_score": 5.3,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AbstractSendMessageProcessor.java",
        "class_name": "AbstractSendMessageProcessor",
        "method_name": "msgCheck",
        "signature": "RemotingCommand msgCheck(ChannelHandlerContext,SendMessageRequestHeader,RemotingCommand)",
        "lines_hint_csv": [
          165,
          232
        ],
        "code": "    protected RemotingCommand msgCheck(final ChannelHandlerContext ctx,\n        final SendMessageRequestHeader requestHeader, final RemotingCommand response) {\n        if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())\n            && this.brokerController.getTopicConfigManager().isOrderTopic(requestHeader.getTopic())) {\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n                + \"] sending message is forbidden\");\n            return response;\n        }\n        if (!this.brokerController.getTopicConfigManager().isTopicCanSendMessage(requestHeader.getTopic())) {\n            String errorMsg = \"the topic[\" + requestHeader.getTopic() + \"] is conflict with system reserved words.\";\n            log.warn(errorMsg);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorMsg);\n            return response;\n        }\n\n        TopicConfig topicConfig =\n            this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n        if (null == topicConfig) {\n            int topicSysFlag = 0;\n            if (requestHeader.isUnitMode()) {\n                if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                    topicSysFlag = TopicSysFlag.buildSysFlag(false, true);\n                } else {\n                    topicSysFlag = TopicSysFlag.buildSysFlag(true, false);\n                }\n            }\n\n            log.warn(\"the topic {} not exist, producer: {}\", requestHeader.getTopic(), ctx.channel().remoteAddress());\n            topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageMethod(\n                requestHeader.getTopic(),\n                requestHeader.getDefaultTopic(),\n                RemotingHelper.parseChannelRemoteAddr(ctx.channel()),\n                requestHeader.getDefaultTopicQueueNums(), topicSysFlag);\n\n            if (null == topicConfig) {\n                if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                    topicConfig =\n                        this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(\n                            requestHeader.getTopic(), 1, PermName.PERM_WRITE | PermName.PERM_READ,\n                            topicSysFlag);\n                }\n            }\n\n            if (null == topicConfig) {\n                response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n                response.setRemark(\"topic[\" + requestHeader.getTopic() + \"] not exist, apply first please!\"\n                    + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));\n                return response;\n            }\n        }\n\n        int queueIdInt = requestHeader.getQueueId();\n        int idValid = Math.max(topicConfig.getWriteQueueNums(), topicConfig.getReadQueueNums());\n        if (queueIdInt >= idValid) {\n            String errorInfo = String.format(\"request queueId[%d] is illegal, %s Producer: %s\",\n                queueIdInt,\n                topicConfig.toString(),\n                RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n            log.warn(errorInfo);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorInfo);\n\n            return response;\n        }\n        return response;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          165,
          233
        ]
      },
      {
        "file_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java",
        "class_name": "AdminBrokerProcessor",
        "method_name": "updateAndCreateTopic",
        "signature": "RemotingCommand updateAndCreateTopic(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          246,
          282
        ],
        "code": "    private synchronized RemotingCommand updateAndCreateTopic(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n        final CreateTopicRequestHeader requestHeader =\n            (CreateTopicRequestHeader) request.decodeCommandCustomHeader(CreateTopicRequestHeader.class);\n        log.info(\"updateAndCreateTopic called by {}\", RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n\n        if (requestHeader.getTopic().equals(this.brokerController.getBrokerConfig().getBrokerClusterName())) {\n            String errorMsg = \"the topic[\" + requestHeader.getTopic() + \"] is conflict with system reserved words.\";\n            log.warn(errorMsg);\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(errorMsg);\n            return response;\n        }\n\n        try {\n            response.setCode(ResponseCode.SUCCESS);\n            response.setOpaque(request.getOpaque());\n            response.markResponseType();\n            response.setRemark(null);\n            ctx.writeAndFlush(response);\n        } catch (Exception e) {\n            log.error(\"Failed to produce a proper response\", e);\n        }\n\n        TopicConfig topicConfig = new TopicConfig(requestHeader.getTopic());\n        topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());\n        topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());\n        topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());\n        topicConfig.setPerm(requestHeader.getPerm());\n        topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == null ? 0 : requestHeader.getTopicSysFlag());\n\n        this.brokerController.getTopicConfigManager().updateTopicConfig(topicConfig);\n\n        this.brokerController.registerIncrementBrokerData(topicConfig, this.brokerController.getTopicConfigManager().getDataVersion());\n\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          246,
          283
        ]
      },
      {
        "file_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java",
        "class_name": "AdminBrokerProcessor",
        "method_name": "updateGlobalWhiteAddrsConfig",
        "signature": "RemotingCommand updateGlobalWhiteAddrsConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          379,
          409
        ],
        "code": "    private synchronized RemotingCommand updateGlobalWhiteAddrsConfig(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        final UpdateGlobalWhiteAddrsConfigRequestHeader requestHeader =\n            (UpdateGlobalWhiteAddrsConfigRequestHeader) request.decodeCommandCustomHeader(UpdateGlobalWhiteAddrsConfigRequestHeader.class);\n\n        try {\n            AccessValidator accessValidator = this.brokerController.getAccessValidatorMap().get(PlainAccessValidator.class);\n            if (accessValidator.updateGlobalWhiteAddrsConfig(UtilAll.String2List(requestHeader.getGlobalWhiteAddrs(),\",\"))) {\n                response.setCode(ResponseCode.SUCCESS);\n                response.setOpaque(request.getOpaque());\n                response.markResponseType();\n                response.setRemark(null);\n                ctx.writeAndFlush(response);\n            } else {\n                String errorMsg = \"The globalWhiteAddresses[\" + requestHeader.getGlobalWhiteAddrs() + \"] has been updated failed.\";\n                log.warn(errorMsg);\n                response.setCode(ResponseCode.UPDATE_GLOBAL_WHITE_ADDRS_CONFIG_FAILED);\n                response.setRemark(errorMsg);\n                return response;\n            }\n        } catch (Exception e) {\n            log.error(\"Failed to generate a proper update globalWhiteAddresses response\", e);\n            response.setCode(ResponseCode.UPDATE_GLOBAL_WHITE_ADDRS_CONFIG_FAILED);\n            response.setRemark(e.getMessage());\n            return response;\n        }\n\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          379,
          410
        ]
      },
      {
        "file_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java",
        "class_name": "AdminBrokerProcessor",
        "method_name": "updateAndCreateAccessConfig",
        "signature": "RemotingCommand updateAndCreateAccessConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          302,
          341
        ],
        "code": "    private synchronized RemotingCommand updateAndCreateAccessConfig(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        final CreateAccessConfigRequestHeader requestHeader =\n            (CreateAccessConfigRequestHeader) request.decodeCommandCustomHeader(CreateAccessConfigRequestHeader.class);\n\n        PlainAccessConfig accessConfig = new PlainAccessConfig();\n        accessConfig.setAccessKey(requestHeader.getAccessKey());\n        accessConfig.setSecretKey(requestHeader.getSecretKey());\n        accessConfig.setWhiteRemoteAddress(requestHeader.getWhiteRemoteAddress());\n        accessConfig.setDefaultTopicPerm(requestHeader.getDefaultTopicPerm());\n        accessConfig.setDefaultGroupPerm(requestHeader.getDefaultGroupPerm());\n        accessConfig.setTopicPerms(UtilAll.String2List(requestHeader.getTopicPerms(),\",\"));\n        accessConfig.setGroupPerms(UtilAll.String2List(requestHeader.getGroupPerms(),\",\"));\n        accessConfig.setAdmin(requestHeader.isAdmin());\n        try {\n\n            AccessValidator accessValidator = this.brokerController.getAccessValidatorMap().get(PlainAccessValidator.class);\n            if (accessValidator.updateAccessConfig(accessConfig)) {\n                response.setCode(ResponseCode.SUCCESS);\n                response.setOpaque(request.getOpaque());\n                response.markResponseType();\n                response.setRemark(null);\n                ctx.writeAndFlush(response);\n            } else {\n                String errorMsg = \"The accesskey[\" + requestHeader.getAccessKey() + \"] corresponding to accessConfig has been updated failed.\";\n                log.warn(errorMsg);\n                response.setCode(ResponseCode.UPDATE_AND_CREATE_ACL_CONFIG_FAILED);\n                response.setRemark(errorMsg);\n                return response;\n            }\n        } catch (Exception e) {\n            log.error(\"Failed to generate a proper update accessvalidator response\", e);\n            response.setCode(ResponseCode.UPDATE_AND_CREATE_ACL_CONFIG_FAILED);\n            response.setRemark(e.getMessage());\n            return response;\n        }\n\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          302,
          342
        ]
      },
      {
        "file_path": "broker/src/main/java/org/apache/rocketmq/broker/topic/TopicConfigManager.java",
        "class_name": "TopicConfigManager",
        "method_name": "getSystemTopic",
        "signature": "Set getSystemTopic()",
        "lines_hint_csv": [
          151,
          152
        ],
        "code": "    public Set<String> getSystemTopic() {\n        return this.systemTopicList;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          151,
          153
        ]
      },
      {
        "file_path": "client/src/main/java/org/apache/rocketmq/client/Validators.java",
        "class_name": "Validators",
        "method_name": "regularExpressionMatcher",
        "signature": "boolean regularExpressionMatcher(String,Pattern)",
        "lines_hint_csv": [
          72,
          77
        ],
        "code": "    public static boolean regularExpressionMatcher(String origin, Pattern pattern) {\n        if (pattern == null) {\n            return true;\n        }\n        Matcher matcher = pattern.matcher(origin);\n        return matcher.matches();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          72,
          78
        ]
      },
      {
        "file_path": "client/src/main/java/org/apache/rocketmq/client/Validators.java",
        "class_name": "Validators",
        "method_name": "checkMessage",
        "signature": "void checkMessage(Message,DefaultMQProducer)",
        "lines_hint_csv": [
          83,
          102
        ],
        "code": "    public static void checkMessage(Message msg, DefaultMQProducer defaultMQProducer)\n        throws MQClientException {\n        if (null == msg) {\n            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, \"the message is null\");\n        }\n        // topic\n        Validators.checkTopic(msg.getTopic());\n\n        // body\n        if (null == msg.getBody()) {\n            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, \"the message body is null\");\n        }\n\n        if (0 == msg.getBody().length) {\n            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, \"the message body length is zero\");\n        }\n\n        if (msg.getBody().length > defaultMQProducer.getMaxMessageSize()) {\n            throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL,\n                \"the message body size over max value, MAX: \" + defaultMQProducer.getMaxMessageSize());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          83,
          104
        ]
      },
      {
        "file_path": "client/src/main/java/org/apache/rocketmq/client/Validators.java",
        "class_name": "Validators",
        "method_name": "checkTopic",
        "signature": "void checkTopic(String)",
        "lines_hint_csv": [
          109,
          127
        ],
        "code": "    public static void checkTopic(String topic) throws MQClientException {\n        if (UtilAll.isBlank(topic)) {\n            throw new MQClientException(\"The specified topic is blank\", null);\n        }\n\n        if (!regularExpressionMatcher(topic, PATTERN)) {\n            throw new MQClientException(String.format(\n                \"The specified topic[%s] contains illegal characters, allowing only %s\", topic,\n                VALID_PATTERN_STR), null);\n        }\n\n        if (topic.length() > CHARACTER_MAX_LENGTH) {\n            throw new MQClientException(\"The specified topic is longer than topic max length 255.\", null);\n        }\n\n        //whether the same with system reserved keyword\n        if (topic.equals(MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC)) {\n            throw new MQClientException(\n                String.format(\"The topic[%s] is conflict with AUTO_CREATE_TOPIC_KEY_TOPIC.\", topic), null);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          109,
          129
        ]
      },
      {
        "file_path": "client/src/main/java/org/apache/rocketmq/client/impl/MQAdminImpl.java",
        "class_name": "MQAdminImpl",
        "method_name": "createTopic",
        "signature": "void createTopic(String,String,int,int)",
        "lines_hint_csv": [
          81,
          131
        ],
        "code": "    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {\n        try {\n            TopicRouteData topicRouteData = this.mQClientFactory.getMQClientAPIImpl().getTopicRouteInfoFromNameServer(key, timeoutMillis);\n            List<BrokerData> brokerDataList = topicRouteData.getBrokerDatas();\n            if (brokerDataList != null && !brokerDataList.isEmpty()) {\n                Collections.sort(brokerDataList);\n\n                boolean createOKAtLeastOnce = false;\n                MQClientException exception = null;\n\n                StringBuilder orderTopicString = new StringBuilder();\n\n                for (BrokerData brokerData : brokerDataList) {\n                    String addr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);\n                    if (addr != null) {\n                        TopicConfig topicConfig = new TopicConfig(newTopic);\n                        topicConfig.setReadQueueNums(queueNum);\n                        topicConfig.setWriteQueueNums(queueNum);\n                        topicConfig.setTopicSysFlag(topicSysFlag);\n\n                        boolean createOK = false;\n                        for (int i = 0; i < 5; i++) {\n                            try {\n                                this.mQClientFactory.getMQClientAPIImpl().createTopic(addr, key, topicConfig, timeoutMillis);\n                                createOK = true;\n                                createOKAtLeastOnce = true;\n                                break;\n                            } catch (Exception e) {\n                                if (4 == i) {\n                                    exception = new MQClientException(\"create topic to broker exception\", e);\n                                }\n                            }\n                        }\n\n                        if (createOK) {\n                            orderTopicString.append(brokerData.getBrokerName());\n                            orderTopicString.append(\":\");\n                            orderTopicString.append(queueNum);\n                            orderTopicString.append(\";\");\n                        }\n                    }\n                }\n\n                if (exception != null && !createOKAtLeastOnce) {\n                    throw exception;\n                }\n            } else {\n                throw new MQClientException(\"Not found broker, maybe key is wrong\", null);\n            }\n        } catch (Exception e) {\n            throw new MQClientException(\"create new topic failed\", e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          81,
          133
        ]
      },
      {
        "file_path": "client/src/main/java/org/apache/rocketmq/client/impl/MQClientAPIImpl.java",
        "class_name": "MQClientAPIImpl",
        "method_name": "createPlainAccessConfig",
        "signature": "void createPlainAccessConfig(String,PlainAccessConfig,long)",
        "lines_hint_csv": [
          298,
          324
        ],
        "code": "    public void createPlainAccessConfig(final String addr, final PlainAccessConfig plainAccessConfig,\n        final long timeoutMillis)\n        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {\n        CreateAccessConfigRequestHeader requestHeader = new CreateAccessConfigRequestHeader();\n        requestHeader.setAccessKey(plainAccessConfig.getAccessKey());\n        requestHeader.setSecretKey(plainAccessConfig.getSecretKey());\n        requestHeader.setAdmin(plainAccessConfig.isAdmin());\n        requestHeader.setDefaultGroupPerm(plainAccessConfig.getDefaultGroupPerm());\n        requestHeader.setDefaultTopicPerm(plainAccessConfig.getDefaultTopicPerm());\n        requestHeader.setWhiteRemoteAddress(plainAccessConfig.getWhiteRemoteAddress());\n        requestHeader.setTopicPerms(UtilAll.List2String(plainAccessConfig.getTopicPerms(), \",\"));\n        requestHeader.setGroupPerms(UtilAll.List2String(plainAccessConfig.getGroupPerms(), \",\"));\n\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.UPDATE_AND_CREATE_ACL_CONFIG, requestHeader);\n\n        RemotingCommand response = this.remotingClient.invokeSync(MixAll.brokerVIPChannel(this.clientConfig.isVipChannelEnabled(), addr),\n            request, timeoutMillis);\n        assert response != null;\n        switch (response.getCode()) {\n            case ResponseCode.SUCCESS: {\n                return;\n            }\n            default:\n                break;\n        }\n\n        throw new MQClientException(response.getCode(), response.getRemark());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          298,
          325
        ]
      },
      {
        "file_path": "common/src/main/java/org/apache/rocketmq/common/UtilAll.java",
        "class_name": "UtilAll",
        "method_name": "String2List",
        "signature": "List String2List(String,String)",
        "lines_hint_csv": [
          598,
          604
        ],
        "code": "    public static List<String> String2List(String str, String splitor) {\n        if (StringUtils.isEmpty(str)) {\n            return null;\n        }\n\n        String[] addrArray = str.split(splitor);\n        return Arrays.asList(addrArray);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          598,
          605
        ]
      },
      {
        "file_path": "common/src/main/java/org/apache/rocketmq/common/UtilAll.java",
        "class_name": "UtilAll",
        "method_name": "List2String",
        "signature": "String List2String(List,String)",
        "lines_hint_csv": [
          583,
          595
        ],
        "code": "    public static String List2String(List<String> list, String splitor) {\n        if (list == null || list.size() == 0) {\n            return null;\n        }\n        StringBuffer str = new StringBuffer();\n        for (int i = 0; i < list.size(); i++) {\n            str.append(list.get(i));\n            if (i == list.size() - 1) {\n                continue;\n            }\n            str.append(splitor);\n        }\n        return str.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          583,
          596
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-35460",
    "project_slug": "joniles__mpxj_CVE-2020-35460_8.3.4",
    "buggy_commit_id": "87ea0ba33e901b87c95a18e3703ac51b59e2ee04",
    "github_url": "https://github.com/joniles/mpxj",
    "nvd_metadata": {
      "description": "common/InputStreamHelper.java in Packwood MPXJ before 8.3.5 allows directory traversal in the zip stream handler flow, leading to the writing of files to arbitrary locations.",
      "published_date": "2020-12-14T23:15:12.267",
      "cvss_v3_score": 5.3,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/net/sf/mpxj/common/InputStreamHelper.java",
        "class_name": "InputStreamHelper",
        "method_name": "processZipStream",
        "signature": "void processZipStream(File,InputStream)",
        "lines_hint_csv": [
          115,
          146
        ],
        "code": "   private static void processZipStream(File dir, InputStream inputStream) throws IOException\n   {\n      ZipInputStream zip = new ZipInputStream(inputStream);\n      while (true)\n      {\n         ZipEntry entry = zip.getNextEntry();\n         if (entry == null)\n         {\n            break;\n         }\n\n         File file = new File(dir, entry.getName());\n         if (entry.isDirectory())\n         {\n            FileHelper.mkdirsQuietly(file);\n            continue;\n         }\n\n         File parent = file.getParentFile();\n         if (parent != null)\n         {\n            FileHelper.mkdirsQuietly(parent);\n         }\n\n         FileOutputStream fos = new FileOutputStream(file);\n         byte[] bytes = new byte[1024];\n         int length;\n         while ((length = zip.read(bytes)) >= 0)\n         {\n            fos.write(bytes, 0, length);\n         }\n         fos.close();\n      }\n   }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          115,
          148
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-17519",
    "project_slug": "apache__flink_CVE-2020-17519_1.11.2",
    "buggy_commit_id": "fe3613574f76201a8d55d572a639a4ce7e18a9db",
    "github_url": "https://github.com/apache/flink",
    "nvd_metadata": {
      "description": "A change introduced in Apache Flink 1.11.0 (and released in 1.11.1 and 1.11.2 as well) allows attackers to read any file on the local filesystem of the JobManager through the REST interface of the JobManager process. Access is restricted to files accessible by the JobManager process. All users should upgrade to Flink 1.11.3 or 1.12.0 if their Flink instance(s) are exposed. The issue was fixed in commit b561010b0ee741543c3953306037f00d7a9f0801 from apache/flink:master.",
      "published_date": "2021-01-05T12:15:12.680",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/cluster/JobManagerCustomLogHandler.java",
        "class_name": "JobManagerCustomLogHandler",
        "method_name": "getFile",
        "signature": "File getFile(HandlerRequest)",
        "lines_hint_csv": [
          53,
          58
        ],
        "code": "\tprotected File getFile(HandlerRequest<EmptyRequestBody, FileMessageParameters> handlerRequest) {\n\t\tif (logDir == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString filename = handlerRequest.getPathParameter(LogFileNamePathParameter.class);\n\t\treturn new File(logDir, filename);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          53,
          59
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-8570",
    "project_slug": "kubernetes-client__java_CVE-2020-8570_client-java-parent-9.0.1",
    "buggy_commit_id": "796c74f4244cacd90d99393640ccaad0c72f8893",
    "github_url": "https://github.com/kubernetes-client/java",
    "nvd_metadata": {
      "description": "Kubernetes Java client libraries in version 10.0.0 and versions prior to 9.0.1 allow writes to paths outside of the current directory when copying multiple files from a remote pod which sends a maliciously crafted archive. This can potentially overwrite any files on the system of the process executing the client code.",
      "published_date": "2021-01-21T17:15:14.327",
      "cvss_v3_score": 9.1,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "util/src/main/java/io/kubernetes/client/Copy.java",
        "class_name": "Copy",
        "method_name": "copyDirectoryFromPod",
        "signature": "void copyDirectoryFromPod(String,String,String,String,Path,boolean)",
        "lines_hint_csv": [
          142,
          196
        ],
        "code": "  public void copyDirectoryFromPod(String namespace, String pod, String srcPath, Path destination)\n      throws ApiException, IOException, CopyNotSupportedException {\n    copyDirectoryFromPod(namespace, pod, null, srcPath, destination);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          111,
          114
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2021-29425",
    "project_slug": "asf__commons-io_CVE-2021-29425_2.6",
    "buggy_commit_id": "2ae025fe5c4a7d2046c53072b0898e37a079fe62",
    "github_url": "https://github.com/apache/commons-io",
    "nvd_metadata": {
      "description": "In Apache Commons IO before 2.7, When invoking the method FileNameUtils.normalize with an improper input string, like \"//../foo\", or \"\\\\..\\foo\", the result would be the same value, thus possibly providing access to files in the parent directory, but not further above (thus \"limited\" path traversal), if the calling code would use the result to construct a path value.",
      "published_date": "2021-04-13T07:15:12.327",
      "cvss_v3_score": 4.8,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/test/java/org/apache/commons/io/FilenameUtilsTestCase.java",
        "class_name": "FilenameUtilsTestCase",
        "method_name": "testNormalize_with_nullbytes",
        "signature": "void testNormalize_with_nullbytes()",
        "lines_hint_csv": [
          280,
          287
        ],
        "code": "    public void testNormalize_with_nullbytes() throws Exception {\n        try {\n            assertEquals(\"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"a\\\\b/c\\u0000.txt\"));\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            assertEquals(\"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"\\u0000a\\\\b/c.txt\"));\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          250,
          260
        ]
      },
      {
        "file_path": "src/test/java/org/apache/commons/io/FilenameUtilsTestCase.java",
        "class_name": "FilenameUtilsTestCase",
        "method_name": "testNormalize",
        "signature": "void testNormalize()",
        "lines_hint_csv": [
          101,
          274
        ],
        "code": "    public void testNormalize() throws Exception {\n        assertEquals(null, FilenameUtils.normalize(null));\n        assertEquals(null, FilenameUtils.normalize(\":\"));\n        assertEquals(null, FilenameUtils.normalize(\"1:\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.normalize(\"1:\"));\n        assertEquals(null, FilenameUtils.normalize(\"1:a\"));\n        assertEquals(null, FilenameUtils.normalize(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.normalize(\"\\\\\\\\a\"));\n\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"a\\\\b/c.txt\"));\n        assertEquals(\"\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"\\\\a\\\\b/c.txt\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"C:\\\\a\\\\b/c.txt\"));\n        assertEquals(\"\" + SEP + \"\" + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"\\\\\\\\server\\\\a\\\\b/c.txt\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"~\\\\a\\\\b/c.txt\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"~user\\\\a\\\\b/c.txt\"));\n\n        assertEquals(\"a\" + SEP + \"c\", FilenameUtils.normalize(\"a/b/../c\"));\n        assertEquals(\"c\", FilenameUtils.normalize(\"a/b/../../c\"));\n        assertEquals(\"c\" + SEP, FilenameUtils.normalize(\"a/b/../../c/\"));\n        assertEquals(null, FilenameUtils.normalize(\"a/b/../../../c\"));\n        assertEquals(\"a\" + SEP, FilenameUtils.normalize(\"a/b/..\"));\n        assertEquals(\"a\" + SEP, FilenameUtils.normalize(\"a/b/../\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"a/b/../..\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"a/b/../../\"));\n        assertEquals(null, FilenameUtils.normalize(\"a/b/../../..\"));\n        assertEquals(\"a\" + SEP + \"d\", FilenameUtils.normalize(\"a/b/../c/../d\"));\n        assertEquals(\"a\" + SEP + \"d\" + SEP, FilenameUtils.normalize(\"a/b/../c/../d/\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"a/b//d\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"a/b/././.\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"a/b/./././\"));\n        assertEquals(\"a\" + SEP, FilenameUtils.normalize(\"./a/\"));\n        assertEquals(\"a\", FilenameUtils.normalize(\"./a\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"./\"));\n        assertEquals(\"\", FilenameUtils.normalize(\".\"));\n        assertEquals(null, FilenameUtils.normalize(\"../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"..\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"\"));\n\n        assertEquals(SEP + \"a\", FilenameUtils.normalize(\"/a\"));\n        assertEquals(SEP + \"a\" + SEP, FilenameUtils.normalize(\"/a/\"));\n        assertEquals(SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"/a/b/../c\"));\n        assertEquals(SEP + \"c\", FilenameUtils.normalize(\"/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"/a/b/../../../c\"));\n        assertEquals(SEP + \"a\" + SEP, FilenameUtils.normalize(\"/a/b/..\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"/a/b/../../..\"));\n        assertEquals(SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"/a/b/../c/../d\"));\n        assertEquals(SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"/a/b//d\"));\n        assertEquals(SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"/a/b/././.\"));\n        assertEquals(SEP + \"a\", FilenameUtils.normalize(\"/./a\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/./\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"/..\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/\"));\n\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalize(\"~/a\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~/a/\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"~/a/b/../c\"));\n        assertEquals(\"~\" + SEP + \"c\", FilenameUtils.normalize(\"~/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/a/b/../../../c\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~/a/b/..\"));\n        assertEquals(\"~\" + SEP + \"\", FilenameUtils.normalize(\"~/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/a/b/../../..\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"~/a/b/../c/../d\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"~/a/b//d\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"~/a/b/././.\"));\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalize(\"~/./a\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~/./\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/..\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~/\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~\"));\n\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalize(\"~user/a\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~user/a/\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"~user/a/b/../c\"));\n        assertEquals(\"~user\" + SEP + \"c\", FilenameUtils.normalize(\"~user/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/a/b/../../../c\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~user/a/b/..\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalize(\"~user/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/a/b/../../..\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"~user/a/b/../c/../d\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"~user/a/b//d\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"~user/a/b/././.\"));\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalize(\"~user/./a\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalize(\"~user/./\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalize(\"~user/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/..\"));\n        assertEquals(\"~user\" + SEP, FilenameUtils.normalize(\"~user/\"));\n        assertEquals(\"~user\" + SEP, FilenameUtils.normalize(\"~user\"));\n\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalize(\"C:/a\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"C:/a/\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"C:/a/b/../c\"));\n        assertEquals(\"C:\" + SEP + \"c\", FilenameUtils.normalize(\"C:/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/a/b/../../../c\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"C:/a/b/..\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/a/b/../../..\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"C:/a/b/../c/../d\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"C:/a/b//d\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"C:/a/b/././.\"));\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalize(\"C:/./a\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/./\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/..\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/\"));\n\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalize(\"C:a\"));\n        assertEquals(\"C:\" + \"a\" + SEP, FilenameUtils.normalize(\"C:a/\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"C:a/b/../c\"));\n        assertEquals(\"C:\" + \"c\", FilenameUtils.normalize(\"C:a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:a/b/../../../c\"));\n        assertEquals(\"C:\" + \"a\" + SEP, FilenameUtils.normalize(\"C:a/b/..\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:a/b/../../..\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"C:a/b/../c/../d\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"C:a/b//d\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"C:a/b/././.\"));\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalize(\"C:./a\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:./\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:.\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:..\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:\"));\n\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalize(\"//server/a\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"//server/a/\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"//server/a/b/../c\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"c\", FilenameUtils.normalize(\"//server/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/a/b/../../../c\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"//server/a/b/..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/a/b/../../..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"//server/a/b/../c/../d\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"//server/a/b//d\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"//server/a/b/././.\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalize(\"//server/./a\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/./\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          100,
          247
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-22932",
    "project_slug": "asf__karaf_CVE-2022-22932_4.3.5",
    "buggy_commit_id": "d0439e5b0dde1c7e3ff0207c557aa701093acd25",
    "github_url": "https://github.com/apache/karaf",
    "nvd_metadata": {
      "description": "Apache Karaf obr:* commands and run goal on the karaf-maven-plugin have partial path traversal which allows to break out of expected folder. The risk is low as obr:* commands are not very used and the entry is set by user. This has been fixed in revision: https://gitbox.apache.org/repos/asf?p=karaf.git;h=36a2bc4 https://gitbox.apache.org/repos/asf?p=karaf.git;h=52b70cf Mitigation: Apache Karaf users should upgrade to 4.2.15 or 4.3.6 or later as soon as possible, or use correct path. JIRA Tickets: https://issues.apache.org/jira/browse/KARAF-7326",
      "published_date": "2022-01-26T11:15:09.583",
      "cvss_v3_score": 5.3,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "obr/src/main/java/org/apache/karaf/obr/command/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "unjar",
        "signature": "void unjar(JarInputStream,File)",
        "lines_hint_csv": [
          96,
          140
        ],
        "code": "    public static void unjar(JarInputStream jis, File dir)\n        throws IOException\n    {\n        // Reusable buffer.\n        byte[] buffer = new byte[4096];\n\n        // Loop through JAR entries.\n        for (JarEntry je = jis.getNextJarEntry();\n             je != null;\n             je = jis.getNextJarEntry())\n        {\n            if (je.getName().startsWith(\"/\"))\n            {\n                throw new IOException(\"JAR resource cannot contain absolute paths.\");\n            }\n\n            File target = new File(dir, je.getName());\n            if (!target.getCanonicalPath().startsWith(dir.getCanonicalPath())) {\n                throw new IOException(\"JAR resource cannot contain paths with .. characters\");\n            }\n\n            // Check to see if the JAR entry is a directory.\n            if (je.isDirectory())\n            {\n                if (!target.exists())\n                {\n                    if (!target.mkdirs())\n                    {\n                        throw new IOException(\"Unable to create target directory: \"\n                            + target);\n                    }\n                }\n                // Just continue since directories do not have content to copy.\n                continue;\n            }\n\n            int lastIndex = je.getName().lastIndexOf('/');\n            String name = (lastIndex >= 0) ?\n                je.getName().substring(lastIndex + 1) : je.getName();\n            String destination = (lastIndex >= 0) ?\n                je.getName().substring(0, lastIndex) : \"\";\n\n            // JAR files use '/', so convert it to platform separator.\n            destination = destination.replace('/', File.separatorChar);\n            copy(jis, dir, name, destination, buffer);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          96,
          142
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-22931",
    "project_slug": "asf__james-project_CVE-2022-22931_3.6.0",
    "buggy_commit_id": "34f9b0b52ab8c84378d3a34ac43a0fef5aa4e8fe",
    "github_url": "https://github.com/apache/james-project",
    "nvd_metadata": {
      "description": "Fix of CVE-2021-40525 do not prepend delimiters upon valid directory validations. Affected implementations include: - maildir mailbox store - Sieve file repository This enables a user to access other users data stores (limited to user names being prefixed by the value of the username being used).",
      "published_date": "2022-02-07T19:15:08.300",
      "cvss_v3_score": 4.3,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "mailbox/maildir/src/main/java/org/apache/james/mailbox/maildir/MaildirFolder.java",
        "class_name": "MaildirFolder",
        "method_name": "validateWithinFolder",
        "signature": "MaildirFolder validateWithinFolder(File)",
        "lines_hint_csv": [
          108,
          116
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "server/data/data-file/src/main/java/org/apache/james/sieverepository/file/SieveFileRepository.java",
        "class_name": "SieveFileRepository",
        "method_name": "enforceRoot",
        "signature": "void enforceRoot(File)",
        "lines_hint_csv": [
          318,
          324
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "server/data/data-file/src/test/java/org/apache/james/sieverepository/file/SieveFileRepositoryTest.java",
        "class_name": "SieveFileRepositoryTest",
        "method_name": "getScriptShouldNotAllowToReadScriptsOfOtherUsers",
        "signature": "void getScriptShouldNotAllowToReadScriptsOfOtherUsers()",
        "lines_hint_csv": [
          80,
          85
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2019-17640",
    "project_slug": "vert-x3__vertx-web_CVE-2019-17640_3.9.3",
    "buggy_commit_id": "2146b7240096e25b40bb1acc083fa7ec79330989",
    "github_url": "https://github.com/vert-x3/vertx-web",
    "nvd_metadata": {
      "description": "In Eclipse Vert.x 3.4.x up to 3.9.4, 4.0.0.milestone1, 4.0.0.milestone2, 4.0.0.milestone3, 4.0.0.milestone4, 4.0.0.milestone5, 4.0.0.Beta1, 4.0.0.Beta2, and 4.0.0.Beta3, StaticHandler doesn't correctly processes back slashes on Windows Operating systems, allowing, escape the webroot folder to the current working directory.",
      "published_date": "2020-10-15T21:15:11.427",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "vertx-web/src/main/java/io/vertx/ext/web/handler/impl/StaticHandlerImpl.java",
        "class_name": "StaticHandlerImpl",
        "method_name": "handle",
        "signature": "void handle(RoutingContext)",
        "lines_hint_csv": [
          125,
          145
        ],
        "code": "  public void handle(RoutingContext context) {\n    HttpServerRequest request = context.request();\n    if (request.method() != HttpMethod.GET && request.method() != HttpMethod.HEAD) {\n      if (log.isTraceEnabled()) log.trace(\"Not GET or HEAD so ignoring request\");\n      context.next();\n    } else {\n      String path = HttpUtils.removeDots(URIDecoder.decodeURIComponent(context.normalisedPath(), false));\n      // if the normalized path is null it cannot be resolved\n      if (path == null) {\n        log.warn(\"Invalid path: \" + context.request().path());\n        context.next();\n        return;\n      }\n\n      // only root is known for sure to be a directory. all other directories must be identified as such.\n      if (!directoryListing && \"/\".equals(path)) {\n        path = indexPage;\n      }\n\n      // can be called recursive for index pages\n      sendStatic(context, path);\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          125,
          147
        ]
      },
      {
        "file_path": "vertx-web/src/test/java/io/vertx/ext/web/handler/StaticHandlerTest.java",
        "class_name": "StaticHandlerTest",
        "method_name": "testGetDefaultIndex",
        "signature": "void testGetDefaultIndex()",
        "lines_hint_csv": [
          51,
          52
        ],
        "code": "  public void testGetDefaultIndex() throws Exception {\n    testRequest(HttpMethod.GET, \"/\", 200, \"OK\", \"<html><body>Index page</body></html>\");\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          51,
          53
        ]
      },
      {
        "file_path": "vertx-web/src/test/java/io/vertx/ext/web/handler/StaticHandlerTest.java",
        "class_name": "StaticHandlerTest",
        "method_name": "toDateTime",
        "signature": "long toDateTime(String)",
        "lines_hint_csv": [
          852,
          857
        ],
        "code": "  private long toDateTime(String header) {\n    try {\n      return Utils.parseRFC1123DateTime(header);\n    } catch (Exception e) {\n      fail(e.getMessage());\n      return -1;\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          852,
          859
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-23457",
    "project_slug": "ESAPI__esapi-java-legacy_CVE-2022-23457_2.2.3.1",
    "buggy_commit_id": "2e8694c6beb3bdbb2645b882eba72ce41bc63242",
    "github_url": "https://github.com/ESAPI/esapi-java-legacy",
    "nvd_metadata": {
      "description": "ESAPI (The OWASP Enterprise Security API) is a free, open source, web application security control library. Prior to version 2.3.0.0, the default implementation of `Validator.getValidDirectoryPath(String, String, File, boolean)` may incorrectly treat the tested input string as a child of the specified parent directory. This potentially could allow control-flow bypass checks to be defeated if an attack can specify the entire string representing the 'input' path. This vulnerability is patched in release 2.3.0.0 of ESAPI. As a workaround, it is possible to write one's own implementation of the Validator interface. However, maintainers do not recommend this.",
      "published_date": "2022-04-25T20:15:41.870",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidDirectoryPath",
        "signature": "String getValidDirectoryPath(String,String,File,boolean)",
        "lines_hint_csv": [
          447,
          481
        ],
        "code": "\tpublic String getValidDirectoryPath(String context, String input, File parent, boolean allowNull) throws ValidationException, IntrusionException {\n\t\ttry {\n\t\t\tif (isEmpty(input)) {\n\t\t\t\tif (allowNull) return null;\n       \t\t\tthrow new ValidationException( context + \": Input directory path required\", \"Input directory path required: context=\" + context + \", input=\" + input, context );\n\t\t\t}\n\n\t\t\tFile dir = new File( input );\n\n\t\t\t// check dir exists and parent exists and dir is inside parent\n\t\t\tif ( !dir.exists() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, does not exist: context=\" + context + \", input=\" + input );\n\t\t\t}\n\t\t\tif ( !dir.isDirectory() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, not a directory: context=\" + context + \", input=\" + input );\n\t\t\t}\n\t\t\tif ( !parent.exists() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, specified parent does not exist: context=\" + context + \", input=\" + input + \", parent=\" + parent );\n\t\t\t}\n\t\t\tif ( !parent.isDirectory() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, specified parent is not a directory: context=\" + context + \", input=\" + input + \", parent=\" + parent );\n\t\t\t}\n\t\t\tif ( !dir.getCanonicalPath().startsWith(parent.getCanonicalPath() ) ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, not inside specified parent: context=\" + context + \", input=\" + input + \", parent=\" + parent );\n\t\t\t}\n\n\t\t\t// check canonical form matches input\n\t\t\tString canonicalPath = dir.getCanonicalPath();\n\t\t\tString canonical = fileValidator.getValidInput( context, canonicalPath, \"DirectoryName\", 255, false);\n\t\t\tif ( !canonical.equals( input ) ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory name does not match the canonical path: context=\" + context + \", input=\" + input + \", canonical=\" + canonical, context );\n\t\t\t}\n\t\t\treturn canonical;\n\t\t} catch (Exception e) {\n\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Failure to validate directory path: context=\" + context + \", input=\" + input, e, context );\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          447,
          483
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-24897",
    "project_slug": "xwiki__xwiki-commons_CVE-2022-24897_12.6.6",
    "buggy_commit_id": "4f33e1efd74016fa9eb31b3c2fcd01bc6becd551",
    "github_url": "https://github.com/xwiki/xwiki-commons",
    "nvd_metadata": {
      "description": "APIs to evaluate content with Velocity is a package for APIs to evaluate content with Velocity. Starting with version 2.3 and prior to 12.6.7, 12.10.3, and 13.0, the velocity scripts are not properly sandboxed against using the Java File API to perform read or write operations on the filesystem. Writing an attacking script in Velocity requires the Script rights in XWiki so not all users can use it, and it also requires finding an XWiki API which returns a File. The problem has been patched in versions 12.6.7, 12.10.3, and 13.0. There is no easy workaround for fixing this vulnerability other than upgrading and being careful when giving Script rights.",
      "published_date": "2022-05-02T22:15:09.767",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/SecureIntrospector.java",
        "class_name": "SecureIntrospector",
        "method_name": "SecureIntrospector",
        "signature": "SecureIntrospector(String,String,Logger)",
        "lines_hint_csv": [
          43,
          70
        ],
        "code": "    public SecureIntrospector(String[] badClasses, String[] badPackages, Logger log)\n    {\n        super(badClasses, badPackages, log);\n\n        this.secureClassMethods.add(\"getname\");\n        this.secureClassMethods.add(\"getName\");\n        this.secureClassMethods.add(\"getsimpleName\");\n        this.secureClassMethods.add(\"getSimpleName\");\n\n        this.secureClassMethods.add(\"isarray\");\n        this.secureClassMethods.add(\"isArray\");\n        this.secureClassMethods.add(\"isassignablefrom\");\n        this.secureClassMethods.add(\"isAssignableFrom\");\n        this.secureClassMethods.add(\"isenum\");\n        this.secureClassMethods.add(\"isEnum\");\n        this.secureClassMethods.add(\"isinstance\");\n        this.secureClassMethods.add(\"isInstance\");\n        this.secureClassMethods.add(\"isinterface\");\n        this.secureClassMethods.add(\"isInterface\");\n        this.secureClassMethods.add(\"islocalClass\");\n        this.secureClassMethods.add(\"isLocalClass\");\n        this.secureClassMethods.add(\"ismemberclass\");\n        this.secureClassMethods.add(\"isMemberClass\");\n        this.secureClassMethods.add(\"isprimitive\");\n        this.secureClassMethods.add(\"isPrimitive\");\n        this.secureClassMethods.add(\"issynthetic\");\n        this.secureClassMethods.add(\"isSynthetic\");\n        this.secureClassMethods.add(\"getEnumConstants\");\n\n        // TODO: add more when needed\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          43,
          73
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-1002202",
    "project_slug": "srikanth-lingala__zip4j_CVE-2018-1002202_1.3.2",
    "buggy_commit_id": "d87ffa2d64ffb3a0a1cf0c7a69c7b19d7015bfde",
    "github_url": "https://github.com/iris-sast/zip4j",
    "nvd_metadata": {
      "description": "zip4j before 1.3.3 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.",
      "published_date": "2018-07-25T17:29:00.797",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/net/lingala/zip4j/unzip/Unzip.java",
        "class_name": "Unzip",
        "method_name": "initExtractFile",
        "signature": "void initExtractFile(FileHeader,String,UnzipParameters,String,ProgressMonitor)",
        "lines_hint_csv": [
          123,
          179
        ],
        "code": "\tprivate void initExtractFile(FileHeader fileHeader, String outPath,\r\n\t\t\tUnzipParameters unzipParameters, String newFileName, ProgressMonitor progressMonitor) throws ZipException {\r\n\r\n\t\tif (fileHeader == null) {\r\n\t\t\tthrow new ZipException(\"fileHeader is null\");\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tprogressMonitor.setFileName(fileHeader.getFileName());\r\n\t\t\t\r\n\t\t\tif (!outPath.endsWith(InternalZipConstants.FILE_SEPARATOR)) {\r\n\t\t\t\toutPath += InternalZipConstants.FILE_SEPARATOR;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// If file header is a directory, then check if the directory exists\r\n\t\t\t// If not then create a directory and return\r\n\t\t\tif (fileHeader.isDirectory()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString fileName = fileHeader.getFileName();\r\n\t\t\t\t\tif (!Zip4jUtil.isStringNotNullAndNotEmpty(fileName)) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tString completePath = outPath + fileName;\r\n\t\t\t\t\tFile file = new File(completePath);\r\n\t\t\t\t\tif (!file.exists()) {\r\n\t\t\t\t\t\tfile.mkdirs();\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tprogressMonitor.endProgressMonitorError(e);\r\n\t\t\t\t\tthrow new ZipException(e);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t//Create Directories\r\n\t\t\t\tcheckOutputDirectoryStructure(fileHeader, outPath, newFileName);\r\n\t\t\t\t\r\n\t\t\t\tUnzipEngine unzipEngine = new UnzipEngine(zipModel, fileHeader);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tunzipEngine.unzipFile(progressMonitor, outPath, newFileName, unzipParameters);\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tprogressMonitor.endProgressMonitorError(e);\r\n\t\t\t\t\tthrow new ZipException(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (ZipException e) {\r\n\t\t\tprogressMonitor.endProgressMonitorError(e);\r\n\t\t\tthrow e;\r\n\t\t} catch (Exception e) {\r\n\t\t\tprogressMonitor.endProgressMonitorError(e);\r\n\t\t\tthrow new ZipException(e);\r\n\t\t}\r\n\t}\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          123,
          173
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-25842",
    "project_slug": "alibaba__one-java-agent_CVE-2022-25842_0.0.1",
    "buggy_commit_id": "b911af2bb779917c84a016350700745dc31c642a",
    "github_url": "https://github.com/alibaba/one-java-agent",
    "nvd_metadata": {
      "description": "All versions of package com.alibaba.oneagent:one-java-agent-plugin are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) using a specially crafted archive that holds directory traversal filenames (e.g. ../../evil.exe). The attacker can overwrite executable files and either invoke them remotely or wait for the system or user to call them, thus achieving remote command execution on the victims machine.",
      "published_date": "2022-05-01T16:15:08.710",
      "cvss_v3_score": 6.9,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "one-java-agent-plugin/src/main/java/com/alibaba/oneagent/utils/IOUtils.java",
        "class_name": "IOUtils",
        "method_name": "unzip",
        "signature": "unzip(String zipFile, String extractFolder)",
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "\tpublic static void unzip(String zipFile, String extractFolder) throws IOException {\n\t\tFile file = new File(zipFile);\n\t\tZipFile zip = null;\n\t\ttry {\n\t\t\tint BUFFER = 1024 * 8;\n\n\t\t\tzip = new ZipFile(file);\n\t\t\tString newPath = extractFolder;\n\n\t\t\tnew File(newPath).mkdir();\n\t\t\tEnumeration<? extends ZipEntry> zipFileEntries = zip.entries();\n\n\t\t\t// Process each entry\n\t\t\twhile (zipFileEntries.hasMoreElements()) {\n\t\t\t\t// grab a zip file entry\n\t\t\t\tZipEntry entry = (ZipEntry) zipFileEntries.nextElement();\n\t\t\t\tString currentEntry = entry.getName();\n\n\t\t\t\tFile destFile = new File(newPath, currentEntry);\n\t\t\t\t// destFile = new File(newPath, destFile.getName());\n\t\t\t\tFile destinationParent = destFile.getParentFile();\n\n\t\t\t\t// create the parent directory structure if needed\n\t\t\t\tdestinationParent.mkdirs();\n\n\t\t\t\tif (!entry.isDirectory()) {\n\t\t\t\t\tBufferedInputStream is = null;\n\t\t\t\t\tBufferedOutputStream dest = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tis = new BufferedInputStream(zip.getInputStream(entry));\n\t\t\t\t\t\tint currentByte;\n\t\t\t\t\t\t// establish buffer for writing file\n\t\t\t\t\t\tbyte data[] = new byte[BUFFER];\n\n\t\t\t\t\t\t// write the current file to disk\n\t\t\t\t\t\tFileOutputStream fos = new FileOutputStream(destFile);\n\t\t\t\t\t\tdest = new BufferedOutputStream(fos, BUFFER);\n\n\t\t\t\t\t\t// read and write until last byte is encountered\n\t\t\t\t\t\twhile ((currentByte = is.read(data, 0, BUFFER)) != -1) {\n\t\t\t\t\t\t\tdest.write(data, 0, currentByte);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdest.flush();\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tclose(dest);\n\t\t\t\t\t\tclose(is);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tclose(zip);\n\t\t}\n\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          106,
          161
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2011-4367",
    "project_slug": "apache__myfaces_CVE-2011-4367_2.0.11",
    "buggy_commit_id": "bedac49daffc3cb792fa19884620af01ab5a01ab",
    "github_url": "https://github.com/apache/myfaces",
    "nvd_metadata": {
      "description": "Multiple directory traversal vulnerabilities in MyFaces JavaServer Faces (JSF) in Apache MyFaces Core 2.0.x before 2.0.12 and 2.1.x before 2.1.6 allow remote attackers to read arbitrary files via a .. (dot dot) in the (1) ln parameter to faces/javax.faces.resource/web.xml or (2) the PATH_INFO to faces/javax.faces.resource/.",
      "published_date": "2014-06-19T14:55:06.693",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "shared/src/main/java/org/apache/myfaces/shared/resource/ResourceValidationUtils.java",
        "class_name": "ResourceValidationUtils",
        "method_name": "isValidLibraryName",
        "signature": "boolean isValidLibraryName(String)",
        "lines_hint_csv": [
          28,
          30
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "shared/src/main/java/org/apache/myfaces/shared/resource/ResourceValidationUtils.java",
        "class_name": "ResourceValidationUtils",
        "method_name": "validate",
        "signature": "boolean validate(String,boolean)",
        "lines_hint_csv": [
          50,
          112
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "shared/src/main/java/org/apache/myfaces/shared/resource/ResourceValidationUtils.java",
        "class_name": "ResourceValidationUtils",
        "method_name": "validate",
        "signature": "boolean validate(String,boolean)",
        "lines_hint_csv": [
          50,
          112
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "libraryExists",
        "signature": "boolean libraryExists(String)",
        "lines_hint_csv": [
          519,
          550
        ],
        "code": "    public boolean libraryExists(String libraryName)\n    {\n        String localePrefix = getLocalePrefixForLocateResource();\n\n        String pathToLib = null;\n        \n        if (localePrefix != null)\n        {\n            //Check with locale\n            pathToLib = localePrefix + '/' + libraryName;\n            \n            for (ResourceLoader loader : getResourceHandlerSupport()\n                    .getResourceLoaders())\n            {\n                if (loader.libraryExists(pathToLib))\n                {\n                    return true;\n                }\n            }            \n        }\n\n        //Check without locale\n        for (ResourceLoader loader : getResourceHandlerSupport()\n                .getResourceLoaders())\n        {\n            if (loader.libraryExists(libraryName))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          514,
          546
        ]
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "getLocalePrefixForLocateResource",
        "signature": "String getLocalePrefixForLocateResource()",
        "lines_hint_csv": [
          441,
          488
        ],
        "code": "    protected String getLocalePrefixForLocateResource()\n    {\n        String localePrefix = null;\n        FacesContext context = FacesContext.getCurrentInstance();\n        boolean isResourceRequest = context.getApplication().getResourceHandler().isResourceRequest(context);\n\n        if (isResourceRequest)\n        {\n            localePrefix = context.getExternalContext().getRequestParameterMap().get(\"loc\");\n            \n            if (localePrefix != null)\n            {\n                return localePrefix;\n            }\n        }\n        \n        String bundleName = context.getApplication().getMessageBundle();\n\n        if (null != bundleName)\n        {\n            Locale locale = null;\n            \n            if (isResourceRequest || context.getViewRoot() == null)\n            {\n                locale = context.getApplication().getViewHandler()\n                                .calculateLocale(context);\n            }\n            else\n            {\n                locale = context.getViewRoot().getLocale();\n            }\n\n            try\n            {\n                ResourceBundle bundle = ResourceBundle\n                        .getBundle(bundleName, locale, ClassUtils.getContextClassLoader());\n\n                if (bundle != null)\n                {\n                    localePrefix = bundle.getString(ResourceHandler.LOCALE_PREFIX);\n                }\n            }\n            catch (MissingResourceException e)\n            {\n                // Ignore it and return null\n            }\n        }\n        return localePrefix;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          436,
          484
        ]
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "createResource",
        "signature": "Resource createResource(String,String,String)",
        "lines_hint_csv": [
          82,
          122
        ],
        "code": "    public Resource createResource(String resourceName, String libraryName,\n            String contentType)\n    {\n        Resource resource = null;\n        \n        if (contentType == null)\n        {\n            //Resolve contentType using ExternalContext.getMimeType\n            contentType = FacesContext.getCurrentInstance().getExternalContext().getMimeType(resourceName);\n        }\n\n        final String localePrefix = getLocalePrefixForLocateResource();\n\n        // check cache\n        if(getResourceLoaderCache().containsResource(resourceName, libraryName, contentType, localePrefix))\n        {\n            ResourceValue resourceValue = getResourceLoaderCache().getResource(\n                    resourceName, libraryName, contentType, localePrefix);\n            \n            resource = new ResourceImpl(resourceValue.getResourceMeta(), resourceValue.getResourceLoader(),\n                    getResourceHandlerSupport(), contentType);\n        }\n        else\n        {\n            for (ResourceLoader loader : getResourceHandlerSupport().getResourceLoaders())\n            {\n                ResourceMeta resourceMeta = deriveResourceMeta(loader, resourceName, libraryName, localePrefix);\n    \n                if (resourceMeta != null)\n                {\n                    resource = new ResourceImpl(resourceMeta, loader, getResourceHandlerSupport(), contentType);\n\n                    // cache it\n                    getResourceLoaderCache().putResource(resourceName, libraryName, contentType,\n                            localePrefix, resourceMeta, loader);\n                    break;\n                }\n            }\n        }\n        \n        return resource;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          83,
          124
        ]
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "setResourceHandlerSupport",
        "signature": "void setResourceHandlerSupport(ResourceHandlerSupport)",
        "lines_hint_csv": [
          557,
          560
        ],
        "code": "    public void setResourceHandlerSupport(\n            ResourceHandlerSupport resourceHandlerSupport)\n    {\n        _resourceHandlerSupport = resourceHandlerSupport;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          552,
          556
        ]
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "handleResourceRequest",
        "signature": "void handleResourceRequest(FacesContext)",
        "lines_hint_csv": [
          263,
          379
        ],
        "code": "    public void handleResourceRequest(FacesContext facesContext) throws IOException\n    {\n        //try\n        //{\n            String resourceBasePath = getResourceHandlerSupport()\n                    .calculateResourceBasePath(facesContext);\n    \n            if (resourceBasePath == null)\n            {\n                // No base name could be calculated, so no further\n                //advance could be done here. HttpServletResponse.SC_NOT_FOUND\n                //cannot be returned since we cannot extract the \n                //resource base name\n                return;\n            }\n    \n            // We neet to get an instance of HttpServletResponse, but sometimes\n            // the response object is wrapped by several instances of \n            // ServletResponseWrapper (like ResponseSwitch).\n            // Since we are handling a resource, we can expect to get an \n            // HttpServletResponse.\n            Object response = facesContext.getExternalContext().getResponse();\n            HttpServletResponse httpServletResponse = ExternalContextUtils.getHttpServletResponse(response);\n            if (httpServletResponse == null)\n            {\n                throw new IllegalStateException(\"Could not obtain an instance of HttpServletResponse.\");\n            }\n    \n            if (isResourceIdentifierExcluded(facesContext, resourceBasePath))\n            {\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n    \n            String resourceName = null;\n            if (resourceBasePath.startsWith(ResourceHandler.RESOURCE_IDENTIFIER))\n            {\n                resourceName = resourceBasePath\n                        .substring(ResourceHandler.RESOURCE_IDENTIFIER.length() + 1);\n            }\n            else\n            {\n                //Does not have the conditions for be a resource call\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n    \n            String libraryName = facesContext.getExternalContext()\n                    .getRequestParameterMap().get(\"ln\");\n    \n            Resource resource = null;\n            if (libraryName != null)\n            {\n                //log.info(\"libraryName=\" + libraryName);\n                resource = facesContext.getApplication().getResourceHandler().createResource(resourceName, libraryName);\n            }\n            else\n            {\n                resource = facesContext.getApplication().getResourceHandler().createResource(resourceName);\n            }\n    \n            if (resource == null)\n            {\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n    \n            if (!resource.userAgentNeedsUpdate(facesContext))\n            {\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n    \n            httpServletResponse.setContentType(_getContentType(resource, facesContext.getExternalContext()));\n    \n            Map<String, String> headers = resource.getResponseHeaders();\n    \n            for (Map.Entry<String, String> entry : headers.entrySet())\n            {\n                httpServletResponse.setHeader(entry.getKey(), entry.getValue());\n            }\n    \n            //serve up the bytes (taken from trinidad ResourceServlet)\n            try\n            {\n                InputStream in = resource.getInputStream();\n                OutputStream out = httpServletResponse.getOutputStream();\n                byte[] buffer = new byte[_BUFFER_SIZE];\n    \n                try\n                {\n                    int count = pipeBytes(in, out, buffer);\n                    //set the content lenght\n                    httpServletResponse.setContentLength(count);\n                }\n                finally\n                {\n                    try\n                    {\n                        in.close();\n                    }\n                    finally\n                    {\n                        out.close();\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                //TODO: Log using a localized message (which one?)\n                if (log.isLoggable(Level.SEVERE))\n                    log.severe(\"Error trying to load resource \" + resourceName\n                            + \" with library \" + libraryName + \" :\"\n                            + e.getMessage());\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n            }\n        //}\n        //catch (Throwable ex)\n        //{\n            // handle the Throwable accordingly. Maybe generate an error page.\n            // FIXME we are creating a html error page for a non html request here\n            // shouln't we do something better? -=Jakob Korherr=-\n            //ErrorPageWriter.handleThrowable(facesContext, ex);\n        //}\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          260,
          384
        ]
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "createResource",
        "signature": "Resource createResource(String,String,String)",
        "lines_hint_csv": [
          83,
          132
        ],
        "code": "    public Resource createResource(String resourceName, String libraryName,\n            String contentType)\n    {\n        Resource resource = null;\n        \n        if (contentType == null)\n        {\n            //Resolve contentType using ExternalContext.getMimeType\n            contentType = FacesContext.getCurrentInstance().getExternalContext().getMimeType(resourceName);\n        }\n\n        final String localePrefix = getLocalePrefixForLocateResource();\n\n        // check cache\n        if(getResourceLoaderCache().containsResource(resourceName, libraryName, contentType, localePrefix))\n        {\n            ResourceValue resourceValue = getResourceLoaderCache().getResource(\n                    resourceName, libraryName, contentType, localePrefix);\n            \n            resource = new ResourceImpl(resourceValue.getResourceMeta(), resourceValue.getResourceLoader(),\n                    getResourceHandlerSupport(), contentType);\n        }\n        else\n        {\n            for (ResourceLoader loader : getResourceHandlerSupport().getResourceLoaders())\n            {\n                ResourceMeta resourceMeta = deriveResourceMeta(loader, resourceName, libraryName, localePrefix);\n    \n                if (resourceMeta != null)\n                {\n                    resource = new ResourceImpl(resourceMeta, loader, getResourceHandlerSupport(), contentType);\n\n                    // cache it\n                    getResourceLoaderCache().putResource(resourceName, libraryName, contentType,\n                            localePrefix, resourceMeta, loader);\n                    break;\n                }\n            }\n        }\n        \n        return resource;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          83,
          124
        ]
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "libraryExists",
        "signature": "boolean libraryExists(String)",
        "lines_hint_csv": [
          545,
          581
        ],
        "code": "    public boolean libraryExists(String libraryName)\n    {\n        String localePrefix = getLocalePrefixForLocateResource();\n\n        String pathToLib = null;\n        \n        if (localePrefix != null)\n        {\n            //Check with locale\n            pathToLib = localePrefix + '/' + libraryName;\n            \n            for (ResourceLoader loader : getResourceHandlerSupport()\n                    .getResourceLoaders())\n            {\n                if (loader.libraryExists(pathToLib))\n                {\n                    return true;\n                }\n            }            \n        }\n\n        //Check without locale\n        for (ResourceLoader loader : getResourceHandlerSupport()\n                .getResourceLoaders())\n        {\n            if (loader.libraryExists(libraryName))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          514,
          546
        ]
      },
      {
        "file_path": "impl/src/main/java/org/apache/myfaces/application/ResourceHandlerImpl.java",
        "class_name": "ResourceHandlerImpl",
        "method_name": "handleResourceRequest",
        "signature": "void handleResourceRequest(FacesContext)",
        "lines_hint_csv": [
          273,
          401
        ],
        "code": "    public void handleResourceRequest(FacesContext facesContext) throws IOException\n    {\n        //try\n        //{\n            String resourceBasePath = getResourceHandlerSupport()\n                    .calculateResourceBasePath(facesContext);\n    \n            if (resourceBasePath == null)\n            {\n                // No base name could be calculated, so no further\n                //advance could be done here. HttpServletResponse.SC_NOT_FOUND\n                //cannot be returned since we cannot extract the \n                //resource base name\n                return;\n            }\n    \n            // We neet to get an instance of HttpServletResponse, but sometimes\n            // the response object is wrapped by several instances of \n            // ServletResponseWrapper (like ResponseSwitch).\n            // Since we are handling a resource, we can expect to get an \n            // HttpServletResponse.\n            Object response = facesContext.getExternalContext().getResponse();\n            HttpServletResponse httpServletResponse = ExternalContextUtils.getHttpServletResponse(response);\n            if (httpServletResponse == null)\n            {\n                throw new IllegalStateException(\"Could not obtain an instance of HttpServletResponse.\");\n            }\n    \n            if (isResourceIdentifierExcluded(facesContext, resourceBasePath))\n            {\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n    \n            String resourceName = null;\n            if (resourceBasePath.startsWith(ResourceHandler.RESOURCE_IDENTIFIER))\n            {\n                resourceName = resourceBasePath\n                        .substring(ResourceHandler.RESOURCE_IDENTIFIER.length() + 1);\n            }\n            else\n            {\n                //Does not have the conditions for be a resource call\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n    \n            String libraryName = facesContext.getExternalContext()\n                    .getRequestParameterMap().get(\"ln\");\n    \n            Resource resource = null;\n            if (libraryName != null)\n            {\n                //log.info(\"libraryName=\" + libraryName);\n                resource = facesContext.getApplication().getResourceHandler().createResource(resourceName, libraryName);\n            }\n            else\n            {\n                resource = facesContext.getApplication().getResourceHandler().createResource(resourceName);\n            }\n    \n            if (resource == null)\n            {\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n    \n            if (!resource.userAgentNeedsUpdate(facesContext))\n            {\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                return;\n            }\n    \n            httpServletResponse.setContentType(_getContentType(resource, facesContext.getExternalContext()));\n    \n            Map<String, String> headers = resource.getResponseHeaders();\n    \n            for (Map.Entry<String, String> entry : headers.entrySet())\n            {\n                httpServletResponse.setHeader(entry.getKey(), entry.getValue());\n            }\n    \n            //serve up the bytes (taken from trinidad ResourceServlet)\n            try\n            {\n                InputStream in = resource.getInputStream();\n                OutputStream out = httpServletResponse.getOutputStream();\n                byte[] buffer = new byte[_BUFFER_SIZE];\n    \n                try\n                {\n                    int count = pipeBytes(in, out, buffer);\n                    //set the content lenght\n                    httpServletResponse.setContentLength(count);\n                }\n                finally\n                {\n                    try\n                    {\n                        in.close();\n                    }\n                    finally\n                    {\n                        out.close();\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                //TODO: Log using a localized message (which one?)\n                if (log.isLoggable(Level.SEVERE))\n                    log.severe(\"Error trying to load resource \" + resourceName\n                            + \" with library \" + libraryName + \" :\"\n                            + e.getMessage());\n                httpServletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n            }\n        //}\n        //catch (Throwable ex)\n        //{\n            // handle the Throwable accordingly. Maybe generate an error page.\n            // FIXME we are creating a html error page for a non html request here\n            // shouln't we do something better? -=Jakob Korherr=-\n            //ErrorPageWriter.handleThrowable(facesContext, ex);\n        //}\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          260,
          384
        ]
      },
      {
        "file_path": "shared/src/main/java/org/apache/myfaces/shared/resource/ResourceValidationUtils.java",
        "class_name": "ResourceValidationUtils",
        "method_name": "isValidLibraryName",
        "signature": "boolean isValidLibraryName(String)",
        "lines_hint_csv": [
          28,
          30
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "shared/src/main/java/org/apache/myfaces/shared/resource/ResourceValidationUtils.java",
        "class_name": "ResourceValidationUtils",
        "method_name": "isValidLocalePrefix",
        "signature": "boolean isValidLocalePrefix(String)",
        "lines_hint_csv": [
          33,
          47
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "shared/src/test/java/org/apache/myfaces/shared/resource/ResourceValidationUtilsTest.java",
        "class_name": "ResourceValidationUtilsTest",
        "method_name": "testLibraryNames",
        "signature": "void testLibraryNames()",
        "lines_hint_csv": [
          48,
          61
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "shared/src/test/java/org/apache/myfaces/shared/resource/ResourceValidationUtilsTest.java",
        "class_name": "ResourceValidationUtilsTest",
        "method_name": "testResourceNames",
        "signature": "void testResourceNames()",
        "lines_hint_csv": [
          65,
          92
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "shared/src/main/java/org/apache/myfaces/shared/resource/ResourceValidationUtils.java",
        "class_name": "ResourceValidationUtils",
        "method_name": "validate",
        "signature": "boolean validate(String,boolean)",
        "lines_hint_csv": [
          50,
          92
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2014-7816",
    "project_slug": "undertow-io__undertow_CVE-2014-7816_1.0.16.Final",
    "buggy_commit_id": "4aa98c80fa9962235c94f8666c30793d0018f95d",
    "github_url": "https://github.com/undertow-io/undertow",
    "nvd_metadata": {
      "description": "Directory traversal vulnerability in JBoss Undertow 1.0.x before 1.0.17, 1.1.x before 1.1.0.CR5, and 1.2.x before 1.2.0.Beta3, when running on Windows, allows remote attackers to read arbitrary files via a .. (dot dot) in a resource URI.",
      "published_date": "2014-12-01T15:59:06.610",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "core/src/main/java/io/undertow/server/handlers/resource/ResourceHandler.java",
        "class_name": "ResourceHandler",
        "method_name": "serveResource",
        "signature": "void serveResource(HttpServerExchange,boolean)",
        "lines_hint_csv": [
          123,
          263
        ],
        "code": "    private void serveResource(final HttpServerExchange exchange, final boolean sendContent) {\n\n        if (DirectoryUtils.sendRequestedBlobs(exchange)) {\n            return;\n        }\n\n        if (!allowed.resolve(exchange)) {\n            exchange.setResponseCode(403);\n            exchange.endExchange();\n            return;\n        }\n\n        ResponseCache cache = exchange.getAttachment(ResponseCache.ATTACHMENT_KEY);\n        final boolean cachable = this.cachable.resolve(exchange);\n\n        //we set caching headers before we try and serve from the cache\n        if (cachable && cacheTime != null) {\n            exchange.getResponseHeaders().put(Headers.CACHE_CONTROL, \"public, max-age=\" + cacheTime);\n            if (System.currentTimeMillis() > lastExpiryDate) {\n                long date = System.currentTimeMillis();\n                lastExpiryHeader = DateUtils.toDateString(new Date(date));\n                lastExpiryDate = date;\n            }\n            exchange.getResponseHeaders().put(Headers.EXPIRES, lastExpiryHeader);\n        }\n\n        if (cache != null && cachable) {\n            if (cache.tryServeResponse()) {\n                return;\n            }\n        }\n\n\n        //we now dispatch to a worker thread\n        //as resource manager methods are potentially blocking\n        exchange.dispatch(new Runnable() {\n            @Override\n            public void run() {\n                Resource resource = null;\n                try {\n                    resource = resourceManager.getResource(exchange.getRelativePath());\n                } catch (IOException e) {\n                    UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n                    exchange.setResponseCode(500);\n                    exchange.endExchange();\n                    return;\n                }\n                if (resource == null) {\n                    exchange.setResponseCode(404);\n                    exchange.endExchange();\n                    return;\n                }\n\n                if (resource.isDirectory()) {\n                    Resource indexResource = null;\n                    try {\n                        indexResource = getIndexFiles(resourceManager, resource.getPath(), welcomeFiles);\n                    } catch (IOException e) {\n                        UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n                        exchange.setResponseCode(500);\n                        exchange.endExchange();\n                        return;\n                    }\n                    if (indexResource == null) {\n                        if (directoryListingEnabled) {\n                            DirectoryUtils.renderDirectoryListing(exchange, resource);\n                            return;\n                        } else {\n                            exchange.setResponseCode(StatusCodes.FORBIDDEN);\n                            exchange.endExchange();\n                            return;\n                        }\n                    } else if (!exchange.getRequestPath().endsWith(\"/\")) {\n                        exchange.setResponseCode(302);\n                        exchange.getResponseHeaders().put(Headers.LOCATION, RedirectBuilder.redirect(exchange, exchange.getRelativePath() + \"/\", true));\n                        exchange.endExchange();\n                        return;\n                    }\n                    resource = indexResource;\n                }\n\n                final ETag etag = resource.getETag();\n                final Date lastModified = resource.getLastModified();\n                if (!ETagUtils.handleIfMatch(exchange, etag, false) ||\n                        !DateUtils.handleIfUnmodifiedSince(exchange, lastModified)) {\n                    exchange.setResponseCode(412);\n                    exchange.endExchange();\n                    return;\n                }\n                if (!ETagUtils.handleIfNoneMatch(exchange, etag, true) ||\n                        !DateUtils.handleIfModifiedSince(exchange, lastModified)) {\n                    exchange.setResponseCode(304);\n                    exchange.endExchange();\n                    return;\n                }\n                //todo: handle range requests\n                //we are going to proceed. Set the appropriate headers\n                final String contentType = resource.getContentType(mimeMappings);\n                if (contentType != null) {\n                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, contentType);\n                } else {\n                    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, \"application/octet-stream\");\n                }\n                if (lastModified != null) {\n                    exchange.getResponseHeaders().put(Headers.LAST_MODIFIED, resource.getLastModifiedString());\n                }\n                if (etag != null) {\n                    exchange.getResponseHeaders().put(Headers.ETAG, etag.toString());\n                }\n                Long contentLength = resource.getContentLength();\n                if (contentLength != null) {\n                    exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, contentLength.toString());\n                }\n\n                final ContentEncodedResourceManager contentEncodedResourceManager = ResourceHandler.this.contentEncodedResourceManager;\n                if (contentEncodedResourceManager != null) {\n                    try {\n                        ContentEncodedResource encoded = contentEncodedResourceManager.getResource(resource, exchange);\n                        if (encoded != null) {\n                            exchange.getResponseHeaders().put(Headers.CONTENT_ENCODING, encoded.getContentEncoding());\n                            exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH, encoded.getResource().getContentLength());\n                            encoded.getResource().serve(exchange.getResponseSender(), exchange, IoCallback.END_EXCHANGE);\n                            return;\n                        }\n\n                    } catch (IOException e) {\n                        //TODO: should this be fatal\n                        UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n                        exchange.setResponseCode(500);\n                        exchange.endExchange();\n                        return;\n                    }\n                }\n\n                if (!sendContent) {\n                    exchange.endExchange();\n                } else {\n                    resource.serve(exchange.getResponseSender(), exchange, IoCallback.END_EXCHANGE);\n                }\n            }\n        });\n\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          91,
          234
        ]
      },
      {
        "file_path": "servlet/src/main/java/io/undertow/servlet/handlers/DefaultServlet.java",
        "class_name": "DefaultServlet",
        "method_name": "doGet",
        "signature": "void doGet(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          128,
          160
        ],
        "code": "    protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n        final String path = getPath(req);\n        if (!isAllowed(path)) {\n            resp.sendError(404);\n            return;\n        }\n        final Resource resource = resourceManager.getResource(path);\n        if (resource == null) {\n            if (req.getDispatcherType() == DispatcherType.INCLUDE) {\n                //servlet 9.3\n                throw new FileNotFoundException(path);\n            } else {\n                resp.sendError(404);\n            }\n            return;\n        } else if (resource.isDirectory()) {\n            if (\"css\".equals(req.getQueryString())) {\n                resp.setContentType(\"text/css\");\n                resp.getWriter().write(DirectoryUtils.Blobs.FILE_CSS);\n                return;\n            } else if (\"js\".equals(req.getQueryString())) {\n                resp.setContentType(\"application/javascript\");\n                resp.getWriter().write(DirectoryUtils.Blobs.FILE_JS);\n                return;\n            }\n            if (directoryListingEnabled) {\n                StringBuilder output = DirectoryUtils.renderDirectoryListing(req.getRequestURI(), resource);\n                resp.getWriter().write(output.toString());\n            } else {\n                resp.sendError(403);\n            }\n        } else {\n            serveFileBlocking(req, resp, resource);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          128,
          162
        ]
      },
      {
        "file_path": "servlet/src/main/java/io/undertow/servlet/handlers/ServletPathMatches.java",
        "class_name": "ServletPathMatches",
        "method_name": "findWelcomeFile",
        "signature": "ServletPathMatch findWelcomeFile(String,boolean)",
        "lines_hint_csv": [
          128,
          140
        ],
        "code": "    private ServletPathMatch findWelcomeFile(final String path, boolean requiresRedirect) {\n        for (String i : welcomePages) {\n            try {\n                String mergedPath = path + i;\n                Resource resource = resourceManager.getResource(mergedPath);\n                if (resource != null) {\n                    final ServletPathMatch handler = data.getServletHandlerByPath(mergedPath);\n                    return new ServletPathMatch(handler.getServletChain(), mergedPath, null, requiresRedirect ? REDIRECT : REWRITE, i);\n                }\n            } catch (IOException e) {\n            }\n        }\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          128,
          141
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-12036",
    "project_slug": "jeremylong__DependencyCheck_CVE-2018-12036_3.1.2",
    "buggy_commit_id": "c3b5b3c0d7fe7283b4cd421149d6fb620476f67d",
    "github_url": "https://github.com/jeremylong/DependencyCheck",
    "nvd_metadata": {
      "description": "OWASP Dependency-Check before 3.2.0 allows attackers to write to arbitrary files via a crafted archive that holds directory traversal filenames.",
      "published_date": "2018-06-07T18:29:00.207",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "core/src/main/java/org/owasp/dependencycheck/analyzer/ArchiveAnalyzer.java",
        "class_name": "ArchiveAnalyzer",
        "method_name": "extractFiles",
        "signature": "void extractFiles(File,File,Engine)",
        "lines_hint_csv": [
          380,
          442
        ],
        "code": "    private void extractFiles(File archive, File destination, Engine engine) throws AnalysisException {\n        if (archive != null && destination != null) {\n            String archiveExt = FileUtils.getFileExtension(archive.getName());\n            if (archiveExt == null) {\n                return;\n            }\n            archiveExt = archiveExt.toLowerCase();\n\n            final FileInputStream fis;\n            try {\n                fis = new FileInputStream(archive);\n            } catch (FileNotFoundException ex) {\n                final String msg = String.format(\"Error extracting file `%s`: %s\", archive.getAbsolutePath(), ex.getMessage());\n                LOGGER.debug(msg, ex);\n                throw new AnalysisException(msg);\n            }\n            BufferedInputStream in = null;\n            ZipArchiveInputStream zin = null;\n            TarArchiveInputStream tin = null;\n            GzipCompressorInputStream gin = null;\n            BZip2CompressorInputStream bzin = null;\n            try {\n                if (KNOWN_ZIP_EXT.contains(archiveExt)) {\n                    in = new BufferedInputStream(fis);\n                    ensureReadableJar(archiveExt, in);\n                    zin = new ZipArchiveInputStream(in);\n                    extractArchive(zin, destination, engine);\n                } else if (\"tar\".equals(archiveExt)) {\n                    in = new BufferedInputStream(fis);\n                    tin = new TarArchiveInputStream(in);\n                    extractArchive(tin, destination, engine);\n                } else if (\"gz\".equals(archiveExt) || \"tgz\".equals(archiveExt)) {\n                    final String uncompressedName = GzipUtils.getUncompressedFilename(archive.getName());\n                    final File f = new File(destination, uncompressedName);\n                    if (engine.accept(f)) {\n                        in = new BufferedInputStream(fis);\n                        gin = new GzipCompressorInputStream(in);\n                        decompressFile(gin, f);\n                    }\n                } else if (\"bz2\".equals(archiveExt) || \"tbz2\".equals(archiveExt)) {\n                    final String uncompressedName = BZip2Utils.getUncompressedFilename(archive.getName());\n                    final File f = new File(destination, uncompressedName);\n                    if (engine.accept(f)) {\n                        in = new BufferedInputStream(fis);\n                        bzin = new BZip2CompressorInputStream(in);\n                        decompressFile(bzin, f);\n                    }\n                }\n            } catch (ArchiveExtractionException ex) {\n                LOGGER.warn(\"Exception extracting archive '{}'.\", archive.getName());\n                LOGGER.debug(\"\", ex);\n            } catch (IOException ex) {\n                LOGGER.warn(\"Exception reading archive '{}'.\", archive.getName());\n                LOGGER.debug(\"\", ex);\n            } finally {\n                //overly verbose and not needed... but keeping it anyway due to\n                //having issue with file handles being left open\n                FileUtils.close(fis);\n                FileUtils.close(in);\n                FileUtils.close(zin);\n                FileUtils.close(tin);\n                FileUtils.close(gin);\n                FileUtils.close(bzin);\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          380,
          445
        ]
      },
      {
        "file_path": "core/src/main/java/org/owasp/dependencycheck/analyzer/ArchiveAnalyzer.java",
        "class_name": "ArchiveAnalyzer",
        "method_name": "extractArchive",
        "signature": "void extractArchive(ArchiveInputStream,File,Engine)",
        "lines_hint_csv": [
          512,
          529
        ],
        "code": "    private void extractArchive(ArchiveInputStream input, File destination, Engine engine) throws ArchiveExtractionException {\n        ArchiveEntry entry;\n        try {\n            while ((entry = input.getNextEntry()) != null) {\n                final File file = new File(destination, entry.getName());\n                if (entry.isDirectory()) {\n                    if (!file.exists() && !file.mkdirs()) {\n                        final String msg = String.format(\"Unable to create directory '%s'.\", file.getAbsolutePath());\n                        throw new AnalysisException(msg);\n                    }\n                } else if (engine.accept(file)) {\n                    extractAcceptedFile(input, file);\n                }\n            }\n        } catch (IOException | AnalysisException ex) {\n            throw new ArchiveExtractionException(ex);\n        } finally {\n            FileUtils.close(input);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          512,
          531
        ]
      },
      {
        "file_path": "core/src/main/java/org/owasp/dependencycheck/utils/ExtractionUtil.java",
        "class_name": "ExtractionUtil",
        "method_name": "extractFiles",
        "signature": "void extractFiles(File,File,Engine)",
        "lines_hint_csv": [
          85,
          121
        ],
        "code": "    public static void extractFiles(File archive, File extractTo, Engine engine) throws ExtractionException {\n        if (archive == null || extractTo == null) {\n            return;\n        }\n\n        ZipEntry entry;\n        try (FileInputStream fis = new FileInputStream(archive);\n                BufferedInputStream bis = new BufferedInputStream(fis);\n                ZipInputStream zis = new ZipInputStream(bis)) {\n            while ((entry = zis.getNextEntry()) != null) {\n                if (entry.isDirectory()) {\n                    final File d = new File(extractTo, entry.getName());\n                    if (!d.exists() && !d.mkdirs()) {\n                        final String msg = String.format(\"Unable to create '%s'.\", d.getAbsolutePath());\n                        throw new ExtractionException(msg);\n                    }\n                } else {\n                    final File file = new File(extractTo, entry.getName());\n                    if (engine == null || engine.accept(file)) {\n                        try (FileOutputStream fos = new FileOutputStream(file)) {\n                            IOUtils.copy(zis, fos);\n                        } catch (FileNotFoundException ex) {\n                            LOGGER.debug(\"\", ex);\n                            final String msg = String.format(\"Unable to find file '%s'.\", file.getName());\n                            throw new ExtractionException(msg, ex);\n                        } catch (IOException ex) {\n                            LOGGER.debug(\"\", ex);\n                            final String msg = String.format(\"IO Exception while parsing file '%s'.\", file.getName());\n                            throw new ExtractionException(msg, ex);\n                        }\n                    }\n                }\n            }\n        } catch (IOException ex) {\n            final String msg = String.format(\"Exception reading archive '%s'.\", archive.getName());\n            LOGGER.debug(\"\", ex);\n            throw new ExtractionException(msg, ex);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          85,
          123
        ]
      },
      {
        "file_path": "core/src/main/java/org/owasp/dependencycheck/utils/ExtractionUtil.java",
        "class_name": "ExtractionUtil",
        "method_name": "extractGzip",
        "signature": "void extractGzip(File)",
        "lines_hint_csv": [
          244,
          262
        ],
        "code": "    public static void extractGzip(File file) throws FileNotFoundException, IOException {\n        final String originalPath = file.getPath();\n        final File gzip = new File(originalPath + \".gz\");\n        if (gzip.isFile() && !gzip.delete()) {\n            LOGGER.debug(\"Failed to delete initial temporary file when extracting 'gz' {}\", gzip.toString());\n            gzip.deleteOnExit();\n        }\n        if (!file.renameTo(gzip)) {\n            throw new IOException(\"Unable to rename '\" + file.getPath() + \"'\");\n        }\n        final File newFile = new File(originalPath);\n        try (FileInputStream fis = new FileInputStream(gzip);\n                GZIPInputStream cin = new GZIPInputStream(fis);\n                FileOutputStream out = new FileOutputStream(newFile)) {\n            IOUtils.copy(cin, out);\n        } finally {\n            if (gzip.isFile() && !org.apache.commons.io.FileUtils.deleteQuietly(gzip)) {\n                LOGGER.debug(\"Failed to delete temporary file when extracting 'gz' {}\", gzip.toString());\n                gzip.deleteOnExit();\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          244,
          265
        ]
      },
      {
        "file_path": "core/src/main/java/org/owasp/dependencycheck/utils/ExtractionUtil.java",
        "class_name": "ExtractionUtil",
        "method_name": "extractArchive",
        "signature": "void extractArchive(ArchiveInputStream,File,FilenameFilter)",
        "lines_hint_csv": [
          161,
          182
        ],
        "code": "    private static void extractArchive(ArchiveInputStream input,\n            File destination, FilenameFilter filter)\n            throws ArchiveExtractionException {\n        ArchiveEntry entry;\n        try {\n            while ((entry = input.getNextEntry()) != null) {\n                if (entry.isDirectory()) {\n                    final File dir = new File(destination, entry.getName());\n                    if (!dir.exists() && !dir.mkdirs()) {\n                        final String msg = String.format(\n                                \"Unable to create directory '%s'.\",\n                                dir.getAbsolutePath());\n                        throw new AnalysisException(msg);\n                    }\n                } else {\n                    extractFile(input, destination, filter, entry);\n                }\n            }\n        } catch (IOException | AnalysisException ex) {\n            throw new ArchiveExtractionException(ex);\n        } finally {\n            FileUtils.close(input);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          161,
          184
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-1002200",
    "project_slug": "codehaus-plexus__plexus-archiver_CVE-2018-1002200_3.5",
    "buggy_commit_id": "b9f9a425865eb47fb3665b3144ee4ca11f402704",
    "github_url": "https://github.com/codehaus-plexus/plexus-archiver",
    "nvd_metadata": {
      "description": "plexus-archiver before 3.6.0 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in an archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.",
      "published_date": "2018-07-25T17:29:00.237",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
        "class_name": "AbstractUnArchiver",
        "method_name": "extractFile",
        "signature": "void extractFile(File,File,InputStream,String,Date,boolean,Integer,String)",
        "lines_hint_csv": [
          303,
          359
        ],
        "code": "    protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                                final String entryName, final Date entryDate, final boolean isDirectory,\n                                final Integer mode, String symlinkDestination )\n        throws IOException, ArchiverException\n    {\n        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...\n        final File f = FileUtils.resolveFile( dir, entryName );\n\n        try\n        {\n            if ( !isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) )\n            {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            final File dirF = f.getParentFile();\n            if ( dirF != null )\n            {\n                dirF.mkdirs();\n            }\n\n            if ( !StringUtils.isEmpty( symlinkDestination ) )\n            {\n                SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) );\n            }\n            else if ( isDirectory )\n            {\n                f.mkdirs();\n            }\n            else\n            {\n                OutputStream out = null;\n                try\n                {\n                    out = new FileOutputStream( f );\n\n                    IOUtil.copy( compressedInputStream, out );\n                    out.close();\n                    out = null;\n                }\n                finally\n                {\n                    IOUtil.close( out );\n                }\n            }\n\n            f.setLastModified( entryDate.getTime() );\n\n            if ( !isIgnorePermissions() && mode != null && !isDirectory )\n            {\n                ArchiveEntryUtils.chmod( f, mode );\n            }\n        }\n        catch ( final FileNotFoundException ex )\n        {\n            getLogger().warn( \"Unable to expand to file \" + f.getPath() );\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          303,
          361
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-1002201",
    "project_slug": "zeroturnaround__zt-zip_CVE-2018-1002201_1.12",
    "buggy_commit_id": "bd3f3d77f3709f901fd5180a493ef32e4dfebfa6",
    "github_url": "https://github.com/zeroturnaround/zt-zip",
    "nvd_metadata": {
      "description": "zt-zip before 1.13 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.",
      "published_date": "2018-07-25T17:29:00.500",
      "cvss_v3_score": 5.5,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/zeroturnaround/zip/ZipUtil.java",
        "class_name": "Unpacker",
        "method_name": "process",
        "signature": "void process(InputStream,ZipEntry)",
        "lines_hint_csv": [
          1149,
          1168
        ],
        "code": "    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n\n        ZTFilePermissions permissions = ZipEntryUtil.getZTFilePermissions(zipEntry);\n        if (permissions != null) {\n          ZTFilePermissionsUtil.getDefaultStategy().setPermissions(file, permissions);\n        }\n      }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1149,
          1171
        ]
      },
      {
        "file_path": "src/main/java/org/zeroturnaround/zip/ZipUtil.java",
        "class_name": "Unwraper",
        "method_name": "getRootName",
        "signature": "String getRootName(String)",
        "lines_hint_csv": [
          1280,
          1286
        ],
        "code": "    private String getRootName(final String name) {\n      String newName = name.substring(FilenameUtils.getPrefixLength(name));\n      int idx = newName.indexOf(PATH_SEPARATOR);\n      if (idx < 0) {\n        throw new ZipException(\"Entry \" + newName + \" from the root of the zip is not supported\");\n      }\n      return newName.substring(0, newName.indexOf(PATH_SEPARATOR));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1280,
          1287
        ]
      },
      {
        "file_path": "src/main/java/org/zeroturnaround/zip/ZipUtil.java",
        "class_name": "Unwraper",
        "method_name": "process",
        "signature": "void process(InputStream,ZipEntry)",
        "lines_hint_csv": [
          1249,
          1271
        ],
        "code": "    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String root = getRootName(zipEntry.getName());\n      if (rootDir == null) {\n        rootDir = root;\n      }\n      else if (!rootDir.equals(root)) {\n        throw new ZipException(\"Unwrapping with multiple roots is not supported, roots: \" + rootDir + \", \" + root);\n      }\n\n      String name = mapper.map(getUnrootedName(root, zipEntry.getName()));\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n      }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1249,
          1274
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-23082",
    "project_slug": "whitesource__curekit_CVE-2022-23082_1.1.3",
    "buggy_commit_id": "7b275a67a5992165deb186b2b3f7764ddd062d26",
    "github_url": "https://github.com/whitesource/CureKit",
    "nvd_metadata": {
      "description": "In CureKit versions v1.0.1 through v1.1.3 are vulnerable to path traversal as the function isFileOutsideDir fails to sanitize the user input which may lead to path traversal.",
      "published_date": "2022-05-31T15:15:07.887",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/io/whitesource/cure/FileSecurityUtils.java",
        "class_name": "FileSecurityUtils",
        "method_name": "isFileOutsideDir",
        "signature": "boolean isFileOutsideDir(String,String)",
        "lines_hint_csv": [
          21,
          25
        ],
        "code": "  public static boolean isFileOutsideDir(\n          @NonNull final String filePath, @NonNull final String baseDirPath) throws IOException {\n    File file = new File(filePath);\n    File baseDir = new File(baseDirPath);\n    return !file.getCanonicalPath().startsWith(baseDir.getCanonicalPath());\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          21,
          26
        ]
      },
      {
        "file_path": "src/test/java/io/whitesource/cure/FileSecurityUtilsTests.java",
        "class_name": "FileSecurityUtilsTests",
        "method_name": "normalize_validInput_successfullyWithResult",
        "signature": "void normalize_validInput_successfullyWithResult()",
        "lines_hint_csv": [
          45,
          50
        ],
        "code": "  void normalize_validInput_successfullyWithResult() {\n    String validInput = \"./In/../Valid/Un/../Normalized/./Path\";\n    String expectedResult = \"Valid\" + File.separator + \"Normalized\" + File.separator + \"Path\";\n\n    String actualResult = FileSecurityUtils.normalize(validInput);\n    Assertions.assertEquals(expectedResult, actualResult);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          45,
          51
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-31159",
    "project_slug": "aws__aws-sdk-java_CVE-2022-31159_1.12.260",
    "buggy_commit_id": "5555d847a882d4c3094b00ac7cec21a16cf01a3e",
    "github_url": "https://github.com/aws/aws-sdk-java",
    "nvd_metadata": {
      "description": "The AWS SDK for Java enables Java developers to work with Amazon Web Services. A partial-path traversal issue exists within the `downloadDirectory` method in the AWS S3 TransferManager component of the AWS SDK for Java v1 prior to version 1.12.261. Applications using the SDK control the `destinationDirectory` argument, but S3 object keys are determined by the application that uploaded the objects. The `downloadDirectory` method allows the caller to pass a filesystem object in the object key but contained an issue in the validation logic for the key name. A knowledgeable actor could bypass the validation logic by including a UNIX double-dot in the bucket key. Under certain conditions, this could permit them to retrieve a directory from their S3 bucket that is one level up in the filesystem from their working directory. This issues scope is limited to directories whose name prefix matches the destinationDirectory. E.g. for destination directory`/tmp/foo`, the actor can cause a download to `/tmp/foo-bar`, but not `/tmp/bar`. If `com.amazonaws.services.s3.transfer.TransferManager::downloadDirectory` is used to download an untrusted buckets contents, the contents of that bucket can be written outside of the intended destination directory. Version 1.12.261 contains a patch for this issue. As a workaround, when calling `com.amazonaws.services.s3.transfer.TransferManager::downloadDirectory`, pass a `KeyFilter` that forbids `S3ObjectSummary` objects that `getKey` method return a string containing the substring `..` .",
      "published_date": "2022-07-15T18:15:09.037",
      "cvss_v3_score": 7.9,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AWSCodeArtifactAsyncClient.java",
        "class_name": "AWSCodeArtifactAsyncClient",
        "method_name": "describeRepositoryAsync",
        "signature": "java describeRepositoryAsync(DescribeRepositoryRequest,com)",
        "lines_hint_csv": [
          742,
          763
        ],
        "code": "    public java.util.concurrent.Future<DescribeRepositoryResult> describeRepositoryAsync(final DescribeRepositoryRequest request,\n            final com.amazonaws.handlers.AsyncHandler<DescribeRepositoryRequest, DescribeRepositoryResult> asyncHandler) {\n        final DescribeRepositoryRequest finalRequest = beforeClientExecution(request);\n\n        return executorService.submit(new java.util.concurrent.Callable<DescribeRepositoryResult>() {\n            @Override\n            public DescribeRepositoryResult call() throws Exception {\n                DescribeRepositoryResult result = null;\n\n                try {\n                    result = executeDescribeRepository(finalRequest);\n                } catch (Exception ex) {\n                    if (asyncHandler != null) {\n                        asyncHandler.onError(ex);\n                    }\n                    throw ex;\n                }\n\n                if (asyncHandler != null) {\n                    asyncHandler.onSuccess(finalRequest, result);\n                }\n                return result;\n            }\n        });\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          742,
          766
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AWSCodeArtifactAsyncClient.java",
        "class_name": "AWSCodeArtifactAsyncClient",
        "method_name": "untagResourceAsync",
        "signature": "java untagResourceAsync(UntagResourceRequest,com)",
        "lines_hint_csv": [
          1406,
          1427
        ],
        "code": "    public java.util.concurrent.Future<UntagResourceResult> untagResourceAsync(final UntagResourceRequest request,\n            final com.amazonaws.handlers.AsyncHandler<UntagResourceRequest, UntagResourceResult> asyncHandler) {\n        final UntagResourceRequest finalRequest = beforeClientExecution(request);\n\n        return executorService.submit(new java.util.concurrent.Callable<UntagResourceResult>() {\n            @Override\n            public UntagResourceResult call() throws Exception {\n                UntagResourceResult result = null;\n\n                try {\n                    result = executeUntagResource(finalRequest);\n                } catch (Exception ex) {\n                    if (asyncHandler != null) {\n                        asyncHandler.onError(ex);\n                    }\n                    throw ex;\n                }\n\n                if (asyncHandler != null) {\n                    asyncHandler.onSuccess(finalRequest, result);\n                }\n                return result;\n            }\n        });\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1406,
          1430
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AWSCodeArtifactAsyncClient.java",
        "class_name": "AWSCodeArtifactAsyncClient",
        "method_name": "describePackageVersionAsync",
        "signature": "java describePackageVersionAsync(DescribePackageVersionRequest,com)",
        "lines_hint_csv": [
          709,
          730
        ],
        "code": "    public java.util.concurrent.Future<DescribePackageVersionResult> describePackageVersionAsync(final DescribePackageVersionRequest request,\n            final com.amazonaws.handlers.AsyncHandler<DescribePackageVersionRequest, DescribePackageVersionResult> asyncHandler) {\n        final DescribePackageVersionRequest finalRequest = beforeClientExecution(request);\n\n        return executorService.submit(new java.util.concurrent.Callable<DescribePackageVersionResult>() {\n            @Override\n            public DescribePackageVersionResult call() throws Exception {\n                DescribePackageVersionResult result = null;\n\n                try {\n                    result = executeDescribePackageVersion(finalRequest);\n                } catch (Exception ex) {\n                    if (asyncHandler != null) {\n                        asyncHandler.onError(ex);\n                    }\n                    throw ex;\n                }\n\n                if (asyncHandler != null) {\n                    asyncHandler.onSuccess(finalRequest, result);\n                }\n                return result;\n            }\n        });\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          709,
          733
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AWSCodeArtifactAsyncClient.java",
        "class_name": "AWSCodeArtifactAsyncClient",
        "method_name": "tagResourceAsync",
        "signature": "java tagResourceAsync(TagResourceRequest,com)",
        "lines_hint_csv": [
          1373,
          1394
        ],
        "code": "    public java.util.concurrent.Future<TagResourceResult> tagResourceAsync(final TagResourceRequest request,\n            final com.amazonaws.handlers.AsyncHandler<TagResourceRequest, TagResourceResult> asyncHandler) {\n        final TagResourceRequest finalRequest = beforeClientExecution(request);\n\n        return executorService.submit(new java.util.concurrent.Callable<TagResourceResult>() {\n            @Override\n            public TagResourceResult call() throws Exception {\n                TagResourceResult result = null;\n\n                try {\n                    result = executeTagResource(finalRequest);\n                } catch (Exception ex) {\n                    if (asyncHandler != null) {\n                        asyncHandler.onError(ex);\n                    }\n                    throw ex;\n                }\n\n                if (asyncHandler != null) {\n                    asyncHandler.onSuccess(finalRequest, result);\n                }\n                return result;\n            }\n        });\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1373,
          1397
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifact.java",
        "class_name": "AbstractAWSCodeArtifact",
        "method_name": "describeDomain",
        "signature": "DescribeDomainResult describeDomain(DescribeDomainRequest)",
        "lines_hint_csv": [
          76,
          77
        ],
        "code": "    public DescribeDomainResult describeDomain(DescribeDomainRequest request) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          76,
          78
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifact.java",
        "class_name": "AbstractAWSCodeArtifact",
        "method_name": "untagResource",
        "signature": "UntagResourceResult untagResource(UntagResourceRequest)",
        "lines_hint_csv": [
          186,
          187
        ],
        "code": "    public UntagResourceResult untagResource(UntagResourceRequest request) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          186,
          188
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifact.java",
        "class_name": "AbstractAWSCodeArtifact",
        "method_name": "putRepositoryPermissionsPolicy",
        "signature": "PutRepositoryPermissionsPolicyResult putRepositoryPermissionsPolicy(PutRepositoryPermissionsPolicyRequest)",
        "lines_hint_csv": [
          176,
          177
        ],
        "code": "    public PutRepositoryPermissionsPolicyResult putRepositoryPermissionsPolicy(PutRepositoryPermissionsPolicyRequest request) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          176,
          178
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifact.java",
        "class_name": "AbstractAWSCodeArtifact",
        "method_name": "describeRepository",
        "signature": "DescribeRepositoryResult describeRepository(DescribeRepositoryRequest)",
        "lines_hint_csv": [
          86,
          87
        ],
        "code": "    public DescribeRepositoryResult describeRepository(DescribeRepositoryRequest request) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          86,
          88
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifactAsync.java",
        "class_name": "AbstractAWSCodeArtifactAsync",
        "method_name": "describeRepositoryAsync",
        "signature": "java describeRepositoryAsync(DescribeRepositoryRequest)",
        "lines_hint_csv": [
          176,
          178
        ],
        "code": "    public java.util.concurrent.Future<DescribeRepositoryResult> describeRepositoryAsync(DescribeRepositoryRequest request) {\n\n        return describeRepositoryAsync(request, null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          176,
          179
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifactAsync.java",
        "class_name": "AbstractAWSCodeArtifactAsync",
        "method_name": "describeDomainAsync",
        "signature": "java describeDomainAsync(DescribeDomainRequest,com)",
        "lines_hint_csv": [
          156,
          159
        ],
        "code": "    public java.util.concurrent.Future<DescribeDomainResult> describeDomainAsync(DescribeDomainRequest request,\n            com.amazonaws.handlers.AsyncHandler<DescribeDomainRequest, DescribeDomainResult> asyncHandler) {\n\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          156,
          160
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifactAsync.java",
        "class_name": "AbstractAWSCodeArtifactAsync",
        "method_name": "putRepositoryPermissionsPolicyAsync",
        "signature": "java putRepositoryPermissionsPolicyAsync(PutRepositoryPermissionsPolicyRequest,com)",
        "lines_hint_csv": [
          416,
          419
        ],
        "code": "    public java.util.concurrent.Future<PutRepositoryPermissionsPolicyResult> putRepositoryPermissionsPolicyAsync(PutRepositoryPermissionsPolicyRequest request,\n            com.amazonaws.handlers.AsyncHandler<PutRepositoryPermissionsPolicyRequest, PutRepositoryPermissionsPolicyResult> asyncHandler) {\n\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          416,
          420
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/AbstractAWSCodeArtifactAsync.java",
        "class_name": "AbstractAWSCodeArtifactAsync",
        "method_name": "untagResourceAsync",
        "signature": "java untagResourceAsync(UntagResourceRequest)",
        "lines_hint_csv": [
          436,
          438
        ],
        "code": "    public java.util.concurrent.Future<UntagResourceResult> untagResourceAsync(UntagResourceRequest request) {\n\n        return untagResourceAsync(request, null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          436,
          439
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "withFormat",
        "signature": "CopyPackageVersionsRequest withFormat(PackageFormat)",
        "lines_hint_csv": [
          351,
          353
        ],
        "code": "    public CopyPackageVersionsRequest withFormat(PackageFormat format) {\n        this.format = format.toString();\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          351,
          354
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "setFormat",
        "signature": "void setFormat(String)",
        "lines_hint_csv": [
          307,
          308
        ],
        "code": "    public void setFormat(String format) {\n        this.format = format;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          307,
          309
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "withVersions",
        "signature": "CopyPackageVersionsRequest withVersions(java)",
        "lines_hint_csv": [
          638,
          640
        ],
        "code": "    public CopyPackageVersionsRequest withVersions(java.util.Collection<String> versions) {\n        setVersions(versions);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          638,
          641
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "withPackage",
        "signature": "CopyPackageVersionsRequest withPackage(String)",
        "lines_hint_csv": [
          536,
          538
        ],
        "code": "    public CopyPackageVersionsRequest withPackage(String packageValue) {\n        setPackage(packageValue);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          536,
          539
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "withSourceRepository",
        "signature": "CopyPackageVersionsRequest withSourceRepository(String)",
        "lines_hint_csv": [
          252,
          254
        ],
        "code": "    public CopyPackageVersionsRequest withSourceRepository(String sourceRepository) {\n        setSourceRepository(sourceRepository);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          252,
          255
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "setVersions",
        "signature": "void setVersions(java)",
        "lines_hint_csv": [
          578,
          584
        ],
        "code": "    public void setVersions(java.util.Collection<String> versions) {\n        if (versions == null) {\n            this.versions = null;\n            return;\n        }\n\n        this.versions = new java.util.ArrayList<String>(versions);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          578,
          585
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "withFormat",
        "signature": "CopyPackageVersionsRequest withFormat(String)",
        "lines_hint_csv": [
          335,
          337
        ],
        "code": "    public CopyPackageVersionsRequest withFormat(String format) {\n        setFormat(format);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          335,
          338
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "getFormat",
        "signature": "String getFormat()",
        "lines_hint_csv": [
          320,
          321
        ],
        "code": "    public String getFormat() {\n        return this.format;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          320,
          322
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/CopyPackageVersionsRequest.java",
        "class_name": "CopyPackageVersionsRequest",
        "method_name": "withVersions",
        "signature": "CopyPackageVersionsRequest withVersions(String)",
        "lines_hint_csv": [
          610,
          617
        ],
        "code": "    public CopyPackageVersionsRequest withVersions(String... versions) {\n        if (this.versions == null) {\n            setVersions(new java.util.ArrayList<String>(versions.length));\n        }\n        for (String ele : versions) {\n            this.versions.add(ele);\n        }\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          610,
          618
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/DescribePackageVersionRequest.java",
        "class_name": "DescribePackageVersionRequest",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          319,
          320
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          319,
          321
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/DisposePackageVersionsRequest.java",
        "class_name": "DisposePackageVersionsRequest",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          331,
          332
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          331,
          333
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/GetPackageVersionAssetRequest.java",
        "class_name": "GetPackageVersionAssetRequest",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          334,
          335
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          334,
          336
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/GetPackageVersionReadmeRequest.java",
        "class_name": "GetPackageVersionReadmeRequest",
        "method_name": "withRepository",
        "signature": "GetPackageVersionReadmeRequest withRepository(String)",
        "lines_hint_csv": [
          224,
          226
        ],
        "code": "    public GetPackageVersionReadmeRequest withRepository(String repository) {\n        setRepository(repository);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          224,
          227
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/GetPackageVersionReadmeResult.java",
        "class_name": "GetPackageVersionReadmeResult",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          184,
          185
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          184,
          186
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsRequest.java",
        "class_name": "ListPackageVersionAssetsRequest",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          332,
          333
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          332,
          334
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsRequest.java",
        "class_name": "ListPackageVersionAssetsRequest",
        "method_name": "setFormat",
        "signature": "void setFormat(String)",
        "lines_hint_csv": [
          239,
          240
        ],
        "code": "    public void setFormat(String format) {\n        this.format = format;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          239,
          241
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsRequest.java",
        "class_name": "ListPackageVersionAssetsRequest",
        "method_name": "withRepository",
        "signature": "ListPackageVersionAssetsRequest withRepository(String)",
        "lines_hint_csv": [
          224,
          226
        ],
        "code": "    public ListPackageVersionAssetsRequest withRepository(String repository) {\n        setRepository(repository);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          224,
          227
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsRequest.java",
        "class_name": "ListPackageVersionAssetsRequest",
        "method_name": "setRepository",
        "signature": "void setRepository(String)",
        "lines_hint_csv": [
          198,
          199
        ],
        "code": "    public void setRepository(String repository) {\n        this.repository = repository;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          198,
          200
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsRequest.java",
        "class_name": "ListPackageVersionAssetsRequest",
        "method_name": "getRepository",
        "signature": "String getRepository()",
        "lines_hint_csv": [
          210,
          211
        ],
        "code": "    public String getRepository() {\n        return this.repository;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          210,
          212
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsRequest.java",
        "class_name": "ListPackageVersionAssetsRequest",
        "method_name": "getFormat",
        "signature": "String getFormat()",
        "lines_hint_csv": [
          252,
          253
        ],
        "code": "    public String getFormat() {\n        return this.format;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          252,
          254
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsResult.java",
        "class_name": "ListPackageVersionAssetsResult",
        "method_name": "getFormat",
        "signature": "String getFormat()",
        "lines_hint_csv": [
          112,
          113
        ],
        "code": "    public String getFormat() {\n        return this.format;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          112,
          114
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsResult.java",
        "class_name": "ListPackageVersionAssetsResult",
        "method_name": "setFormat",
        "signature": "void setFormat(String)",
        "lines_hint_csv": [
          99,
          100
        ],
        "code": "    public void setFormat(String format) {\n        this.format = format;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          99,
          101
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionAssetsResult.java",
        "class_name": "ListPackageVersionAssetsResult",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          192,
          193
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          192,
          194
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionDependenciesRequest.java",
        "class_name": "ListPackageVersionDependenciesRequest",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          329,
          330
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          329,
          331
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionDependenciesResult.java",
        "class_name": "ListPackageVersionDependenciesResult",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          194,
          195
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          194,
          196
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          692,
          716
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getDomain() != null)\n            sb.append(\"Domain: \").append(getDomain()).append(\",\");\n        if (getDomainOwner() != null)\n            sb.append(\"DomainOwner: \").append(getDomainOwner()).append(\",\");\n        if (getRepository() != null)\n            sb.append(\"Repository: \").append(getRepository()).append(\",\");\n        if (getFormat() != null)\n            sb.append(\"Format: \").append(getFormat()).append(\",\");\n        if (getNamespace() != null)\n            sb.append(\"Namespace: \").append(getNamespace()).append(\",\");\n        if (getPackage() != null)\n            sb.append(\"Package: \").append(getPackage()).append(\",\");\n        if (getStatus() != null)\n            sb.append(\"Status: \").append(getStatus()).append(\",\");\n        if (getSortBy() != null)\n            sb.append(\"SortBy: \").append(getSortBy()).append(\",\");\n        if (getMaxResults() != null)\n            sb.append(\"MaxResults: \").append(getMaxResults()).append(\",\");\n        if (getNextToken() != null)\n            sb.append(\"NextToken: \").append(getNextToken());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          692,
          717
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "withSortBy",
        "signature": "ListPackageVersionsRequest withSortBy(PackageVersionSortType)",
        "lines_hint_csv": [
          592,
          594
        ],
        "code": "    public ListPackageVersionsRequest withSortBy(PackageVersionSortType sortBy) {\n        this.sortBy = sortBy.toString();\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          592,
          595
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "getSortBy",
        "signature": "String getSortBy()",
        "lines_hint_csv": [
          561,
          562
        ],
        "code": "    public String getSortBy() {\n        return this.sortBy;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          561,
          563
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "withPackage",
        "signature": "ListPackageVersionsRequest withPackage(String)",
        "lines_hint_csv": [
          474,
          476
        ],
        "code": "    public ListPackageVersionsRequest withPackage(String packageValue) {\n        setPackage(packageValue);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          474,
          477
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "getStatus",
        "signature": "String getStatus()",
        "lines_hint_csv": [
          502,
          503
        ],
        "code": "    public String getStatus() {\n        return this.status;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          502,
          504
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "withStatus",
        "signature": "ListPackageVersionsRequest withStatus(PackageVersionStatus)",
        "lines_hint_csv": [
          533,
          535
        ],
        "code": "    public ListPackageVersionsRequest withStatus(PackageVersionStatus status) {\n        this.status = status.toString();\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          533,
          536
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "clone",
        "signature": "ListPackageVersionsRequest clone()",
        "lines_hint_csv": [
          791,
          792
        ],
        "code": "    public ListPackageVersionsRequest clone() {\n        return (ListPackageVersionsRequest) super.clone();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          791,
          793
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "withSortBy",
        "signature": "ListPackageVersionsRequest withSortBy(String)",
        "lines_hint_csv": [
          576,
          578
        ],
        "code": "    public ListPackageVersionsRequest withSortBy(String sortBy) {\n        setSortBy(sortBy);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          576,
          579
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "withStatus",
        "signature": "ListPackageVersionsRequest withStatus(String)",
        "lines_hint_csv": [
          517,
          519
        ],
        "code": "    public ListPackageVersionsRequest withStatus(String status) {\n        setStatus(status);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          517,
          520
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "equals",
        "signature": "boolean equals(Object)",
        "lines_hint_csv": [
          720,
          769
        ],
        "code": "    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof ListPackageVersionsRequest == false)\n            return false;\n        ListPackageVersionsRequest other = (ListPackageVersionsRequest) obj;\n        if (other.getDomain() == null ^ this.getDomain() == null)\n            return false;\n        if (other.getDomain() != null && other.getDomain().equals(this.getDomain()) == false)\n            return false;\n        if (other.getDomainOwner() == null ^ this.getDomainOwner() == null)\n            return false;\n        if (other.getDomainOwner() != null && other.getDomainOwner().equals(this.getDomainOwner()) == false)\n            return false;\n        if (other.getRepository() == null ^ this.getRepository() == null)\n            return false;\n        if (other.getRepository() != null && other.getRepository().equals(this.getRepository()) == false)\n            return false;\n        if (other.getFormat() == null ^ this.getFormat() == null)\n            return false;\n        if (other.getFormat() != null && other.getFormat().equals(this.getFormat()) == false)\n            return false;\n        if (other.getNamespace() == null ^ this.getNamespace() == null)\n            return false;\n        if (other.getNamespace() != null && other.getNamespace().equals(this.getNamespace()) == false)\n            return false;\n        if (other.getPackage() == null ^ this.getPackage() == null)\n            return false;\n        if (other.getPackage() != null && other.getPackage().equals(this.getPackage()) == false)\n            return false;\n        if (other.getStatus() == null ^ this.getStatus() == null)\n            return false;\n        if (other.getStatus() != null && other.getStatus().equals(this.getStatus()) == false)\n            return false;\n        if (other.getSortBy() == null ^ this.getSortBy() == null)\n            return false;\n        if (other.getSortBy() != null && other.getSortBy().equals(this.getSortBy()) == false)\n            return false;\n        if (other.getMaxResults() == null ^ this.getMaxResults() == null)\n            return false;\n        if (other.getMaxResults() != null && other.getMaxResults().equals(this.getMaxResults()) == false)\n            return false;\n        if (other.getNextToken() == null ^ this.getNextToken() == null)\n            return false;\n        if (other.getNextToken() != null && other.getNextToken().equals(this.getNextToken()) == false)\n            return false;\n        return true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          720,
          770
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsRequest.java",
        "class_name": "ListPackageVersionsRequest",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          338,
          339
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          338,
          340
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackageVersionsResult.java",
        "class_name": "ListPackageVersionsResult",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          314,
          315
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          314,
          316
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackagesRequest.java",
        "class_name": "ListPackagesRequest",
        "method_name": "withFormat",
        "signature": "ListPackagesRequest withFormat(PackageFormat)",
        "lines_hint_csv": [
          278,
          280
        ],
        "code": "    public ListPackagesRequest withFormat(PackageFormat format) {\n        this.format = format.toString();\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          278,
          281
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/ListPackagesRequest.java",
        "class_name": "ListPackagesRequest",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          569,
          589
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getDomain() != null)\n            sb.append(\"Domain: \").append(getDomain()).append(\",\");\n        if (getDomainOwner() != null)\n            sb.append(\"DomainOwner: \").append(getDomainOwner()).append(\",\");\n        if (getRepository() != null)\n            sb.append(\"Repository: \").append(getRepository()).append(\",\");\n        if (getFormat() != null)\n            sb.append(\"Format: \").append(getFormat()).append(\",\");\n        if (getNamespace() != null)\n            sb.append(\"Namespace: \").append(getNamespace()).append(\",\");\n        if (getPackagePrefix() != null)\n            sb.append(\"PackagePrefix: \").append(getPackagePrefix()).append(\",\");\n        if (getMaxResults() != null)\n            sb.append(\"MaxResults: \").append(getMaxResults()).append(\",\");\n        if (getNextToken() != null)\n            sb.append(\"NextToken: \").append(getNextToken());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          569,
          590
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageDependency.java",
        "class_name": "PackageDependency",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          121,
          122
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          123
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageSummary.java",
        "class_name": "PackageSummary",
        "method_name": "setPackage",
        "signature": "void setPackage(String)",
        "lines_hint_csv": [
          283,
          284
        ],
        "code": "    public void setPackage(String packageValue) {\n        this.packageValue = packageValue;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          283,
          285
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageSummary.java",
        "class_name": "PackageSummary",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          323,
          333
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getFormat() != null)\n            sb.append(\"Format: \").append(getFormat()).append(\",\");\n        if (getNamespace() != null)\n            sb.append(\"Namespace: \").append(getNamespace()).append(\",\");\n        if (getPackage() != null)\n            sb.append(\"Package: \").append(getPackage());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          323,
          334
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageVersionDescription.java",
        "class_name": "PackageVersionDescription",
        "method_name": "equals",
        "signature": "boolean equals(Object)",
        "lines_hint_csv": [
          840,
          897
        ],
        "code": "    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof PackageVersionDescription == false)\n            return false;\n        PackageVersionDescription other = (PackageVersionDescription) obj;\n        if (other.getFormat() == null ^ this.getFormat() == null)\n            return false;\n        if (other.getFormat() != null && other.getFormat().equals(this.getFormat()) == false)\n            return false;\n        if (other.getNamespace() == null ^ this.getNamespace() == null)\n            return false;\n        if (other.getNamespace() != null && other.getNamespace().equals(this.getNamespace()) == false)\n            return false;\n        if (other.getPackageName() == null ^ this.getPackageName() == null)\n            return false;\n        if (other.getPackageName() != null && other.getPackageName().equals(this.getPackageName()) == false)\n            return false;\n        if (other.getDisplayName() == null ^ this.getDisplayName() == null)\n            return false;\n        if (other.getDisplayName() != null && other.getDisplayName().equals(this.getDisplayName()) == false)\n            return false;\n        if (other.getVersion() == null ^ this.getVersion() == null)\n            return false;\n        if (other.getVersion() != null && other.getVersion().equals(this.getVersion()) == false)\n            return false;\n        if (other.getSummary() == null ^ this.getSummary() == null)\n            return false;\n        if (other.getSummary() != null && other.getSummary().equals(this.getSummary()) == false)\n            return false;\n        if (other.getHomePage() == null ^ this.getHomePage() == null)\n            return false;\n        if (other.getHomePage() != null && other.getHomePage().equals(this.getHomePage()) == false)\n            return false;\n        if (other.getSourceCodeRepository() == null ^ this.getSourceCodeRepository() == null)\n            return false;\n        if (other.getSourceCodeRepository() != null && other.getSourceCodeRepository().equals(this.getSourceCodeRepository()) == false)\n            return false;\n        if (other.getPublishedTime() == null ^ this.getPublishedTime() == null)\n            return false;\n        if (other.getPublishedTime() != null && other.getPublishedTime().equals(this.getPublishedTime()) == false)\n            return false;\n        if (other.getLicenses() == null ^ this.getLicenses() == null)\n            return false;\n        if (other.getLicenses() != null && other.getLicenses().equals(this.getLicenses()) == false)\n            return false;\n        if (other.getRevision() == null ^ this.getRevision() == null)\n            return false;\n        if (other.getRevision() != null && other.getRevision().equals(this.getRevision()) == false)\n            return false;\n        if (other.getStatus() == null ^ this.getStatus() == null)\n            return false;\n        if (other.getStatus() != null && other.getStatus().equals(this.getStatus()) == false)\n            return false;\n        return true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          840,
          898
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageVersionDescription.java",
        "class_name": "PackageVersionDescription",
        "method_name": "setFormat",
        "signature": "void setFormat(String)",
        "lines_hint_csv": [
          135,
          136
        ],
        "code": "    public void setFormat(String format) {\n        this.format = format;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          135,
          137
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageVersionDescription.java",
        "class_name": "PackageVersionDescription",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          808,
          836
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getFormat() != null)\n            sb.append(\"Format: \").append(getFormat()).append(\",\");\n        if (getNamespace() != null)\n            sb.append(\"Namespace: \").append(getNamespace()).append(\",\");\n        if (getPackageName() != null)\n            sb.append(\"PackageName: \").append(getPackageName()).append(\",\");\n        if (getDisplayName() != null)\n            sb.append(\"DisplayName: \").append(getDisplayName()).append(\",\");\n        if (getVersion() != null)\n            sb.append(\"Version: \").append(getVersion()).append(\",\");\n        if (getSummary() != null)\n            sb.append(\"Summary: \").append(getSummary()).append(\",\");\n        if (getHomePage() != null)\n            sb.append(\"HomePage: \").append(getHomePage()).append(\",\");\n        if (getSourceCodeRepository() != null)\n            sb.append(\"SourceCodeRepository: \").append(getSourceCodeRepository()).append(\",\");\n        if (getPublishedTime() != null)\n            sb.append(\"PublishedTime: \").append(getPublishedTime()).append(\",\");\n        if (getLicenses() != null)\n            sb.append(\"Licenses: \").append(getLicenses()).append(\",\");\n        if (getRevision() != null)\n            sb.append(\"Revision: \").append(getRevision()).append(\",\");\n        if (getStatus() != null)\n            sb.append(\"Status: \").append(getStatus());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          808,
          837
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageVersionDescription.java",
        "class_name": "PackageVersionDescription",
        "method_name": "hashCode",
        "signature": "int hashCode()",
        "lines_hint_csv": [
          901,
          917
        ],
        "code": "    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n\n        hashCode = prime * hashCode + ((getFormat() == null) ? 0 : getFormat().hashCode());\n        hashCode = prime * hashCode + ((getNamespace() == null) ? 0 : getNamespace().hashCode());\n        hashCode = prime * hashCode + ((getPackageName() == null) ? 0 : getPackageName().hashCode());\n        hashCode = prime * hashCode + ((getDisplayName() == null) ? 0 : getDisplayName().hashCode());\n        hashCode = prime * hashCode + ((getVersion() == null) ? 0 : getVersion().hashCode());\n        hashCode = prime * hashCode + ((getSummary() == null) ? 0 : getSummary().hashCode());\n        hashCode = prime * hashCode + ((getHomePage() == null) ? 0 : getHomePage().hashCode());\n        hashCode = prime * hashCode + ((getSourceCodeRepository() == null) ? 0 : getSourceCodeRepository().hashCode());\n        hashCode = prime * hashCode + ((getPublishedTime() == null) ? 0 : getPublishedTime().hashCode());\n        hashCode = prime * hashCode + ((getLicenses() == null) ? 0 : getLicenses().hashCode());\n        hashCode = prime * hashCode + ((getRevision() == null) ? 0 : getRevision().hashCode());\n        hashCode = prime * hashCode + ((getStatus() == null) ? 0 : getStatus().hashCode());\n        return hashCode;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          901,
          918
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageVersionSummary.java",
        "class_name": "PackageVersionSummary",
        "method_name": "clone",
        "signature": "PackageVersionSummary clone()",
        "lines_hint_csv": [
          250,
          254
        ],
        "code": "    public PackageVersionSummary clone() {\n        try {\n            return (PackageVersionSummary) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new IllegalStateException(\"Got a CloneNotSupportedException from Object.clone() \" + \"even though we're Cloneable!\", e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          250,
          256
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/PackageVersionSummary.java",
        "class_name": "PackageVersionSummary",
        "method_name": "setVersion",
        "signature": "void setVersion(String)",
        "lines_hint_csv": [
          61,
          62
        ],
        "code": "    public void setVersion(String version) {\n        this.version = version;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          61,
          63
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/UpdatePackageVersionsStatusRequest.java",
        "class_name": "UpdatePackageVersionsStatusRequest",
        "method_name": "setNamespace",
        "signature": "void setNamespace(String)",
        "lines_hint_csv": [
          347,
          348
        ],
        "code": "    public void setNamespace(String namespace) {\n        this.namespace = namespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          347,
          349
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/ListPackageVersionsRequestMarshaller.java",
        "class_name": "ListPackageVersionsRequestMarshaller",
        "method_name": "getInstance",
        "signature": "ListPackageVersionsRequestMarshaller getInstance()",
        "lines_hint_csv": [
          53,
          54
        ],
        "code": "    public static ListPackageVersionsRequestMarshaller getInstance() {\n        return instance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          53,
          55
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/ListPackageVersionsRequestMarshaller.java",
        "class_name": "ListPackageVersionsRequestMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(ListPackageVersionsRequest,ProtocolMarshaller)",
        "lines_hint_csv": [
          60,
          78
        ],
        "code": "    public void marshall(ListPackageVersionsRequest listPackageVersionsRequest, ProtocolMarshaller protocolMarshaller) {\n\n        if (listPackageVersionsRequest == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(listPackageVersionsRequest.getDomain(), DOMAIN_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getDomainOwner(), DOMAINOWNER_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getRepository(), REPOSITORY_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getFormat(), FORMAT_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getNamespace(), NAMESPACE_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getPackage(), PACKAGE_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getStatus(), STATUS_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getSortBy(), SORTBY_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getMaxResults(), MAXRESULTS_BINDING);\n            protocolMarshaller.marshall(listPackageVersionsRequest.getNextToken(), NEXTTOKEN_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          60,
          80
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/ListPackagesRequestMarshaller.java",
        "class_name": "ListPackagesRequestMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(ListPackagesRequest,ProtocolMarshaller)",
        "lines_hint_csv": [
          56,
          72
        ],
        "code": "    public void marshall(ListPackagesRequest listPackagesRequest, ProtocolMarshaller protocolMarshaller) {\n\n        if (listPackagesRequest == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(listPackagesRequest.getDomain(), DOMAIN_BINDING);\n            protocolMarshaller.marshall(listPackagesRequest.getDomainOwner(), DOMAINOWNER_BINDING);\n            protocolMarshaller.marshall(listPackagesRequest.getRepository(), REPOSITORY_BINDING);\n            protocolMarshaller.marshall(listPackagesRequest.getFormat(), FORMAT_BINDING);\n            protocolMarshaller.marshall(listPackagesRequest.getNamespace(), NAMESPACE_BINDING);\n            protocolMarshaller.marshall(listPackagesRequest.getPackagePrefix(), PACKAGEPREFIX_BINDING);\n            protocolMarshaller.marshall(listPackagesRequest.getMaxResults(), MAXRESULTS_BINDING);\n            protocolMarshaller.marshall(listPackagesRequest.getNextToken(), NEXTTOKEN_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          56,
          74
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageSummaryJsonUnmarshaller.java",
        "class_name": "PackageSummaryJsonUnmarshaller",
        "method_name": "unmarshall",
        "signature": "PackageSummary unmarshall(JsonUnmarshallerContext)",
        "lines_hint_csv": [
          32,
          72
        ],
        "code": "    public PackageSummary unmarshall(JsonUnmarshallerContext context) throws Exception {\n        PackageSummary packageSummary = new PackageSummary();\n\n        int originalDepth = context.getCurrentDepth();\n        String currentParentElement = context.getCurrentParentElement();\n        int targetDepth = originalDepth + 1;\n\n        JsonToken token = context.getCurrentToken();\n        if (token == null)\n            token = context.nextToken();\n        if (token == VALUE_NULL) {\n            return null;\n        }\n\n        while (true) {\n            if (token == null)\n                break;\n\n            if (token == FIELD_NAME || token == START_OBJECT) {\n                if (context.testExpression(\"format\", targetDepth)) {\n                    context.nextToken();\n                    packageSummary.setFormat(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"namespace\", targetDepth)) {\n                    context.nextToken();\n                    packageSummary.setNamespace(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"package\", targetDepth)) {\n                    context.nextToken();\n                    packageSummary.setPackage(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n            } else if (token == END_ARRAY || token == END_OBJECT) {\n                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n                    if (context.getCurrentDepth() <= originalDepth)\n                        break;\n                }\n            }\n            token = context.nextToken();\n        }\n\n        return packageSummary;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          32,
          73
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageSummaryMarshaller.java",
        "class_name": "PackageSummaryMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(PackageSummary,ProtocolMarshaller)",
        "lines_hint_csv": [
          46,
          57
        ],
        "code": "    public void marshall(PackageSummary packageSummary, ProtocolMarshaller protocolMarshaller) {\n\n        if (packageSummary == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(packageSummary.getFormat(), FORMAT_BINDING);\n            protocolMarshaller.marshall(packageSummary.getNamespace(), NAMESPACE_BINDING);\n            protocolMarshaller.marshall(packageSummary.getPackage(), PACKAGE_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          46,
          59
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageSummaryMarshaller.java",
        "class_name": "PackageSummaryMarshaller",
        "method_name": "getInstance",
        "signature": "PackageSummaryMarshaller getInstance()",
        "lines_hint_csv": [
          39,
          40
        ],
        "code": "    public static PackageSummaryMarshaller getInstance() {\n        return instance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          39,
          41
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageVersionDescriptionJsonUnmarshaller.java",
        "class_name": "PackageVersionDescriptionJsonUnmarshaller",
        "method_name": "unmarshall",
        "signature": "PackageVersionDescription unmarshall(JsonUnmarshallerContext)",
        "lines_hint_csv": [
          32,
          110
        ],
        "code": "    public PackageVersionDescription unmarshall(JsonUnmarshallerContext context) throws Exception {\n        PackageVersionDescription packageVersionDescription = new PackageVersionDescription();\n\n        int originalDepth = context.getCurrentDepth();\n        String currentParentElement = context.getCurrentParentElement();\n        int targetDepth = originalDepth + 1;\n\n        JsonToken token = context.getCurrentToken();\n        if (token == null)\n            token = context.nextToken();\n        if (token == VALUE_NULL) {\n            return null;\n        }\n\n        while (true) {\n            if (token == null)\n                break;\n\n            if (token == FIELD_NAME || token == START_OBJECT) {\n                if (context.testExpression(\"format\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setFormat(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"namespace\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setNamespace(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"packageName\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setPackageName(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"displayName\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setDisplayName(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"version\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setVersion(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"summary\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setSummary(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"homePage\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setHomePage(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"sourceCodeRepository\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setSourceCodeRepository(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"publishedTime\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setPublishedTime(DateJsonUnmarshallerFactory.getInstance(\"unixTimestamp\").unmarshall(context));\n                }\n                if (context.testExpression(\"licenses\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setLicenses(new ListUnmarshaller<LicenseInfo>(LicenseInfoJsonUnmarshaller.getInstance())\n\n                    .unmarshall(context));\n                }\n                if (context.testExpression(\"revision\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setRevision(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"status\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionDescription.setStatus(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n            } else if (token == END_ARRAY || token == END_OBJECT) {\n                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n                    if (context.getCurrentDepth() <= originalDepth)\n                        break;\n                }\n            }\n            token = context.nextToken();\n        }\n\n        return packageVersionDescription;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          32,
          111
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageVersionDescriptionMarshaller.java",
        "class_name": "PackageVersionDescriptionMarshaller",
        "method_name": "getInstance",
        "signature": "PackageVersionDescriptionMarshaller getInstance()",
        "lines_hint_csv": [
          58,
          59
        ],
        "code": "    public static PackageVersionDescriptionMarshaller getInstance() {\n        return instance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          58,
          60
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageVersionDescriptionMarshaller.java",
        "class_name": "PackageVersionDescriptionMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(PackageVersionDescription,ProtocolMarshaller)",
        "lines_hint_csv": [
          65,
          85
        ],
        "code": "    public void marshall(PackageVersionDescription packageVersionDescription, ProtocolMarshaller protocolMarshaller) {\n\n        if (packageVersionDescription == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(packageVersionDescription.getFormat(), FORMAT_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getNamespace(), NAMESPACE_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getPackageName(), PACKAGENAME_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getDisplayName(), DISPLAYNAME_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getVersion(), VERSION_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getSummary(), SUMMARY_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getHomePage(), HOMEPAGE_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getSourceCodeRepository(), SOURCECODEREPOSITORY_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getPublishedTime(), PUBLISHEDTIME_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getLicenses(), LICENSES_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getRevision(), REVISION_BINDING);\n            protocolMarshaller.marshall(packageVersionDescription.getStatus(), STATUS_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          65,
          87
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageVersionSummaryJsonUnmarshaller.java",
        "class_name": "PackageVersionSummaryJsonUnmarshaller",
        "method_name": "unmarshall",
        "signature": "PackageVersionSummary unmarshall(JsonUnmarshallerContext)",
        "lines_hint_csv": [
          32,
          72
        ],
        "code": "    public PackageVersionSummary unmarshall(JsonUnmarshallerContext context) throws Exception {\n        PackageVersionSummary packageVersionSummary = new PackageVersionSummary();\n\n        int originalDepth = context.getCurrentDepth();\n        String currentParentElement = context.getCurrentParentElement();\n        int targetDepth = originalDepth + 1;\n\n        JsonToken token = context.getCurrentToken();\n        if (token == null)\n            token = context.nextToken();\n        if (token == VALUE_NULL) {\n            return null;\n        }\n\n        while (true) {\n            if (token == null)\n                break;\n\n            if (token == FIELD_NAME || token == START_OBJECT) {\n                if (context.testExpression(\"version\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionSummary.setVersion(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"revision\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionSummary.setRevision(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"status\", targetDepth)) {\n                    context.nextToken();\n                    packageVersionSummary.setStatus(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n            } else if (token == END_ARRAY || token == END_OBJECT) {\n                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n                    if (context.getCurrentDepth() <= originalDepth)\n                        break;\n                }\n            }\n            token = context.nextToken();\n        }\n\n        return packageVersionSummary;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          32,
          73
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageVersionSummaryMarshaller.java",
        "class_name": "PackageVersionSummaryMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(PackageVersionSummary,ProtocolMarshaller)",
        "lines_hint_csv": [
          46,
          57
        ],
        "code": "    public void marshall(PackageVersionSummary packageVersionSummary, ProtocolMarshaller protocolMarshaller) {\n\n        if (packageVersionSummary == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(packageVersionSummary.getVersion(), VERSION_BINDING);\n            protocolMarshaller.marshall(packageVersionSummary.getRevision(), REVISION_BINDING);\n            protocolMarshaller.marshall(packageVersionSummary.getStatus(), STATUS_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          46,
          59
        ]
      },
      {
        "file_path": "aws-java-sdk-codeartifact/src/main/java/com/amazonaws/services/codeartifact/model/transform/PackageVersionSummaryMarshaller.java",
        "class_name": "PackageVersionSummaryMarshaller",
        "method_name": "getInstance",
        "signature": "PackageVersionSummaryMarshaller getInstance()",
        "lines_hint_csv": [
          39,
          40
        ],
        "code": "    public static PackageVersionSummaryMarshaller getInstance() {\n        return instance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          39,
          41
        ]
      },
      {
        "file_path": "aws-java-sdk-fms/src/main/java/com/amazonaws/services/fms/model/NetworkFirewallPolicyDescription.java",
        "class_name": "NetworkFirewallPolicyDescription",
        "method_name": "equals",
        "signature": "boolean equals(Object)",
        "lines_hint_csv": [
          439,
          469
        ],
        "code": "    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof NetworkFirewallPolicyDescription == false)\n            return false;\n        NetworkFirewallPolicyDescription other = (NetworkFirewallPolicyDescription) obj;\n        if (other.getStatelessRuleGroups() == null ^ this.getStatelessRuleGroups() == null)\n            return false;\n        if (other.getStatelessRuleGroups() != null && other.getStatelessRuleGroups().equals(this.getStatelessRuleGroups()) == false)\n            return false;\n        if (other.getStatelessDefaultActions() == null ^ this.getStatelessDefaultActions() == null)\n            return false;\n        if (other.getStatelessDefaultActions() != null && other.getStatelessDefaultActions().equals(this.getStatelessDefaultActions()) == false)\n            return false;\n        if (other.getStatelessFragmentDefaultActions() == null ^ this.getStatelessFragmentDefaultActions() == null)\n            return false;\n        if (other.getStatelessFragmentDefaultActions() != null\n                && other.getStatelessFragmentDefaultActions().equals(this.getStatelessFragmentDefaultActions()) == false)\n            return false;\n        if (other.getStatelessCustomActions() == null ^ this.getStatelessCustomActions() == null)\n            return false;\n        if (other.getStatelessCustomActions() != null && other.getStatelessCustomActions().equals(this.getStatelessCustomActions()) == false)\n            return false;\n        if (other.getStatefulRuleGroups() == null ^ this.getStatefulRuleGroups() == null)\n            return false;\n        if (other.getStatefulRuleGroups() != null && other.getStatefulRuleGroups().equals(this.getStatefulRuleGroups()) == false)\n            return false;\n        return true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          439,
          470
        ]
      },
      {
        "file_path": "aws-java-sdk-fms/src/main/java/com/amazonaws/services/fms/model/StatefulRuleGroup.java",
        "class_name": "StatefulRuleGroup",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          133,
          141
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getRuleGroupName() != null)\n            sb.append(\"RuleGroupName: \").append(getRuleGroupName()).append(\",\");\n        if (getResourceId() != null)\n            sb.append(\"ResourceId: \").append(getResourceId());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          133,
          142
        ]
      },
      {
        "file_path": "aws-java-sdk-fms/src/main/java/com/amazonaws/services/fms/model/transform/NetworkFirewallPolicyDescriptionJsonUnmarshaller.java",
        "class_name": "NetworkFirewallPolicyDescriptionJsonUnmarshaller",
        "method_name": "unmarshall",
        "signature": "NetworkFirewallPolicyDescription unmarshall(JsonUnmarshallerContext)",
        "lines_hint_csv": [
          32,
          92
        ],
        "code": "    public NetworkFirewallPolicyDescription unmarshall(JsonUnmarshallerContext context) throws Exception {\n        NetworkFirewallPolicyDescription networkFirewallPolicyDescription = new NetworkFirewallPolicyDescription();\n\n        int originalDepth = context.getCurrentDepth();\n        String currentParentElement = context.getCurrentParentElement();\n        int targetDepth = originalDepth + 1;\n\n        JsonToken token = context.getCurrentToken();\n        if (token == null)\n            token = context.nextToken();\n        if (token == VALUE_NULL) {\n            return null;\n        }\n\n        while (true) {\n            if (token == null)\n                break;\n\n            if (token == FIELD_NAME || token == START_OBJECT) {\n                if (context.testExpression(\"StatelessRuleGroups\", targetDepth)) {\n                    context.nextToken();\n                    networkFirewallPolicyDescription.setStatelessRuleGroups(new ListUnmarshaller<StatelessRuleGroup>(StatelessRuleGroupJsonUnmarshaller\n                            .getInstance())\n\n                    .unmarshall(context));\n                }\n                if (context.testExpression(\"StatelessDefaultActions\", targetDepth)) {\n                    context.nextToken();\n                    networkFirewallPolicyDescription.setStatelessDefaultActions(new ListUnmarshaller<String>(context.getUnmarshaller(String.class))\n\n                    .unmarshall(context));\n                }\n                if (context.testExpression(\"StatelessFragmentDefaultActions\", targetDepth)) {\n                    context.nextToken();\n                    networkFirewallPolicyDescription.setStatelessFragmentDefaultActions(new ListUnmarshaller<String>(context.getUnmarshaller(String.class))\n\n                    .unmarshall(context));\n                }\n                if (context.testExpression(\"StatelessCustomActions\", targetDepth)) {\n                    context.nextToken();\n                    networkFirewallPolicyDescription.setStatelessCustomActions(new ListUnmarshaller<String>(context.getUnmarshaller(String.class))\n\n                    .unmarshall(context));\n                }\n                if (context.testExpression(\"StatefulRuleGroups\", targetDepth)) {\n                    context.nextToken();\n                    networkFirewallPolicyDescription.setStatefulRuleGroups(new ListUnmarshaller<StatefulRuleGroup>(StatefulRuleGroupJsonUnmarshaller\n                            .getInstance())\n\n                    .unmarshall(context));\n                }\n            } else if (token == END_ARRAY || token == END_OBJECT) {\n                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n                    if (context.getCurrentDepth() <= originalDepth)\n                        break;\n                }\n            }\n            token = context.nextToken();\n        }\n\n        return networkFirewallPolicyDescription;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          32,
          93
        ]
      },
      {
        "file_path": "aws-java-sdk-fms/src/main/java/com/amazonaws/services/fms/model/transform/NetworkFirewallPolicyDescriptionMarshaller.java",
        "class_name": "NetworkFirewallPolicyDescriptionMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(NetworkFirewallPolicyDescription,ProtocolMarshaller)",
        "lines_hint_csv": [
          51,
          64
        ],
        "code": "    public void marshall(NetworkFirewallPolicyDescription networkFirewallPolicyDescription, ProtocolMarshaller protocolMarshaller) {\n\n        if (networkFirewallPolicyDescription == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(networkFirewallPolicyDescription.getStatelessRuleGroups(), STATELESSRULEGROUPS_BINDING);\n            protocolMarshaller.marshall(networkFirewallPolicyDescription.getStatelessDefaultActions(), STATELESSDEFAULTACTIONS_BINDING);\n            protocolMarshaller.marshall(networkFirewallPolicyDescription.getStatelessFragmentDefaultActions(), STATELESSFRAGMENTDEFAULTACTIONS_BINDING);\n            protocolMarshaller.marshall(networkFirewallPolicyDescription.getStatelessCustomActions(), STATELESSCUSTOMACTIONS_BINDING);\n            protocolMarshaller.marshall(networkFirewallPolicyDescription.getStatefulRuleGroups(), STATEFULRULEGROUPS_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          51,
          66
        ]
      },
      {
        "file_path": "aws-java-sdk-fms/src/main/java/com/amazonaws/services/fms/model/transform/StatefulRuleGroupJsonUnmarshaller.java",
        "class_name": "StatefulRuleGroupJsonUnmarshaller",
        "method_name": "unmarshall",
        "signature": "StatefulRuleGroup unmarshall(JsonUnmarshallerContext)",
        "lines_hint_csv": [
          32,
          68
        ],
        "code": "    public StatefulRuleGroup unmarshall(JsonUnmarshallerContext context) throws Exception {\n        StatefulRuleGroup statefulRuleGroup = new StatefulRuleGroup();\n\n        int originalDepth = context.getCurrentDepth();\n        String currentParentElement = context.getCurrentParentElement();\n        int targetDepth = originalDepth + 1;\n\n        JsonToken token = context.getCurrentToken();\n        if (token == null)\n            token = context.nextToken();\n        if (token == VALUE_NULL) {\n            return null;\n        }\n\n        while (true) {\n            if (token == null)\n                break;\n\n            if (token == FIELD_NAME || token == START_OBJECT) {\n                if (context.testExpression(\"RuleGroupName\", targetDepth)) {\n                    context.nextToken();\n                    statefulRuleGroup.setRuleGroupName(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"ResourceId\", targetDepth)) {\n                    context.nextToken();\n                    statefulRuleGroup.setResourceId(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n            } else if (token == END_ARRAY || token == END_OBJECT) {\n                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n                    if (context.getCurrentDepth() <= originalDepth)\n                        break;\n                }\n            }\n            token = context.nextToken();\n        }\n\n        return statefulRuleGroup;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          32,
          69
        ]
      },
      {
        "file_path": "aws-java-sdk-fms/src/main/java/com/amazonaws/services/fms/model/transform/StatefulRuleGroupMarshaller.java",
        "class_name": "StatefulRuleGroupMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(StatefulRuleGroup,ProtocolMarshaller)",
        "lines_hint_csv": [
          44,
          54
        ],
        "code": "    public void marshall(StatefulRuleGroup statefulRuleGroup, ProtocolMarshaller protocolMarshaller) {\n\n        if (statefulRuleGroup == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(statefulRuleGroup.getRuleGroupName(), RULEGROUPNAME_BINDING);\n            protocolMarshaller.marshall(statefulRuleGroup.getResourceId(), RESOURCEID_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          44,
          56
        ]
      },
      {
        "file_path": "aws-java-sdk-fms/src/main/java/com/amazonaws/services/fms/model/transform/StatefulRuleGroupMarshaller.java",
        "class_name": "StatefulRuleGroupMarshaller",
        "method_name": "getInstance",
        "signature": "StatefulRuleGroupMarshaller getInstance()",
        "lines_hint_csv": [
          37,
          38
        ],
        "code": "    public static StatefulRuleGroupMarshaller getInstance() {\n        return instance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          37,
          39
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateJobRequest.java",
        "class_name": "CreateJobRequest",
        "method_name": "withNumberOfWorkers",
        "signature": "CreateJobRequest withNumberOfWorkers(Integer)",
        "lines_hint_csv": [
          1397,
          1399
        ],
        "code": "    public CreateJobRequest withNumberOfWorkers(Integer numberOfWorkers) {\n        setNumberOfWorkers(numberOfWorkers);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1397,
          1400
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateJobRequest.java",
        "class_name": "CreateJobRequest",
        "method_name": "setTimeout",
        "signature": "void setTimeout(Integer)",
        "lines_hint_csv": [
          855,
          856
        ],
        "code": "    public void setTimeout(Integer timeout) {\n        this.timeout = timeout;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          855,
          857
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateJobRequest.java",
        "class_name": "CreateJobRequest",
        "method_name": "getDefaultArguments",
        "signature": "java getDefaultArguments()",
        "lines_hint_csv": [
          509,
          510
        ],
        "code": "    public java.util.Map<String, String> getDefaultArguments() {\n        return defaultArguments;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          509,
          511
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateJobRequest.java",
        "class_name": "CreateJobRequest",
        "method_name": "addDefaultArgumentsEntry",
        "signature": "CreateJobRequest addDefaultArgumentsEntry(String,String)",
        "lines_hint_csv": [
          602,
          609
        ],
        "code": "    public CreateJobRequest addDefaultArgumentsEntry(String key, String value) {\n        if (null == this.defaultArguments) {\n            this.defaultArguments = new java.util.HashMap<String, String>();\n        }\n        if (this.defaultArguments.containsKey(key))\n            throw new IllegalArgumentException(\"Duplicated keys (\" + key.toString() + \") are provided.\");\n        this.defaultArguments.put(key, value);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          602,
          610
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "setNumberOfWorkers",
        "signature": "void setNumberOfWorkers(Integer)",
        "lines_hint_csv": [
          527,
          528
        ],
        "code": "    public void setNumberOfWorkers(Integer numberOfWorkers) {\n        this.numberOfWorkers = numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          527,
          529
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "equals",
        "signature": "boolean equals(Object)",
        "lines_hint_csv": [
          858,
          927
        ],
        "code": "    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof CreateSessionRequest == false)\n            return false;\n        CreateSessionRequest other = (CreateSessionRequest) obj;\n        if (other.getId() == null ^ this.getId() == null)\n            return false;\n        if (other.getId() != null && other.getId().equals(this.getId()) == false)\n            return false;\n        if (other.getDescription() == null ^ this.getDescription() == null)\n            return false;\n        if (other.getDescription() != null && other.getDescription().equals(this.getDescription()) == false)\n            return false;\n        if (other.getRole() == null ^ this.getRole() == null)\n            return false;\n        if (other.getRole() != null && other.getRole().equals(this.getRole()) == false)\n            return false;\n        if (other.getCommand() == null ^ this.getCommand() == null)\n            return false;\n        if (other.getCommand() != null && other.getCommand().equals(this.getCommand()) == false)\n            return false;\n        if (other.getTimeout() == null ^ this.getTimeout() == null)\n            return false;\n        if (other.getTimeout() != null && other.getTimeout().equals(this.getTimeout()) == false)\n            return false;\n        if (other.getIdleTimeout() == null ^ this.getIdleTimeout() == null)\n            return false;\n        if (other.getIdleTimeout() != null && other.getIdleTimeout().equals(this.getIdleTimeout()) == false)\n            return false;\n        if (other.getDefaultArguments() == null ^ this.getDefaultArguments() == null)\n            return false;\n        if (other.getDefaultArguments() != null && other.getDefaultArguments().equals(this.getDefaultArguments()) == false)\n            return false;\n        if (other.getConnections() == null ^ this.getConnections() == null)\n            return false;\n        if (other.getConnections() != null && other.getConnections().equals(this.getConnections()) == false)\n            return false;\n        if (other.getMaxCapacity() == null ^ this.getMaxCapacity() == null)\n            return false;\n        if (other.getMaxCapacity() != null && other.getMaxCapacity().equals(this.getMaxCapacity()) == false)\n            return false;\n        if (other.getNumberOfWorkers() == null ^ this.getNumberOfWorkers() == null)\n            return false;\n        if (other.getNumberOfWorkers() != null && other.getNumberOfWorkers().equals(this.getNumberOfWorkers()) == false)\n            return false;\n        if (other.getWorkerType() == null ^ this.getWorkerType() == null)\n            return false;\n        if (other.getWorkerType() != null && other.getWorkerType().equals(this.getWorkerType()) == false)\n            return false;\n        if (other.getSecurityConfiguration() == null ^ this.getSecurityConfiguration() == null)\n            return false;\n        if (other.getSecurityConfiguration() != null && other.getSecurityConfiguration().equals(this.getSecurityConfiguration()) == false)\n            return false;\n        if (other.getGlueVersion() == null ^ this.getGlueVersion() == null)\n            return false;\n        if (other.getGlueVersion() != null && other.getGlueVersion().equals(this.getGlueVersion()) == false)\n            return false;\n        if (other.getTags() == null ^ this.getTags() == null)\n            return false;\n        if (other.getTags() != null && other.getTags().equals(this.getTags()) == false)\n            return false;\n        if (other.getRequestOrigin() == null ^ this.getRequestOrigin() == null)\n            return false;\n        if (other.getRequestOrigin() != null && other.getRequestOrigin().equals(this.getRequestOrigin()) == false)\n            return false;\n        return true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          858,
          928
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "getRequestOrigin",
        "signature": "String getRequestOrigin()",
        "lines_hint_csv": [
          792,
          793
        ],
        "code": "    public String getRequestOrigin() {\n        return this.requestOrigin;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          792,
          794
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "hashCode",
        "signature": "int hashCode()",
        "lines_hint_csv": [
          931,
          950
        ],
        "code": "    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n\n        hashCode = prime * hashCode + ((getId() == null) ? 0 : getId().hashCode());\n        hashCode = prime * hashCode + ((getDescription() == null) ? 0 : getDescription().hashCode());\n        hashCode = prime * hashCode + ((getRole() == null) ? 0 : getRole().hashCode());\n        hashCode = prime * hashCode + ((getCommand() == null) ? 0 : getCommand().hashCode());\n        hashCode = prime * hashCode + ((getTimeout() == null) ? 0 : getTimeout().hashCode());\n        hashCode = prime * hashCode + ((getIdleTimeout() == null) ? 0 : getIdleTimeout().hashCode());\n        hashCode = prime * hashCode + ((getDefaultArguments() == null) ? 0 : getDefaultArguments().hashCode());\n        hashCode = prime * hashCode + ((getConnections() == null) ? 0 : getConnections().hashCode());\n        hashCode = prime * hashCode + ((getMaxCapacity() == null) ? 0 : getMaxCapacity().hashCode());\n        hashCode = prime * hashCode + ((getNumberOfWorkers() == null) ? 0 : getNumberOfWorkers().hashCode());\n        hashCode = prime * hashCode + ((getWorkerType() == null) ? 0 : getWorkerType().hashCode());\n        hashCode = prime * hashCode + ((getSecurityConfiguration() == null) ? 0 : getSecurityConfiguration().hashCode());\n        hashCode = prime * hashCode + ((getGlueVersion() == null) ? 0 : getGlueVersion().hashCode());\n        hashCode = prime * hashCode + ((getTags() == null) ? 0 : getTags().hashCode());\n        hashCode = prime * hashCode + ((getRequestOrigin() == null) ? 0 : getRequestOrigin().hashCode());\n        return hashCode;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          931,
          951
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "getNumberOfWorkers",
        "signature": "Integer getNumberOfWorkers()",
        "lines_hint_csv": [
          539,
          540
        ],
        "code": "    public Integer getNumberOfWorkers() {\n        return this.numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          539,
          541
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "withNumberOfWorkers",
        "signature": "CreateSessionRequest withNumberOfWorkers(Integer)",
        "lines_hint_csv": [
          553,
          555
        ],
        "code": "    public CreateSessionRequest withNumberOfWorkers(Integer numberOfWorkers) {\n        setNumberOfWorkers(numberOfWorkers);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          553,
          556
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "withMaxCapacity",
        "signature": "CreateSessionRequest withMaxCapacity(Double)",
        "lines_hint_csv": [
          513,
          515
        ],
        "code": "    public CreateSessionRequest withMaxCapacity(Double maxCapacity) {\n        setMaxCapacity(maxCapacity);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          513,
          516
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/CreateSessionRequest.java",
        "class_name": "CreateSessionRequest",
        "method_name": "withSecurityConfiguration",
        "signature": "CreateSessionRequest withSecurityConfiguration(String)",
        "lines_hint_csv": [
          652,
          654
        ],
        "code": "    public CreateSessionRequest withSecurityConfiguration(String securityConfiguration) {\n        setSecurityConfiguration(securityConfiguration);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          652,
          655
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/Job.java",
        "class_name": "Job",
        "method_name": "getNumberOfWorkers",
        "signature": "Integer getNumberOfWorkers()",
        "lines_hint_csv": [
          1447,
          1448
        ],
        "code": "    public Integer getNumberOfWorkers() {\n        return this.numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1447,
          1449
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/Job.java",
        "class_name": "Job",
        "method_name": "withSecurityConfiguration",
        "signature": "Job withSecurityConfiguration(String)",
        "lines_hint_csv": [
          1506,
          1508
        ],
        "code": "    public Job withSecurityConfiguration(String securityConfiguration) {\n        setSecurityConfiguration(securityConfiguration);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1506,
          1509
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/Job.java",
        "class_name": "Job",
        "method_name": "setNumberOfWorkers",
        "signature": "void setNumberOfWorkers(Integer)",
        "lines_hint_csv": [
          1430,
          1431
        ],
        "code": "    public void setNumberOfWorkers(Integer numberOfWorkers) {\n        this.numberOfWorkers = numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1430,
          1432
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/Job.java",
        "class_name": "Job",
        "method_name": "withAllocatedCapacity",
        "signature": "Job withAllocatedCapacity(Integer)",
        "lines_hint_csv": [
          935,
          937
        ],
        "code": "    public Job withAllocatedCapacity(Integer allocatedCapacity) {\n        setAllocatedCapacity(allocatedCapacity);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          935,
          938
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobRun.java",
        "class_name": "JobRun",
        "method_name": "withSecurityConfiguration",
        "signature": "JobRun withSecurityConfiguration(String)",
        "lines_hint_csv": [
          1574,
          1576
        ],
        "code": "    public JobRun withSecurityConfiguration(String securityConfiguration) {\n        setSecurityConfiguration(securityConfiguration);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1574,
          1577
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobRun.java",
        "class_name": "JobRun",
        "method_name": "setNumberOfWorkers",
        "signature": "void setNumberOfWorkers(Integer)",
        "lines_hint_csv": [
          1498,
          1499
        ],
        "code": "    public void setNumberOfWorkers(Integer numberOfWorkers) {\n        this.numberOfWorkers = numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1498,
          1500
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobRun.java",
        "class_name": "JobRun",
        "method_name": "withMaxCapacity",
        "signature": "JobRun withMaxCapacity(Double)",
        "lines_hint_csv": [
          1260,
          1262
        ],
        "code": "    public JobRun withMaxCapacity(Double maxCapacity) {\n        setMaxCapacity(maxCapacity);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1260,
          1263
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobRun.java",
        "class_name": "JobRun",
        "method_name": "getNumberOfWorkers",
        "signature": "Integer getNumberOfWorkers()",
        "lines_hint_csv": [
          1515,
          1516
        ],
        "code": "    public Integer getNumberOfWorkers() {\n        return this.numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1515,
          1517
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobUpdate.java",
        "class_name": "JobUpdate",
        "method_name": "setNumberOfWorkers",
        "signature": "void setNumberOfWorkers(Integer)",
        "lines_hint_csv": [
          1281,
          1282
        ],
        "code": "    public void setNumberOfWorkers(Integer numberOfWorkers) {\n        this.numberOfWorkers = numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1281,
          1283
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobUpdate.java",
        "class_name": "JobUpdate",
        "method_name": "getNumberOfWorkers",
        "signature": "Integer getNumberOfWorkers()",
        "lines_hint_csv": [
          1298,
          1299
        ],
        "code": "    public Integer getNumberOfWorkers() {\n        return this.numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1298,
          1300
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobUpdate.java",
        "class_name": "JobUpdate",
        "method_name": "withSecurityConfiguration",
        "signature": "JobUpdate withSecurityConfiguration(String)",
        "lines_hint_csv": [
          1357,
          1359
        ],
        "code": "    public JobUpdate withSecurityConfiguration(String securityConfiguration) {\n        setSecurityConfiguration(securityConfiguration);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1357,
          1360
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/JobUpdate.java",
        "class_name": "JobUpdate",
        "method_name": "withAllocatedCapacity",
        "signature": "JobUpdate withAllocatedCapacity(Integer)",
        "lines_hint_csv": [
          786,
          788
        ],
        "code": "    public JobUpdate withAllocatedCapacity(Integer allocatedCapacity) {\n        setAllocatedCapacity(allocatedCapacity);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          786,
          789
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/ListSessionsResult.java",
        "class_name": "ListSessionsResult",
        "method_name": "setIds",
        "signature": "void setIds(java)",
        "lines_hint_csv": [
          66,
          72
        ],
        "code": "    public void setIds(java.util.Collection<String> ids) {\n        if (ids == null) {\n            this.ids = null;\n            return;\n        }\n\n        this.ids = new java.util.ArrayList<String>(ids);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          66,
          73
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/ListSessionsResult.java",
        "class_name": "ListSessionsResult",
        "method_name": "getIds",
        "signature": "java getIds()",
        "lines_hint_csv": [
          53,
          54
        ],
        "code": "    public java.util.List<String> getIds() {\n        return ids;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          53,
          55
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/ListStatementsRequest.java",
        "class_name": "ListStatementsRequest",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          158,
          168
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getSessionId() != null)\n            sb.append(\"SessionId: \").append(getSessionId()).append(\",\");\n        if (getRequestOrigin() != null)\n            sb.append(\"RequestOrigin: \").append(getRequestOrigin()).append(\",\");\n        if (getNextToken() != null)\n            sb.append(\"NextToken: \").append(getNextToken());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          158,
          169
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/ListStatementsResult.java",
        "class_name": "ListStatementsResult",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          140,
          148
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getStatements() != null)\n            sb.append(\"Statements: \").append(getStatements()).append(\",\");\n        if (getNextToken() != null)\n            sb.append(\"NextToken: \").append(getNextToken());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          140,
          149
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/Session.java",
        "class_name": "Session",
        "method_name": "setGlueVersion",
        "signature": "void setGlueVersion(String)",
        "lines_hint_csv": [
          655,
          656
        ],
        "code": "    public void setGlueVersion(String glueVersion) {\n        this.glueVersion = glueVersion;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          655,
          657
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/Session.java",
        "class_name": "Session",
        "method_name": "getGlueVersion",
        "signature": "String getGlueVersion()",
        "lines_hint_csv": [
          669,
          670
        ],
        "code": "    public String getGlueVersion() {\n        return this.glueVersion;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          669,
          671
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/SessionCommand.java",
        "class_name": "SessionCommand",
        "method_name": "getName",
        "signature": "String getName()",
        "lines_hint_csv": [
          65,
          66
        ],
        "code": "    public String getName() {\n        return this.name;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          65,
          67
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/SessionCommand.java",
        "class_name": "SessionCommand",
        "method_name": "setName",
        "signature": "void setName(String)",
        "lines_hint_csv": [
          53,
          54
        ],
        "code": "    public void setName(String name) {\n        this.name = name;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          53,
          55
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "getSecurityConfiguration",
        "signature": "String getSecurityConfiguration()",
        "lines_hint_csv": [
          715,
          716
        ],
        "code": "    public String getSecurityConfiguration() {\n        return this.securityConfiguration;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          715,
          717
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "toString",
        "signature": "String toString()",
        "lines_hint_csv": [
          1057,
          1081
        ],
        "code": "    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (getJobName() != null)\n            sb.append(\"JobName: \").append(getJobName()).append(\",\");\n        if (getJobRunId() != null)\n            sb.append(\"JobRunId: \").append(getJobRunId()).append(\",\");\n        if (getArguments() != null)\n            sb.append(\"Arguments: \").append(getArguments()).append(\",\");\n        if (getAllocatedCapacity() != null)\n            sb.append(\"AllocatedCapacity: \").append(getAllocatedCapacity()).append(\",\");\n        if (getTimeout() != null)\n            sb.append(\"Timeout: \").append(getTimeout()).append(\",\");\n        if (getMaxCapacity() != null)\n            sb.append(\"MaxCapacity: \").append(getMaxCapacity()).append(\",\");\n        if (getSecurityConfiguration() != null)\n            sb.append(\"SecurityConfiguration: \").append(getSecurityConfiguration()).append(\",\");\n        if (getNotificationProperty() != null)\n            sb.append(\"NotificationProperty: \").append(getNotificationProperty()).append(\",\");\n        if (getWorkerType() != null)\n            sb.append(\"WorkerType: \").append(getWorkerType()).append(\",\");\n        if (getNumberOfWorkers() != null)\n            sb.append(\"NumberOfWorkers: \").append(getNumberOfWorkers());\n        sb.append(\"}\");\n        return sb.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1057,
          1082
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "setMaxCapacity",
        "signature": "void setMaxCapacity(Double)",
        "lines_hint_csv": [
          573,
          574
        ],
        "code": "    public void setMaxCapacity(Double maxCapacity) {\n        this.maxCapacity = maxCapacity;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          573,
          575
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "getWorkerType",
        "signature": "String getWorkerType()",
        "lines_hint_csv": [
          877,
          878
        ],
        "code": "    public String getWorkerType() {\n        return this.workerType;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          877,
          879
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "equals",
        "signature": "boolean equals(Object)",
        "lines_hint_csv": [
          1085,
          1134
        ],
        "code": "    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof StartJobRunRequest == false)\n            return false;\n        StartJobRunRequest other = (StartJobRunRequest) obj;\n        if (other.getJobName() == null ^ this.getJobName() == null)\n            return false;\n        if (other.getJobName() != null && other.getJobName().equals(this.getJobName()) == false)\n            return false;\n        if (other.getJobRunId() == null ^ this.getJobRunId() == null)\n            return false;\n        if (other.getJobRunId() != null && other.getJobRunId().equals(this.getJobRunId()) == false)\n            return false;\n        if (other.getArguments() == null ^ this.getArguments() == null)\n            return false;\n        if (other.getArguments() != null && other.getArguments().equals(this.getArguments()) == false)\n            return false;\n        if (other.getAllocatedCapacity() == null ^ this.getAllocatedCapacity() == null)\n            return false;\n        if (other.getAllocatedCapacity() != null && other.getAllocatedCapacity().equals(this.getAllocatedCapacity()) == false)\n            return false;\n        if (other.getTimeout() == null ^ this.getTimeout() == null)\n            return false;\n        if (other.getTimeout() != null && other.getTimeout().equals(this.getTimeout()) == false)\n            return false;\n        if (other.getMaxCapacity() == null ^ this.getMaxCapacity() == null)\n            return false;\n        if (other.getMaxCapacity() != null && other.getMaxCapacity().equals(this.getMaxCapacity()) == false)\n            return false;\n        if (other.getSecurityConfiguration() == null ^ this.getSecurityConfiguration() == null)\n            return false;\n        if (other.getSecurityConfiguration() != null && other.getSecurityConfiguration().equals(this.getSecurityConfiguration()) == false)\n            return false;\n        if (other.getNotificationProperty() == null ^ this.getNotificationProperty() == null)\n            return false;\n        if (other.getNotificationProperty() != null && other.getNotificationProperty().equals(this.getNotificationProperty()) == false)\n            return false;\n        if (other.getWorkerType() == null ^ this.getWorkerType() == null)\n            return false;\n        if (other.getWorkerType() != null && other.getWorkerType().equals(this.getWorkerType()) == false)\n            return false;\n        if (other.getNumberOfWorkers() == null ^ this.getNumberOfWorkers() == null)\n            return false;\n        if (other.getNumberOfWorkers() != null && other.getNumberOfWorkers().equals(this.getNumberOfWorkers()) == false)\n            return false;\n        return true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1085,
          1135
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "getAllocatedCapacity",
        "signature": "Integer getAllocatedCapacity()",
        "lines_hint_csv": [
          437,
          438
        ],
        "code": "    public Integer getAllocatedCapacity() {\n        return this.allocatedCapacity;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          437,
          439
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "addArgumentsEntry",
        "signature": "StartJobRunRequest addArgumentsEntry(String,String)",
        "lines_hint_csv": [
          373,
          380
        ],
        "code": "    public StartJobRunRequest addArgumentsEntry(String key, String value) {\n        if (null == this.arguments) {\n            this.arguments = new java.util.HashMap<String, String>();\n        }\n        if (this.arguments.containsKey(key))\n            throw new IllegalArgumentException(\"Duplicated keys (\" + key.toString() + \") are provided.\");\n        this.arguments.put(key, value);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          373,
          381
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "withMaxCapacity",
        "signature": "StartJobRunRequest withMaxCapacity(Double)",
        "lines_hint_csv": [
          689,
          691
        ],
        "code": "    public StartJobRunRequest withMaxCapacity(Double maxCapacity) {\n        setMaxCapacity(maxCapacity);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          689,
          692
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "getArguments",
        "signature": "java getArguments()",
        "lines_hint_csv": [
          276,
          277
        ],
        "code": "    public java.util.Map<String, String> getArguments() {\n        return arguments;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          276,
          278
        ]
      },
      {
        "file_path": "aws-java-sdk-glue/src/main/java/com/amazonaws/services/glue/model/StartJobRunRequest.java",
        "class_name": "StartJobRunRequest",
        "method_name": "getNumberOfWorkers",
        "signature": "Integer getNumberOfWorkers()",
        "lines_hint_csv": [
          1024,
          1025
        ],
        "code": "    public Integer getNumberOfWorkers() {\n        return this.numberOfWorkers;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1024,
          1026
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AWSInspector2AsyncClient.java",
        "class_name": "AWSInspector2AsyncClient",
        "method_name": "getFindingsReportStatusAsync",
        "signature": "java getFindingsReportStatusAsync(GetFindingsReportStatusRequest)",
        "lines_hint_csv": [
          542,
          544
        ],
        "code": "    public java.util.concurrent.Future<GetFindingsReportStatusResult> getFindingsReportStatusAsync(GetFindingsReportStatusRequest request) {\n\n        return getFindingsReportStatusAsync(request, null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          542,
          545
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AWSInspector2Client.java",
        "class_name": "AWSInspector2Client",
        "method_name": "executeGetDelegatedAdminAccount",
        "signature": "GetDelegatedAdminAccountResult executeGetDelegatedAdminAccount(GetDelegatedAdminAccountRequest)",
        "lines_hint_csv": [
          1035,
          1070
        ],
        "code": "    final GetDelegatedAdminAccountResult executeGetDelegatedAdminAccount(GetDelegatedAdminAccountRequest getDelegatedAdminAccountRequest) {\n\n        ExecutionContext executionContext = createExecutionContext(getDelegatedAdminAccountRequest);\n        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();\n        awsRequestMetrics.startEvent(Field.ClientExecuteTime);\n        Request<GetDelegatedAdminAccountRequest> request = null;\n        Response<GetDelegatedAdminAccountResult> response = null;\n\n        try {\n            awsRequestMetrics.startEvent(Field.RequestMarshallTime);\n            try {\n                request = new GetDelegatedAdminAccountRequestProtocolMarshaller(protocolFactory).marshall(super\n                        .beforeMarshalling(getDelegatedAdminAccountRequest));\n                // Binds the request metrics to the current request.\n                request.setAWSRequestMetrics(awsRequestMetrics);\n                request.addHandlerContext(HandlerContextKey.CLIENT_ENDPOINT, endpoint);\n                request.addHandlerContext(HandlerContextKey.ENDPOINT_OVERRIDDEN, isEndpointOverridden());\n                request.addHandlerContext(HandlerContextKey.SIGNING_REGION, getSigningRegion());\n                request.addHandlerContext(HandlerContextKey.SERVICE_ID, \"Inspector2\");\n                request.addHandlerContext(HandlerContextKey.OPERATION_NAME, \"GetDelegatedAdminAccount\");\n                request.addHandlerContext(HandlerContextKey.ADVANCED_CONFIG, advancedConfig);\n\n            } finally {\n                awsRequestMetrics.endEvent(Field.RequestMarshallTime);\n            }\n\n            HttpResponseHandler<AmazonWebServiceResponse<GetDelegatedAdminAccountResult>> responseHandler = protocolFactory.createResponseHandler(\n                    new JsonOperationMetadata().withPayloadJson(true).withHasStreamingSuccessResponse(false),\n                    new GetDelegatedAdminAccountResultJsonUnmarshaller());\n            response = invoke(request, responseHandler, executionContext);\n\n            return response.getAwsResponse();\n\n        } finally {\n\n            endClientExecution(awsRequestMetrics, request, response);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1035,
          1072
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AWSInspector2Client.java",
        "class_name": "AWSInspector2Client",
        "method_name": "executeUpdateFilter",
        "signature": "UpdateFilterResult executeUpdateFilter(UpdateFilterRequest)",
        "lines_hint_csv": [
          1990,
          2023
        ],
        "code": "    final UpdateFilterResult executeUpdateFilter(UpdateFilterRequest updateFilterRequest) {\n\n        ExecutionContext executionContext = createExecutionContext(updateFilterRequest);\n        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();\n        awsRequestMetrics.startEvent(Field.ClientExecuteTime);\n        Request<UpdateFilterRequest> request = null;\n        Response<UpdateFilterResult> response = null;\n\n        try {\n            awsRequestMetrics.startEvent(Field.RequestMarshallTime);\n            try {\n                request = new UpdateFilterRequestProtocolMarshaller(protocolFactory).marshall(super.beforeMarshalling(updateFilterRequest));\n                // Binds the request metrics to the current request.\n                request.setAWSRequestMetrics(awsRequestMetrics);\n                request.addHandlerContext(HandlerContextKey.CLIENT_ENDPOINT, endpoint);\n                request.addHandlerContext(HandlerContextKey.ENDPOINT_OVERRIDDEN, isEndpointOverridden());\n                request.addHandlerContext(HandlerContextKey.SIGNING_REGION, getSigningRegion());\n                request.addHandlerContext(HandlerContextKey.SERVICE_ID, \"Inspector2\");\n                request.addHandlerContext(HandlerContextKey.OPERATION_NAME, \"UpdateFilter\");\n                request.addHandlerContext(HandlerContextKey.ADVANCED_CONFIG, advancedConfig);\n\n            } finally {\n                awsRequestMetrics.endEvent(Field.RequestMarshallTime);\n            }\n\n            HttpResponseHandler<AmazonWebServiceResponse<UpdateFilterResult>> responseHandler = protocolFactory.createResponseHandler(\n                    new JsonOperationMetadata().withPayloadJson(true).withHasStreamingSuccessResponse(false), new UpdateFilterResultJsonUnmarshaller());\n            response = invoke(request, responseHandler, executionContext);\n\n            return response.getAwsResponse();\n\n        } finally {\n\n            endClientExecution(awsRequestMetrics, request, response);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1990,
          2025
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AbstractAWSInspector2.java",
        "class_name": "AbstractAWSInspector2",
        "method_name": "shutdown",
        "signature": "void shutdown()",
        "lines_hint_csv": [
          181,
          182
        ],
        "code": "    public void shutdown() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          181,
          183
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AbstractAWSInspector2.java",
        "class_name": "AbstractAWSInspector2",
        "method_name": "enableDelegatedAdminAccount",
        "signature": "EnableDelegatedAdminAccountResult enableDelegatedAdminAccount(EnableDelegatedAdminAccountRequest)",
        "lines_hint_csv": [
          91,
          92
        ],
        "code": "    public EnableDelegatedAdminAccountResult enableDelegatedAdminAccount(EnableDelegatedAdminAccountRequest request) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          91,
          93
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AbstractAWSInspector2.java",
        "class_name": "AbstractAWSInspector2",
        "method_name": "getFindingsReportStatus",
        "signature": "GetFindingsReportStatusResult getFindingsReportStatus(GetFindingsReportStatusRequest)",
        "lines_hint_csv": [
          101,
          102
        ],
        "code": "    public GetFindingsReportStatusResult getFindingsReportStatus(GetFindingsReportStatusRequest request) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          101,
          103
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AbstractAWSInspector2.java",
        "class_name": "AbstractAWSInspector2",
        "method_name": "updateFilter",
        "signature": "UpdateFilterResult updateFilter(UpdateFilterRequest)",
        "lines_hint_csv": [
          171,
          172
        ],
        "code": "    public UpdateFilterResult updateFilter(UpdateFilterRequest request) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          171,
          173
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AbstractAWSInspector2Async.java",
        "class_name": "AbstractAWSInspector2Async",
        "method_name": "enableDelegatedAdminAccountAsync",
        "signature": "java enableDelegatedAdminAccountAsync(EnableDelegatedAdminAccountRequest,com)",
        "lines_hint_csv": [
          195,
          198
        ],
        "code": "    public java.util.concurrent.Future<EnableDelegatedAdminAccountResult> enableDelegatedAdminAccountAsync(EnableDelegatedAdminAccountRequest request,\n            com.amazonaws.handlers.AsyncHandler<EnableDelegatedAdminAccountRequest, EnableDelegatedAdminAccountResult> asyncHandler) {\n\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          195,
          199
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AbstractAWSInspector2Async.java",
        "class_name": "AbstractAWSInspector2Async",
        "method_name": "getFindingsReportStatusAsync",
        "signature": "java getFindingsReportStatusAsync(GetFindingsReportStatusRequest)",
        "lines_hint_csv": [
          215,
          217
        ],
        "code": "    public java.util.concurrent.Future<GetFindingsReportStatusResult> getFindingsReportStatusAsync(GetFindingsReportStatusRequest request) {\n\n        return getFindingsReportStatusAsync(request, null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          215,
          218
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/AbstractAWSInspector2Async.java",
        "class_name": "AbstractAWSInspector2Async",
        "method_name": "updateFilterAsync",
        "signature": "java updateFilterAsync(UpdateFilterRequest,com)",
        "lines_hint_csv": [
          403,
          406
        ],
        "code": "    public java.util.concurrent.Future<UpdateFilterResult> updateFilterAsync(UpdateFilterRequest request,\n            com.amazonaws.handlers.AsyncHandler<UpdateFilterRequest, UpdateFilterResult> asyncHandler) {\n\n        throw new java.lang.UnsupportedOperationException();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          403,
          407
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/CoverageFilterCriteria.java",
        "class_name": "CoverageFilterCriteria",
        "method_name": "setResourceType",
        "signature": "void setResourceType(java)",
        "lines_hint_csv": [
          457,
          463
        ],
        "code": "    public void setResourceType(java.util.Collection<CoverageStringFilter> resourceType) {\n        if (resourceType == null) {\n            this.resourceType = null;\n            return;\n        }\n\n        this.resourceType = new java.util.ArrayList<CoverageStringFilter>(resourceType);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          457,
          464
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/CoverageFilterCriteria.java",
        "class_name": "CoverageFilterCriteria",
        "method_name": "withResourceType",
        "signature": "CoverageFilterCriteria withResourceType(CoverageStringFilter)",
        "lines_hint_csv": [
          481,
          488
        ],
        "code": "    public CoverageFilterCriteria withResourceType(CoverageStringFilter... resourceType) {\n        if (this.resourceType == null) {\n            setResourceType(new java.util.ArrayList<CoverageStringFilter>(resourceType.length));\n        }\n        for (CoverageStringFilter ele : resourceType) {\n            this.resourceType.add(ele);\n        }\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          481,
          489
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/CreateFilterRequest.java",
        "class_name": "CreateFilterRequest",
        "method_name": "hashCode",
        "signature": "int hashCode()",
        "lines_hint_csv": [
          373,
          382
        ],
        "code": "    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n\n        hashCode = prime * hashCode + ((getAction() == null) ? 0 : getAction().hashCode());\n        hashCode = prime * hashCode + ((getDescription() == null) ? 0 : getDescription().hashCode());\n        hashCode = prime * hashCode + ((getFilterCriteria() == null) ? 0 : getFilterCriteria().hashCode());\n        hashCode = prime * hashCode + ((getName() == null) ? 0 : getName().hashCode());\n        hashCode = prime * hashCode + ((getTags() == null) ? 0 : getTags().hashCode());\n        return hashCode;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          373,
          383
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/CreateFilterRequest.java",
        "class_name": "CreateFilterRequest",
        "method_name": "addTagsEntry",
        "signature": "CreateFilterRequest addTagsEntry(String,String)",
        "lines_hint_csv": [
          292,
          299
        ],
        "code": "    public CreateFilterRequest addTagsEntry(String key, String value) {\n        if (null == this.tags) {\n            this.tags = new java.util.HashMap<String, String>();\n        }\n        if (this.tags.containsKey(key))\n            throw new IllegalArgumentException(\"Duplicated keys (\" + key.toString() + \") are provided.\");\n        this.tags.put(key, value);\n        return this;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          292,
          300
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/UpdateFilterRequest.java",
        "class_name": "UpdateFilterRequest",
        "method_name": "equals",
        "signature": "boolean equals(Object)",
        "lines_hint_csv": [
          305,
          334
        ],
        "code": "    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n\n        if (obj instanceof UpdateFilterRequest == false)\n            return false;\n        UpdateFilterRequest other = (UpdateFilterRequest) obj;\n        if (other.getAction() == null ^ this.getAction() == null)\n            return false;\n        if (other.getAction() != null && other.getAction().equals(this.getAction()) == false)\n            return false;\n        if (other.getDescription() == null ^ this.getDescription() == null)\n            return false;\n        if (other.getDescription() != null && other.getDescription().equals(this.getDescription()) == false)\n            return false;\n        if (other.getFilterArn() == null ^ this.getFilterArn() == null)\n            return false;\n        if (other.getFilterArn() != null && other.getFilterArn().equals(this.getFilterArn()) == false)\n            return false;\n        if (other.getFilterCriteria() == null ^ this.getFilterCriteria() == null)\n            return false;\n        if (other.getFilterCriteria() != null && other.getFilterCriteria().equals(this.getFilterCriteria()) == false)\n            return false;\n        if (other.getName() == null ^ this.getName() == null)\n            return false;\n        if (other.getName() != null && other.getName().equals(this.getName()) == false)\n            return false;\n        return true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          305,
          335
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/UpdateFilterRequest.java",
        "class_name": "UpdateFilterRequest",
        "method_name": "hashCode",
        "signature": "int hashCode()",
        "lines_hint_csv": [
          338,
          347
        ],
        "code": "    public int hashCode() {\n        final int prime = 31;\n        int hashCode = 1;\n\n        hashCode = prime * hashCode + ((getAction() == null) ? 0 : getAction().hashCode());\n        hashCode = prime * hashCode + ((getDescription() == null) ? 0 : getDescription().hashCode());\n        hashCode = prime * hashCode + ((getFilterArn() == null) ? 0 : getFilterArn().hashCode());\n        hashCode = prime * hashCode + ((getFilterCriteria() == null) ? 0 : getFilterCriteria().hashCode());\n        hashCode = prime * hashCode + ((getName() == null) ? 0 : getName().hashCode());\n        return hashCode;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          338,
          348
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/transform/CreateFilterRequestMarshaller.java",
        "class_name": "CreateFilterRequestMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(CreateFilterRequest,ProtocolMarshaller)",
        "lines_hint_csv": [
          52,
          65
        ],
        "code": "    public void marshall(CreateFilterRequest createFilterRequest, ProtocolMarshaller protocolMarshaller) {\n\n        if (createFilterRequest == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(createFilterRequest.getAction(), ACTION_BINDING);\n            protocolMarshaller.marshall(createFilterRequest.getDescription(), DESCRIPTION_BINDING);\n            protocolMarshaller.marshall(createFilterRequest.getFilterCriteria(), FILTERCRITERIA_BINDING);\n            protocolMarshaller.marshall(createFilterRequest.getName(), NAME_BINDING);\n            protocolMarshaller.marshall(createFilterRequest.getTags(), TAGS_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          52,
          67
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/transform/UpdateFilterRequestMarshaller.java",
        "class_name": "UpdateFilterRequestMarshaller",
        "method_name": "getInstance",
        "signature": "UpdateFilterRequestMarshaller getInstance()",
        "lines_hint_csv": [
          43,
          44
        ],
        "code": "    public static UpdateFilterRequestMarshaller getInstance() {\n        return instance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          43,
          45
        ]
      },
      {
        "file_path": "aws-java-sdk-inspector2/src/main/java/com/amazonaws/services/inspector2/model/transform/UpdateFilterRequestMarshaller.java",
        "class_name": "UpdateFilterRequestMarshaller",
        "method_name": "marshall",
        "signature": "void marshall(UpdateFilterRequest,ProtocolMarshaller)",
        "lines_hint_csv": [
          50,
          63
        ],
        "code": "    public void marshall(UpdateFilterRequest updateFilterRequest, ProtocolMarshaller protocolMarshaller) {\n\n        if (updateFilterRequest == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(updateFilterRequest.getAction(), ACTION_BINDING);\n            protocolMarshaller.marshall(updateFilterRequest.getDescription(), DESCRIPTION_BINDING);\n            protocolMarshaller.marshall(updateFilterRequest.getFilterArn(), FILTERARN_BINDING);\n            protocolMarshaller.marshall(updateFilterRequest.getFilterCriteria(), FILTERCRITERIA_BINDING);\n            protocolMarshaller.marshall(updateFilterRequest.getName(), NAME_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          50,
          65
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-36007",
    "project_slug": "jlangch__venice_CVE-2022-36007_1.10.16",
    "buggy_commit_id": "9306c93686100a6bc52ad0c8cb617ed199b5f75c",
    "github_url": "https://github.com/jlangch/venice",
    "nvd_metadata": {
      "description": "Venice is a Clojure inspired sandboxed Lisp dialect with excellent Java interoperability. A partial path traversal issue exists within the functions `load-file` and `load-resource`. These functions can be limited to load files from a list of load paths. Assuming Venice has been configured with the load paths: `[ \"/Users/foo/resources\" ]` When passing **relative** paths to these two vulnerable functions everything is fine: `(load-resource \"test.png\")` => loads the file \"/Users/foo/resources/test.png\" `(load-resource \"../resources-alt/test.png\")` => rejected, outside the load path When passing **absolute** paths to these two vulnerable functions Venice may return files outside the configured load paths: `(load-resource \"/Users/foo/resources/test.png\")` => loads the file \"/Users/foo/resources/test.png\" `(load-resource \"/Users/foo/resources-alt/test.png\")` => loads the file \"/Users/foo/resources-alt/test.png\" !!! The latter call suffers from the _Partial Path Traversal_ vulnerability. This issues scope is limited to absolute paths whose name prefix matches a load path. E.g. for a load-path `\"/Users/foo/resources\"`, the actor can cause loading a resource also from `\"/Users/foo/resources-alt\"`, but not from `\"/Users/foo/images\"`. Versions of Venice before and including v1.10.17 are affected by this issue. Upgrade to Venice >= 1.10.18, if you are on a version < 1.10.18. There are currently no known workarounds.",
      "published_date": "2022-08-15T11:21:40.967",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/com/github/jlangch/venice/impl/util/io/LoadPaths.java",
        "class_name": "LoadPaths",
        "method_name": "isFileWithinDirectory",
        "signature": "boolean isFileWithinDirectory(File,File)",
        "lines_hint_csv": [
          253,
          269
        ],
        "code": "    private boolean isFileWithinDirectory(\n            final File dir,\n            final File file\n    ) throws IOException {\n        final File dir_ = dir.getAbsoluteFile();\n        if (dir_.isDirectory()) {\n            final File fl = new File(dir_, file.getPath());\n            if (fl.isFile()) {\n                if (fl.getCanonicalPath().startsWith(dir_.getCanonicalPath())) {\n                    // Prevent accessing files outside the load-path.\n                    // E.g.: ../../coffee\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          253,
          270
        ]
      },
      {
        "file_path": "src/main/java/com/github/jlangch/venice/impl/util/io/LoadPaths.java",
        "class_name": "LoadPaths",
        "method_name": "isFileWithinDirectory",
        "signature": "boolean isFileWithinDirectory(File,File)",
        "lines_hint_csv": [
          253,
          269
        ],
        "code": "    private boolean isFileWithinDirectory(\n            final File dir,\n            final File file\n    ) throws IOException {\n        final File dir_ = dir.getAbsoluteFile();\n        if (dir_.isDirectory()) {\n            final File fl = new File(dir_, file.getPath());\n            if (fl.isFile()) {\n                if (fl.getCanonicalPath().startsWith(dir_.getCanonicalPath())) {\n                    // Prevent accessing files outside the load-path.\n                    // E.g.: ../../coffee\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          253,
          270
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-31195",
    "project_slug": "DSpace__DSpace_CVE-2022-31195_5.10",
    "buggy_commit_id": "eca7968be7d6b9f8f5f302c9fc09f8186ed4809e",
    "github_url": "https://github.com/DSpace/DSpace",
    "nvd_metadata": {
      "description": "DSpace open source software is a repository application which provides durable access to digital resources. In affected versions the ItemImportServiceImpl is vulnerable to a path traversal vulnerability. This means a malicious SAF (simple archive format) package could cause a file/directory to be created anywhere the Tomcat/DSpace user can write to on the server. However, this path traversal vulnerability is only possible by a user with special privileges (either Administrators or someone with command-line access to the server). This vulnerability impacts the XMLUI, JSPUI and command-line. Users are advised to upgrade. As a basic workaround, users may block all access to the following URL paths: If you are using the XMLUI, block all access to /admin/batchimport path (this is the URL of the Admin Batch Import tool). Keep in mind, if your site uses the path \"/xmlui\", then you'd need to block access to /xmlui/admin/batchimport. If you are using the JSPUI, block all access to /dspace-admin/batchimport path (this is the URL of the Admin Batch Import tool). Keep in mind, if your site uses the path \"/jspui\", then you'd need to block access to /jspui/dspace-admin/batchimport. Keep in mind, only an Administrative user or a user with command-line access to the server is able to import/upload SAF packages. Therefore, assuming those users do not blindly upload untrusted SAF packages, then it is unlikely your site could be impacted by this vulnerability.",
      "published_date": "2022-08-01T21:15:13.557",
      "cvss_v3_score": 7.2,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "dspace-api/src/main/java/org/dspace/app/itemimport/ItemImport.java",
        "class_name": "ItemImport",
        "method_name": "unzip",
        "signature": "String unzip(File,String)",
        "lines_hint_csv": [
          1994,
          2097
        ],
        "code": "    public static String unzip(File zipfile, String destDir) throws IOException {\n        // 2\n        // does the zip file exist and can we write to the temp directory\n        if (!zipfile.canRead())\n        {\n            log.error(\"Zip file '\" + zipfile.getAbsolutePath() + \"' does not exist, or is not readable.\");\n        }\n\n        String destinationDir = destDir;\n        if (destinationDir == null){\n        \tdestinationDir = tempWorkDir;\n        }\n\n        File tempdir = new File(destinationDir);\n        if (!tempdir.isDirectory())\n        {\n            log.error(\"'\" + ConfigurationManager.getProperty(\"org.dspace.app.itemexport.work.dir\") +\n                    \"' as defined by the key 'org.dspace.app.itemexport.work.dir' in dspace.cfg \" +\n                    \"is not a valid directory\");\n        }\n\n        if (!tempdir.exists() && !tempdir.mkdirs())\n        {\n            log.error(\"Unable to create temporary directory: \" + tempdir.getAbsolutePath());\n        }\n        String sourcedir = destinationDir + System.getProperty(\"file.separator\") + zipfile.getName();\n        String zipDir = destinationDir + System.getProperty(\"file.separator\") + zipfile.getName() + System.getProperty(\"file.separator\");\n\n\n        // 3\n        String sourceDirForZip = sourcedir;\n        ZipFile zf = new ZipFile(zipfile);\n        ZipEntry entry;\n        Enumeration<? extends ZipEntry> entries = zf.entries();\n        while (entries.hasMoreElements())\n        {\n            entry = entries.nextElement();\n            if (entry.isDirectory())\n            {\n                if (!new File(zipDir + entry.getName()).mkdir())\n                {\n                    log.error(\"Unable to create contents directory: \" + zipDir + entry.getName());\n                }\n            }\n            else\n            {\n                System.out.println(\"Extracting file: \" + entry.getName());\n                log.info(\"Extracting file: \" + entry.getName());\n\n                int index = entry.getName().lastIndexOf('/');\n                if (index == -1)\n                {\n                    // Was it created on Windows instead?\n                    index = entry.getName().lastIndexOf('\\\\');\n                }\n                if (index > 0)\n                {\n                    File dir = new File(zipDir + entry.getName().substring(0, index));\n                    if (!dir.exists() && !dir.mkdirs())\n                    {\n                        log.error(\"Unable to create directory: \" + dir.getAbsolutePath());\n                    }\n\n                    //Entries could have too many directories, and we need to adjust the sourcedir\n                    // file1.zip (SimpleArchiveFormat / item1 / contents|dublin_core|...\n                    //            SimpleArchiveFormat / item2 / contents|dublin_core|...\n                    // or\n                    // file2.zip (item1 / contents|dublin_core|...\n                    //            item2 / contents|dublin_core|...\n\n                    //regex supports either windows or *nix file paths\n                    String[] entryChunks = entry.getName().split(\"/|\\\\\\\\\");\n                    if(entryChunks.length > 2) {\n                        if(sourceDirForZip == sourcedir) {\n                            sourceDirForZip = sourcedir + \"/\" + entryChunks[0];\n                        }\n                    }\n\n\n                }\n                byte[] buffer = new byte[1024];\n                int len;\n                InputStream in = zf.getInputStream(entry);\n                BufferedOutputStream out = new BufferedOutputStream(\n                        new FileOutputStream(zipDir + entry.getName()));\n                while((len = in.read(buffer)) >= 0)\n                {\n                    out.write(buffer, 0, len);\n                }\n                in.close();\n                out.close();\n            }\n        }\n\n        //Close zip file\n        zf.close();\n        \n        if(sourceDirForZip != sourcedir) {\n            sourcedir = sourceDirForZip;\n            System.out.println(\"Set sourceDir using path inside of Zip: \" + sourcedir);\n            log.info(\"Set sourceDir using path inside of Zip: \" + sourcedir);\n        }\n\n        return sourcedir;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1994,
          2098
        ]
      },
      {
        "file_path": "dspace-api/src/main/java/org/dspace/app/itemimport/ItemImportServiceImpl.java",
        "class_name": "ItemImportServiceImpl",
        "method_name": "unzip",
        "signature": "String unzip(File,String)",
        "lines_hint_csv": [
          1626,
          1729
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2022-37422",
    "project_slug": "payara__Payara_CVE-2022-37422_5.2022.2",
    "buggy_commit_id": "7680990e55c04d628f16a591f950a2b3a4dcb401",
    "github_url": "https://github.com/payara/Payara",
    "nvd_metadata": {
      "description": "Payara through 5.2022.2 allows directory traversal without authentication. This affects Payara Server, Payara Micro, and Payara Server Embedded.",
      "published_date": "2022-08-18T19:15:14.663",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "appserver/web/web-core/src/main/java/org/apache/catalina/connector/CoyoteAdapter.java",
        "class_name": "CoyoteAdapter",
        "method_name": "normalize",
        "signature": "boolean normalize(MessageBytes)",
        "lines_hint_csv": [
          665,
          671
        ],
        "code": "    public static boolean normalize(MessageBytes uriMB) {\n\n        int type = uriMB.getType();\n        if (type == MessageBytes.T_CHARS) {\n            return normalizeChars(uriMB);\n        } else {\n            return normalizeBytes(uriMB);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          647,
          655
        ]
      },
      {
        "file_path": "appserver/web/web-core/src/main/java/org/apache/catalina/connector/CoyoteAdapter.java",
        "class_name": "CoyoteAdapter",
        "method_name": "postParseRequest",
        "signature": "boolean postParseRequest(org,Request,org,Response,boolean)",
        "lines_hint_csv": [
          412,
          652
        ],
        "code": "    protected boolean postParseRequest(final org.glassfish.grizzly.http.server.Request req,\n                                       final Request request,\n                                       final org.glassfish.grizzly.http.server.Response res,\n                                       final Response response,\n                                       final boolean v3Enabled)\n        throws Exception {\n        // XXX the processor may have set a correct scheme and port prior to this point, \n        // in ajp13 protocols dont make sense to get the port from the connector...\n        // otherwise, use connector configuration\n        request.setSecure(req.isSecure());\n\n        // URI decoding\n        DataChunk decodedURI;\n        try {\n            decodedURI = req.getRequest().getRequestURIRef().getDecodedRequestURIBC();\n        } catch (CharConversionException cce) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URI\");\n            return false;\n        }\n        \n        if (compatWithTomcat || !v3Enabled) {\n//            decodedURI.duplicate(req.requestURI());\n//            try {\n//              req.getURLDecoder().convert(decodedURI, false);\n//            } catch (IOException ioe) {\n//              res.setStatus(400);\n//              res.setMessage(\"Invalid URI: \" + ioe.getMessage());\n//              return false;\n//            }\n\n            /* GlassFish Issue 2339\n            // Normalize decoded URI\n            if (!normalize(req.decodedURI())) {\n                res.setStatus(400);\n                res.setMessage(\"Invalid URI\");\n                return false;\n            }\n            */\n\n            // Set the remote principal\n            String principal = req.getRemoteUser();\n            if (principal != null) {\n                request.setUserPrincipal(new CoyotePrincipal(principal));\n            }\n\n            // Set the authorization type\n            String authtype = req.getAuthType();\n            if (authtype != null) {\n                request.setAuthType(authtype);\n            }\n\n            /* CR 6309511\n            // URI character decoding\n            convertURI(decodedURI, request);\n\n            // Parse session Id\n            parseSessionId(req, request);\n             */\n            // START CR 6309511\n//             URI character decoding\n//            request.convertURI(decodedURI);\n\n            // START GlassFish Issue 2339\n            // Normalize decoded URI\n//            if (!normalize(decodedURI)) {\n//                res.setStatus(400);\n//                res.setMessage(\"Invalid URI\");\n//                return false;\n//            }\n            // END GlassFish Issue 2339\n        }\n        // END CR 6309511\n\n        /*\n         * Remove any parameters from the URI, so they won't be considered\n         * by the mapping algorithm, and save them in a temporary CharChunk,\n         * so that any session id param may be parsed once the target\n         * context, which may use a custom session parameter name, has been\n         * identified\n         */\n        final CharChunk uriParamsCC = request.getURIParams();\n        final CharChunk uriCC = decodedURI.getCharChunk();\n        final int semicolon = uriCC.indexOf(';');\n        if (semicolon > 0) {\n            final int absSemicolon = uriCC.getStart() + semicolon;\n            uriParamsCC.setChars(uriCC.getBuffer(), absSemicolon,\n                uriCC.getEnd() - absSemicolon);\n            decodedURI.setChars(uriCC.getBuffer(), uriCC.getStart(),\n                absSemicolon - uriCC.getStart());\n        }\n \n        if (compatWithTomcat || !v3Enabled) {\n            /*mod_jk*/\n            DataChunk localDecodedURI = decodedURI;\n            if (semicolon > 0) {\n                localDecodedURI = req.getNote(DATA_CHUNK);\n                if (localDecodedURI == null) {\n                    localDecodedURI = DataChunk.newInstance();\n                    req.setNote(DATA_CHUNK, localDecodedURI);\n                }\n                localDecodedURI.duplicate(decodedURI);\n            }\n            connector.getMapper().map(req.getRequest().serverName(), localDecodedURI,\n                                  request.getMappingData());\n            MappingData md = request.getMappingData();\n            req.setNote(MAPPING_DATA, md);\n            request.updatePaths(md);\n        }\n\n        // FIXME: the code below doesnt belongs to here,\n        // this is only have sense\n        // in Http11, not in ajp13..\n        // At this point the Host header has been processed.\n        // Override if the proxyPort/proxyHost are set\n        String proxyName = connector.getProxyName();\n        int proxyPort = connector.getProxyPort();\n        if (proxyPort != 0) {\n            req.setServerPort(proxyPort);\n        }\n        if (proxyName != null) {\n            req.setServerName(proxyName);\n        }\n\n        Context ctx = (Context) request.getMappingData().context;\n\n        // Parse session id\n        if (ctx != null) {\n            if (req.isRequestedSessionIdFromURL() &&\n                    Globals.SESSION_PARAMETER_NAME.equals(ctx.getSessionParameterName())) {\n                request.obtainSessionId();\n            } else if (!uriParamsCC.isNull()) {\n//            String sessionParam = \";\" + ctx.getSessionParameterName() + \"=\";\n                request.parseSessionId(ctx.getSessionParameterName(), uriParamsCC);\n            }\n        }\n\n        // START GlassFish 1024\n        request.setDefaultContext(request.getMappingData().isDefaultContext);\n        // END GlassFish 1024\n\n        // START SJSAS 6253524\n        // request.setContext((Context) request.getMappingData().context);\n        // END SJSAS 6253524\n        // START SJSAS 6253524\n        request.setContext(ctx);\n        // END SJSAS 6253524\n\n        if (ctx != null && !uriParamsCC.isNull()) {\n            request.parseSessionVersion(uriParamsCC);\n        }\n\n        if (!uriParamsCC.isNull()) {\n            request.parseJReplica(uriParamsCC);\n        }\n\n        request.setWrapper((Wrapper) request.getMappingData().wrapper);\n\n        // Filter trace method\n        if (!connector.getAllowTrace() && Method.TRACE.equals(req.getMethod())) {\n            Wrapper wrapper = request.getWrapper();\n            String header = null;\n            if (wrapper != null) {\n                String[] methods = wrapper.getServletMethods();\n                if (methods != null) {\n                    for (String method : methods) {\n                        // Exclude TRACE from methods returned in Allow header\n                        if (\"TRACE\".equals(method)) {\n                            continue;\n                        }\n                        if (header == null) {\n                            header = method;\n                        } else {\n                            header += \", \" + method;\n                        }\n                    }\n                }\n            }                               \n            res.setStatus(405, \"TRACE method is not allowed\");\n            res.addHeader(\"Allow\", header);\n            return false;\n        }\n\n        // Possible redirect\n        DataChunk redirectPathMB = request.getMappingData().redirectPath;\n        // START SJSAS 6253524\n        // if (!redirectPathMB.isNull()) {\n        // END SJSAS 6253524\n        // START SJSAS 6253524\n        if (!redirectPathMB.isNull()\n            && (!ctx.hasAdHocPaths()\n                || (ctx.getAdHocServletName(((HttpServletRequest)\n                        request.getRequest()).getServletPath()) == null))) {\n        // END SJSAS 6253524\n            String redirectPath = redirectPathMB.toString();\n            String query = request.getQueryString();\n            if (request.isRequestedSessionIdFromURL()) {\n                // This is not optimal, but as this is not very common, it\n                // shouldn't matter\n                redirectPath = redirectPath + \";\" + ctx.getSessionParameterName() + \"=\" \n                    + request.getRequestedSessionId();\n            }            \n            // START GlassFish 936\n            redirectPath = response.encode(redirectPath);\n            // END GlassFish 936\n            if (query != null) {\n                // This is not optimal, but as this is not very common, it\n                // shouldn't matter\n                redirectPath = redirectPath + \"?\" + query;\n            }\n\n            // START CR 6590921\n            boolean authPassthroughEnabled = \n                connector.getAuthPassthroughEnabled();\n            ProxyHandler proxyHandler = connector.getProxyHandler();\n            if (authPassthroughEnabled && proxyHandler != null) {\n\n                if (proxyHandler.getSSLKeysize(\n                        (HttpServletRequest)request.getRequest()) > 0) {\n                    request.setSecure(true);\n                }\n            }\n            // END CR 6590921\n            // Issue a permanent redirect\n            response.sendRedirect(redirectPath, false);\n\n            return false;\n        }\n\n        // Parse session Id\n        /* CR 6309511\n        parseSessionCookiesId(req, request);\n         */\n        // START CR 6309511\n        request.parseSessionCookiesId();\n        // END CR 6309511\n\n        // START SJSAS 6346226\n        request.parseJrouteCookie();\n        // END SJSAS 6346226\n\n        return true;\n    }\n\n\n    /**\n     * Normalize URI.\n     * <p>\n     * This method normalizes \"\\\", \"//\", \"/./\" and \"/../\". This method will\n     * return false when trying to go above the root, or if the URI contains\n     * a null byte.\n     * \n     * @param uriMB URI to be normalized\n     */\n    public static boolean normalize(MessageBytes uriMB) {\n\n        int type = uriMB.getType();\n        if (type == MessageBytes.T_CHARS) {\n            return normalizeChars(uriMB);\n        } else {\n            return normalizeBytes(uriMB);\n        }\n    }\n\n\n    private static boolean normalizeBytes(MessageBytes uriMB) {\n\n        ByteChunk uriBC = uriMB.getByteChunk();\n        byte[] b = uriBC.getBytes();\n        int start = uriBC.getStart();\n        int end = uriBC.getEnd();\n\n        // An empty URL is not acceptable\n        if (start == end)\n            return false;\n\n        // URL * is acceptable\n        if ((end - start == 1) && b[start] == (byte) '*')\n          return true;\n\n        int pos = 0;\n        int index = 0;\n\n        // Replace '\\' with '/'\n        // Check for null byte\n        for (pos = start; pos < end; pos++) {\n            if (b[pos] == (byte) '\\\\') {\n                if (ALLOW_BACKSLASH) {\n                    b[pos] = (byte) '/';\n                } else {\n                    return false;\n                }\n            }\n            if (b[pos] == (byte) 0) {\n                return false;\n            }\n        }\n\n        // The URL must start with '/'\n        if (b[start] != (byte) '/') {\n            return false;\n        }\n\n        // Replace \"//\" with \"/\"\n        if (COLLAPSE_ADJACENT_SLASHES) {\n            for (pos = start; pos < (end - 1); pos++) {\n                if (b[pos] == (byte) '/') {\n                    while ((pos + 1 < end) && (b[pos + 1] == (byte) '/')) {\n                        copyBytes(b, pos, pos + 1, end - pos - 1);\n                        end--;\n                    }\n                }\n            }\n        }\n\n        // If the URI ends with \"/.\" or \"/..\", then we append an extra \"/\"\n        // Note: It is possible to extend the URI by 1 without any side effect\n        // as the next character is a non-significant WS.\n        if (((end - start) > 2) && (b[end - 1] == (byte) '.')) {\n            if ((b[end - 2] == (byte) '/') \n                || ((b[end - 2] == (byte) '.') \n                    && (b[end - 3] == (byte) '/'))) {\n                b[end] = (byte) '/';\n                end++;\n            }\n        }\n\n        uriBC.setEnd(end);\n\n        index = 0;\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/./\", 0, 3, index);\n            if (index < 0)\n                break;\n            copyBytes(b, start + index, start + index + 2, \n                      end - start - index - 2);\n            end = end - 2;\n            uriBC.setEnd(end);\n        }\n\n        index = 0;\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/../\", 0, 4, index);\n            if (index < 0)\n                break;\n            // Prevent from going outside our context\n            if (index == 0)\n                return false;\n            int index2 = -1;\n            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {\n                if (b[pos] == (byte) '/') {\n                    index2 = pos;\n                }\n            }\n            copyBytes(b, start + index2, start + index + 3,\n                      end - start - index - 3);\n            end = end + index2 - index - 3;\n            uriBC.setEnd(end);\n            index = index2;\n        }\n\n        uriBC.setBytes(b, start, end);\n\n        return true;\n\n    }\n\n\n    private static boolean normalizeChars(MessageBytes uriMB) {\n\n        CharChunk uriCC = uriMB.getCharChunk();\n        char[] c = uriCC.getChars();\n        int start = uriCC.getStart();\n        int end = uriCC.getEnd();\n\n        // URL * is acceptable\n        if ((end - start == 1) && c[start] == (char) '*')\n          return true;\n\n        int pos = 0;\n        int index = 0;\n\n        // Replace '\\' with '/'\n        // Check for null char\n        for (pos = start; pos < end; pos++) {\n            if (c[pos] == (char) '\\\\') {\n                if (ALLOW_BACKSLASH) {\n                    c[pos] = (char) '/';\n                } else {\n                    return false;\n                }\n            }\n            if (c[pos] == (char) 0) {\n                return false;\n            }\n        }\n\n        // The URL must start with '/'\n        if (c[start] != (char) '/') {\n            return false;\n        }\n\n        // Replace \"//\" with \"/\"\n        if (COLLAPSE_ADJACENT_SLASHES) {\n            for (pos = start; pos < (end - 1); pos++) {\n                if (c[pos] == (char) '/') {\n                    while ((pos + 1 < end) && (c[pos + 1] == (char) '/')) {\n                        copyChars(c, pos, pos + 1, end - pos - 1);\n                        end--;\n                    }\n                }\n            }\n        }\t\n\n        // If the URI ends with \"/.\" or \"/..\", then we append an extra \"/\"\n        // Note: It is possible to extend the URI by 1 without any side effect\n        // as the next character is a non-significant WS.\n        if (((end - start) > 2) && (c[end - 1] == (char) '.')) {\n            if ((c[end - 2] == (char) '/') \n                || ((c[end - 2] == (char) '.') \n                    && (c[end - 3] == (char) '/'))) {\n                c[end] = (char) '/';\n                end++;\n            }\n        }\n\n        uriCC.setEnd(end);\n\n        index = 0;\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            index = uriCC.indexOf(\"/./\", 0, 3, index);\n            if (index < 0)\n                break;\n            copyChars(c, start + index, start + index + 2, \n                      end - start - index - 2);\n            end = end - 2;\n            uriCC.setEnd(end);\n        }\n\n        index = 0;\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            index = uriCC.indexOf(\"/../\", 0, 4, index);\n            if (index < 0)\n                break;\n            // Prevent from going outside our context\n            if (index == 0)\n                return false;\n            int index2 = -1;\n            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {\n                if (c[pos] == (char) '/') {\n                    index2 = pos;\n                }\n            }\n            copyChars(c, start + index2, start + index + 3,\n                      end - start - index - 3);\n            end = end + index2 - index - 3;\n            uriCC.setEnd(end);\n            index = index2;\n        }\n\n        uriCC.setChars(c, start, end);\n\n        return true;\n\n    }\n\n\n    // ------------------------------------------------------ Protected Methods\n\n\n    /**\n     * Copy an array of bytes to a different position. Used during \n     * normalization.\n     */\n    protected static void copyBytes(byte[] b, int dest, int src, int len) {\n        for (int pos = 0; pos < len; pos++) {\n            b[pos + dest] = b[pos + src];\n        }\n    }\n\n\n    /**\n     * Copy an array of chars to a different position. Used during \n     * normalization.\n     */\n    private static void copyChars(char[] c, int dest, int src, int len) {\n        for (int pos = 0; pos < len; pos++) {\n            c[pos + dest] = c[pos + src];\n        }\n    }\n\n\n    /**\n     * Log a message on the Logger associated with our Container (if any)\n     *\n     * @param message Message to be logged\n     */\n    protected void log(String message) {\n        log.log(Level.INFO, message);\n    }\n\n\n    /**\n     * Log a message on the Logger associated with our Container (if any)\n     *\n     * @param message Message to be logged\n     * @param throwable Associated exception\n     */\n    protected void log(String message, Throwable throwable) {\n        log.log(Level.SEVERE, message, throwable);\n    }\n\n\n     /**\n      * Character conversion of the a US-ASCII MessageBytes.\n      */\n    /* CR 6309511\n     protected void convertMB(MessageBytes mb) {\n \n        // This is of course only meaningful for bytes\n        if (mb.getType() != MessageBytes.T_BYTES)\n            return;\n        \n        ByteChunk bc = mb.getByteChunk();\n        CharChunk cc = mb.getCharChunk();\n        cc.allocate(bc.getLength(), -1);\n\n        // Default encoding: fast conversion\n        byte[] bbuf = bc.getBuffer();\n        char[] cbuf = cc.getBuffer();\n        int start = bc.getStart();\n        for (int i = 0; i < bc.getLength(); i++) {\n            cbuf[i] = (char) (bbuf[i + start] & 0xff);\n        }\n        mb.setChars(cbuf, 0, bc.getLength());\n   \n     }\n     */\n\n    \n    // START SJSAS 6349248\n    /**\n     * Notify all container event listeners that a particular event has\n     * occurred for this Adapter.  The default implementation performs\n     * this notification synchronously using the calling thread.\n     *\n     * @param type Event type\n     * @param data Event data\n     */\n    public void fireAdapterEvent(String type, Object data) {\n        if ( connector != null && connector.getContainer() != null) {\n            try{\n                ((ContainerBase)connector.getContainer())\n                    .fireContainerEvent(type,data);\n            } catch (Throwable t){\n                log.log(Level.SEVERE, LogFacade.REQUEST_PROCESSING_EXCEPTION, t);\n            }\n        }\n    }\n    // END SJSAS 6349248\n\n    \n    /**\n     * Return true when an instance is executed the same way it does in Tomcat.\n     */\n    public boolean isCompatWithTomcat() {\n        return compatWithTomcat;\n    }\n\n    \n    /**\n     * <tt>true</tt> if this class needs to be compatible with Tomcat\n     * Adapter class. Since Tomcat Adapter implementation doesn't support \n     * the afterService method, the afterService method must be invoked \n     * inside the service method.\n     */\n    public void setCompatWithTomcat(boolean compatWithTomcat) {\n        this.compatWithTomcat = compatWithTomcat;\n\n        // Add server header\n        if (compatWithTomcat){\n            serverName = \"Apache/\" + serverName;\n        } else {\n            // Recalculate.\n            serverName = ServerInfo.getPublicServerInfo();\n        }\n    }\n\n\n    /**\n     * Gets the port of this CoyoteAdapter.\n     *\n     * @return the port of this CoyoteAdapter\n     */\n    public int getPort() {\n        return connector.getPort();\n    }\n\n    /**\n     * AfterServiceListener, which is responsible for recycle catalina request and response\n     * objects.\n     */\n    static final class CatalinaAfterServiceListener implements AfterServiceListener {\n\n        @Override\n        public void onAfterService(final org.glassfish.grizzly.http.server.Request request) {\n            final Request servletRequest = request.getNote(CATALINA_REQUEST_NOTE);\n            final Response servletResponse = request.getNote(CATALINA_RESPONSE_NOTE);\n\n            if (servletRequest != null) {\n                try {\n                    if (!servletRequest.isUpgrade()) {\n                        servletResponse.finishResponse();\n                    } else {\n                        servletResponse.setUpgrade(servletRequest.isUpgrade());\n                    }\n                } catch (Exception e) {\n                    log.log(Level.SEVERE, LogFacade.REQUEST_PROCESSING_EXCEPTION, e);\n                } finally {\n                    try {\n                        servletRequest.unlockSession();\n                    } finally {\n                        servletRequest.recycle();\n                        servletResponse.recycle();\n                    }\n                }\n            }\n        }\n    }\n}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          394,
          1030
        ]
      },
      {
        "file_path": "appserver/web/web-core/src/main/java/org/apache/catalina/connector/CoyoteAdapter.java",
        "class_name": "CoyoteAdapter",
        "method_name": "normalizeBytes",
        "signature": "boolean normalizeBytes(MessageBytes)",
        "lines_hint_csv": [
          676,
          778
        ],
        "code": "    private static boolean normalizeBytes(MessageBytes uriMB) {\n\n        ByteChunk uriBC = uriMB.getByteChunk();\n        byte[] b = uriBC.getBytes();\n        int start = uriBC.getStart();\n        int end = uriBC.getEnd();\n\n        // An empty URL is not acceptable\n        if (start == end)\n            return false;\n\n        // URL * is acceptable\n        if ((end - start == 1) && b[start] == (byte) '*')\n          return true;\n\n        int pos = 0;\n        int index = 0;\n\n        // Replace '\\' with '/'\n        // Check for null byte\n        for (pos = start; pos < end; pos++) {\n            if (b[pos] == (byte) '\\\\') {\n                if (ALLOW_BACKSLASH) {\n                    b[pos] = (byte) '/';\n                } else {\n                    return false;\n                }\n            }\n            if (b[pos] == (byte) 0) {\n                return false;\n            }\n        }\n\n        // The URL must start with '/'\n        if (b[start] != (byte) '/') {\n            return false;\n        }\n\n        // Replace \"//\" with \"/\"\n        if (COLLAPSE_ADJACENT_SLASHES) {\n            for (pos = start; pos < (end - 1); pos++) {\n                if (b[pos] == (byte) '/') {\n                    while ((pos + 1 < end) && (b[pos + 1] == (byte) '/')) {\n                        copyBytes(b, pos, pos + 1, end - pos - 1);\n                        end--;\n                    }\n                }\n            }\n        }\n\n        // If the URI ends with \"/.\" or \"/..\", then we append an extra \"/\"\n        // Note: It is possible to extend the URI by 1 without any side effect\n        // as the next character is a non-significant WS.\n        if (((end - start) > 2) && (b[end - 1] == (byte) '.')) {\n            if ((b[end - 2] == (byte) '/') \n                || ((b[end - 2] == (byte) '.') \n                    && (b[end - 3] == (byte) '/'))) {\n                b[end] = (byte) '/';\n                end++;\n            }\n        }\n\n        uriBC.setEnd(end);\n\n        index = 0;\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/./\", 0, 3, index);\n            if (index < 0)\n                break;\n            copyBytes(b, start + index, start + index + 2, \n                      end - start - index - 2);\n            end = end - 2;\n            uriBC.setEnd(end);\n        }\n\n        index = 0;\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/../\", 0, 4, index);\n            if (index < 0)\n                break;\n            // Prevent from going outside our context\n            if (index == 0)\n                return false;\n            int index2 = -1;\n            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {\n                if (b[pos] == (byte) '/') {\n                    index2 = pos;\n                }\n            }\n            copyBytes(b, start + index2, start + index + 3,\n                      end - start - index - 3);\n            end = end + index2 - index - 3;\n            uriBC.setEnd(end);\n            index = index2;\n        }\n\n        uriBC.setBytes(b, start, end);\n\n        return true;\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          658,
          762
        ]
      },
      {
        "file_path": "appserver/web/web-core/src/main/java/org/apache/catalina/connector/CoyoteAdapter.java",
        "class_name": "CoyoteAdapter",
        "method_name": "copyBytes",
        "signature": "void copyBytes(byte,int,int,int)",
        "lines_hint_csv": [
          893,
          895
        ],
        "code": "    protected static void copyBytes(byte[] b, int dest, int src, int len) {\n        for (int pos = 0; pos < len; pos++) {\n            b[pos + dest] = b[pos + src];\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          875,
          879
        ]
      },
      {
        "file_path": "appserver/web/web-core/src/main/java/org/apache/catalina/connector/CoyoteAdapter.java",
        "class_name": "CoyoteAdapter",
        "method_name": "normalizeChars",
        "signature": "boolean normalizeChars(MessageBytes)",
        "lines_hint_csv": [
          783,
          881
        ],
        "code": "    private static boolean normalizeChars(MessageBytes uriMB) {\n\n        CharChunk uriCC = uriMB.getCharChunk();\n        char[] c = uriCC.getChars();\n        int start = uriCC.getStart();\n        int end = uriCC.getEnd();\n\n        // URL * is acceptable\n        if ((end - start == 1) && c[start] == (char) '*')\n          return true;\n\n        int pos = 0;\n        int index = 0;\n\n        // Replace '\\' with '/'\n        // Check for null char\n        for (pos = start; pos < end; pos++) {\n            if (c[pos] == (char) '\\\\') {\n                if (ALLOW_BACKSLASH) {\n                    c[pos] = (char) '/';\n                } else {\n                    return false;\n                }\n            }\n            if (c[pos] == (char) 0) {\n                return false;\n            }\n        }\n\n        // The URL must start with '/'\n        if (c[start] != (char) '/') {\n            return false;\n        }\n\n        // Replace \"//\" with \"/\"\n        if (COLLAPSE_ADJACENT_SLASHES) {\n            for (pos = start; pos < (end - 1); pos++) {\n                if (c[pos] == (char) '/') {\n                    while ((pos + 1 < end) && (c[pos + 1] == (char) '/')) {\n                        copyChars(c, pos, pos + 1, end - pos - 1);\n                        end--;\n                    }\n                }\n            }\n        }\t\n\n        // If the URI ends with \"/.\" or \"/..\", then we append an extra \"/\"\n        // Note: It is possible to extend the URI by 1 without any side effect\n        // as the next character is a non-significant WS.\n        if (((end - start) > 2) && (c[end - 1] == (char) '.')) {\n            if ((c[end - 2] == (char) '/') \n                || ((c[end - 2] == (char) '.') \n                    && (c[end - 3] == (char) '/'))) {\n                c[end] = (char) '/';\n                end++;\n            }\n        }\n\n        uriCC.setEnd(end);\n\n        index = 0;\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            index = uriCC.indexOf(\"/./\", 0, 3, index);\n            if (index < 0)\n                break;\n            copyChars(c, start + index, start + index + 2, \n                      end - start - index - 2);\n            end = end - 2;\n            uriCC.setEnd(end);\n        }\n\n        index = 0;\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            index = uriCC.indexOf(\"/../\", 0, 4, index);\n            if (index < 0)\n                break;\n            // Prevent from going outside our context\n            if (index == 0)\n                return false;\n            int index2 = -1;\n            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {\n                if (c[pos] == (char) '/') {\n                    index2 = pos;\n                }\n            }\n            copyChars(c, start + index2, start + index + 3,\n                      end - start - index - 3);\n            end = end + index2 - index - 3;\n            uriCC.setEnd(end);\n            index = index2;\n        }\n\n        uriCC.setChars(c, start, end);\n\n        return true;\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          765,
          865
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-31194",
    "project_slug": "DSpace__DSpace_CVE-2022-31194_5.10",
    "buggy_commit_id": "eca7968be7d6b9f8f5f302c9fc09f8186ed4809e",
    "github_url": "https://github.com/DSpace/DSpace",
    "nvd_metadata": {
      "description": "DSpace open source software is a repository application which provides durable access to digital resources. dspace-jspui is a UI component for DSpace. The JSPUI resumable upload implementations in SubmissionController and FileUploadRequest are vulnerable to multiple path traversal attacks, allowing an attacker to create files/directories anywhere on the server writable by the Tomcat/DSpace user, by modifying some request parameters during submission. This path traversal can only be executed by a user with special privileges (submitter rights). This vulnerability only impacts the JSPUI. Users are advised to upgrade. There are no known workarounds. However, this vulnerability cannot be exploited by an anonymous user or a basic user. The user must first have submitter privileges to at least one Collection and be able to determine how to modify the request parameters to exploit the vulnerability.",
      "published_date": "2022-08-01T21:15:13.490",
      "cvss_v3_score": 8.2,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/SubmissionController.java",
        "class_name": "SubmissionController",
        "method_name": "doPostResumable",
        "signature": "File doPostResumable(HttpServletRequest)",
        "lines_hint_csv": [
          1635,
          1711
        ],
        "code": "    protected File doPostResumable(HttpServletRequest request)\n            throws FileSizeLimitExceededException, IOException, ServletException \n    {\n        File completedFile = null;\n        FileUploadRequest wrapper = null;\n        \n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            tempDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else {\n            tempDir = System.getProperty(\"java.io.tmpdir\");\n        }\n        \n        try\n        {\n            // if we already have a FileUploadRequest, use it\n            if (Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\").isInstance(request))\n            {\n                wrapper = (FileUploadRequest) request;\n            } \n            else // if not wrap the mulitpart request to get the submission info\n            {\n                wrapper = new FileUploadRequest(request);\n            }\n        }\n        catch (ClassNotFoundException ex)\n        {\n            // Cannot find a class that is part of the JSPUI?\n            log.fatal(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest\");\n            throw new ServletException(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest.\", ex);\n        }\n\n        String resumableIdentifier = wrapper.getParameter(\"resumableIdentifier\");\n        long resumableTotalSize = Long.valueOf(wrapper.getParameter(\"resumableTotalSize\"));\n        int resumableTotalChunks = Integer.valueOf(wrapper.getParameter(\"resumableTotalChunks\"));\n\n        String chunkDirPath = tempDir + File.separator + resumableIdentifier;\n        File chunkDirPathFile = new File(chunkDirPath);\n        boolean foundAll = true;\n        long currentSize = 0l;\n        \n        // check whether all chunks were received.\n        if(chunkDirPathFile.exists())\n        {\n            for (int p = 1; p <= resumableTotalChunks; p++) \n            {\n                File file = new File(chunkDirPath + File.separator + \"part\" + Integer.toString(p));\n\n                if (!file.exists()) \n                {\n                    foundAll = false;\n                    break;\n                }\n                currentSize += file.length();\n            }\n        }\n        \n        if (foundAll && currentSize >= resumableTotalSize) \n        {\n            try {\n                // assemble the file from it chunks.\n                File file = makeFileFromChunks(tempDir, chunkDirPathFile, wrapper);\n            \n                if (file != null) \n                {\n                    completedFile = file;\n                }\n            } catch (IOException ex) {\n                // if the assembling of a file results in an IOException a\n                // retransmission has to be triggered. Throw the IOException\n                // here and handle it above.\n                throw ex;\n            }\n        }\n\n        return completedFile;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1617,
          1694
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/SubmissionController.java",
        "class_name": "SubmissionController",
        "method_name": "doDSGet",
        "signature": "void doDSGet(Context,HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          143,
          243
        ],
        "code": "    protected void doDSGet(Context context, HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        /*\n         * Possible GET parameters:\n         * \n         * resume= <workspace_item_id> - Resumes submitting the given workspace\n         * item\n         * \n         * workflow= <workflow_id> - Starts editing the given workflow item in\n         * workflow mode\n         * \n         * With no parameters, doDSGet() just calls doDSPost(), which continues\n         * the current submission (if one exists in the Request), or creates a\n         * new submission (if no existing submission can be found).\n         */\n\n        // try to get a workspace ID or workflow ID\n        String workspaceID = request.getParameter(\"resume\");\n        String workflowID = request.getParameter(\"workflow\");\n        String resumableFilename = request.getParameter(\"resumableFilename\");\n\n        // If resuming a workspace item\n        if (workspaceID != null)\n        {\n            try\n            {\n                // load the workspace item\n                WorkspaceItem wi = WorkspaceItem.find(context, Integer\n                        .parseInt(workspaceID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                //TD: Special case - If a user is resuming a submission\n                //where the submission process now has less steps, then\n                //we will need to reset the stepReached in the database\n                //(Hopefully this will never happen, but just in case!)\n                if(getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps())\n                {\n                    //update Stage Reached to the last step in the Process\n                    int lastStep = si.getSubmissionConfig().getNumberOfSteps()-1;\n                    wi.setStageReached(lastStep);\n                    \n                    //flag that user is on last page of last step\n                    wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);\n                    \n                    //commit all changes to database immediately\n                    wi.update();\n                    context.commit();\n                    \n                    //update submission info\n                    si.setSubmissionItem(wi);\n                }\n                    \n                // start over at beginning of first step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workspace_id\",\n                        \"bad_id=\" + workspaceID));\n                JSPManager.showInvalidIDError(request, response, workspaceID,\n                        -1);\n            }\n        }\n        else if (workflowID != null) // if resuming a workflow item\n        {\n            try\n            {\n                // load the workflow item\n                WorkflowItem wi = WorkflowItem.find(context, Integer\n                        .parseInt(workflowID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                // start over at beginning of first workflow step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, WORKFLOW_FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workflow_id\",\n                        \"bad_id=\" + workflowID));\n                JSPManager\n                        .showInvalidIDError(request, response, workflowID, -1);\n            }\n        }\n        else if (!StringUtils.isEmpty(resumableFilename)) // if resumable.js asks whether a part of af file was received\n        {\n            if (request.getMethod().equals(\"GET\"))\n            {\n                DoGetResumable(request, response);\n            }\n        }\n        else\n        {\n            // otherwise, forward to doDSPost() to do usual processing\n            doDSPost(context, request, response);\n        }\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          125,
          229
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/SubmissionController.java",
        "class_name": "SubmissionController",
        "method_name": "DoGetResumable",
        "signature": "void DoGetResumable(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          1589,
          1629
        ],
        "code": "    protected void DoGetResumable(HttpServletRequest request, HttpServletResponse response) \n        throws IOException\n    {\n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            tempDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else\n        {\n            tempDir = System.getProperty(\"java.io.tmpdir\");\n        }\n\n        String resumableIdentifier = request.getParameter(\"resumableIdentifier\");\n        String resumableChunkNumber = request.getParameter(\"resumableChunkNumber\");\n        long resumableCurrentChunkSize = \n                Long.valueOf(request.getParameter(\"resumableCurrentChunkSize\"));\n\n        tempDir = tempDir + File.separator + resumableIdentifier;\n\n        File fileDir = new File(tempDir);\n\n        // create a new directory for each resumableIdentifier\n        if (!fileDir.exists()) {\n            fileDir.mkdir();\n        }\n        // use the String \"part\" and the chunkNumber as filename of a chunk\n        String chunkPath = tempDir + File.separator + \"part\" + resumableChunkNumber;\n\n        File chunkFile = new File(chunkPath);\n        // if the chunk was uploaded already, we send a status code of 200\n        if (chunkFile.exists()) {\n            if (chunkFile.length() == resumableCurrentChunkSize) {\n                response.setStatus(HttpServletResponse.SC_OK);\n                return;\n            }\n            // The chunk file does not have the expected size, delete it and \n            // pretend that it wasn't uploaded already.\n            chunkFile.delete();\n        }\n        // if we don't have the chunk send a http status code 404\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1571,
          1612
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/util/FileUploadRequest.java",
        "class_name": "FileUploadRequest",
        "method_name": "FileUploadRequest",
        "signature": "FileUploadRequest(HttpServletRequest)",
        "lines_hint_csv": [
          56,
          153
        ],
        "code": "    public FileUploadRequest(HttpServletRequest req) throws IOException, FileSizeLimitExceededException\n    {\n        super(req);\n\n        original = req;\n\n        tempDir = (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n            ? ConfigurationManager.getProperty(\"upload.temp.dir\") : System.getProperty(\"java.io.tmpdir\"); \n        long maxSize = ConfigurationManager.getLongProperty(\"upload.max\");\n\n        // Create a factory for disk-based file items\n        DiskFileItemFactory factory = new DiskFileItemFactory();\n        factory.setRepository(new File(tempDir));\n\n        // Create a new file upload handler\n        ServletFileUpload upload = new ServletFileUpload(factory);\n\n        HttpSession session = req.getSession();\n        \n        if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n        {\n            // set file upload progress listener\n            FileUploadListener listener = new FileUploadListener();\n    \n            session.setAttribute(FILE_UPLOAD_LISTNER, listener);\n    \n            // upload servlet allows to set upload listener\n            upload.setProgressListener(listener);\n        }\n        \n        try\n        {\n            upload.setSizeMax(maxSize);\n            List<FileItem> items = upload.parseRequest(req);\n            for (FileItem item : items)\n            {\n                if (item.isFormField())\n                {\n                    parameters.put(item.getFieldName(), item.getString(\"UTF-8\"));\n                }\n                else\n                {\n                    if (parameters.containsKey(\"resumableIdentifier\")) \n                    {\n                        String filename = getFilename(parameters.get(\"resumableFilename\"));\n                        if (!StringUtils.isEmpty(filename)) \n                        {\n                            String chunkDirPath = tempDir + File.separator + parameters.get(\"resumableIdentifier\");\n                            String chunkPath = chunkDirPath + File.separator + \"part\" + parameters.get(\"resumableChunkNumber\");\n                            File fileDir = new File(chunkDirPath);\n                            \n                            if(fileDir.exists())\n                            {\n                                item.write(new File(chunkPath));\n                            }\n                        }\n                    }\n                    else\n                    {\n                        parameters.put(item.getFieldName(), item.getName());\n                        fileitems.put(item.getFieldName(), item);\n                        filenames.add(item.getName());\n\n                        String filename = getFilename(item.getName());\n                        if (filename != null && !\"\".equals(filename))\n                        {\n                            item.write(new File(tempDir + File.separator\n                                            + filename));\n                        }\n                    }\n                }\n            }\n        }\n        catch(IOFileUploadException e){\n            if (!(e.getMessage().contains(\"Stream ended unexpectedly\")))\n            {\n                throw new IOException(e.getMessage(), e);\n            }\n        }\n        catch (Exception e)\n        {\n            if(e.getMessage().contains(\"exceeds the configured maximum\"))\n            {\n                // ServletFileUpload is not throwing the correct error, so this is workaround\n                // the request was rejected because its size (11302) exceeds the configured maximum (536)\n                int startFirstParen = e.getMessage().indexOf(\"(\")+1;\n                int endFirstParen = e.getMessage().indexOf(\")\");\n                String uploadedSize = e.getMessage().substring(startFirstParen, endFirstParen).trim();\n                Long actualSize = Long.parseLong(uploadedSize);\n                throw new FileSizeLimitExceededException(e.getMessage(), actualSize, maxSize);\n            }\n            throw new IOException(e.getMessage(), e);\n        }\n        finally\n        {\n            if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n            {\n                session.removeAttribute(FILE_UPLOAD_LISTNER);\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          56,
          156
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/SubmissionController.java",
        "class_name": "SubmissionController",
        "method_name": "DoGetResumable",
        "signature": "void DoGetResumable(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          1571,
          1611
        ],
        "code": "    protected void DoGetResumable(HttpServletRequest request, HttpServletResponse response) \n        throws IOException\n    {\n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            tempDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else\n        {\n            tempDir = System.getProperty(\"java.io.tmpdir\");\n        }\n\n        String resumableIdentifier = request.getParameter(\"resumableIdentifier\");\n        String resumableChunkNumber = request.getParameter(\"resumableChunkNumber\");\n        long resumableCurrentChunkSize = \n                Long.valueOf(request.getParameter(\"resumableCurrentChunkSize\"));\n\n        tempDir = tempDir + File.separator + resumableIdentifier;\n\n        File fileDir = new File(tempDir);\n\n        // create a new directory for each resumableIdentifier\n        if (!fileDir.exists()) {\n            fileDir.mkdir();\n        }\n        // use the String \"part\" and the chunkNumber as filename of a chunk\n        String chunkPath = tempDir + File.separator + \"part\" + resumableChunkNumber;\n\n        File chunkFile = new File(chunkPath);\n        // if the chunk was uploaded already, we send a status code of 200\n        if (chunkFile.exists()) {\n            if (chunkFile.length() == resumableCurrentChunkSize) {\n                response.setStatus(HttpServletResponse.SC_OK);\n                return;\n            }\n            // The chunk file does not have the expected size, delete it and \n            // pretend that it wasn't uploaded already.\n            chunkFile.delete();\n        }\n        // if we don't have the chunk send a http status code 404\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1571,
          1612
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/SubmissionController.java",
        "class_name": "SubmissionController",
        "method_name": "doDSGet",
        "signature": "void doDSGet(Context,HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          125,
          226
        ],
        "code": "    protected void doDSGet(Context context, HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n        /*\n         * Possible GET parameters:\n         * \n         * resume= <workspace_item_id> - Resumes submitting the given workspace\n         * item\n         * \n         * workflow= <workflow_id> - Starts editing the given workflow item in\n         * workflow mode\n         * \n         * With no parameters, doDSGet() just calls doDSPost(), which continues\n         * the current submission (if one exists in the Request), or creates a\n         * new submission (if no existing submission can be found).\n         */\n\n        // try to get a workspace ID or workflow ID\n        String workspaceID = request.getParameter(\"resume\");\n        String workflowID = request.getParameter(\"workflow\");\n        String resumableFilename = request.getParameter(\"resumableFilename\");\n\n        // If resuming a workspace item\n        if (workspaceID != null)\n        {\n            try\n            {\n                // load the workspace item\n                WorkspaceItem wi = WorkspaceItem.find(context, Integer\n                        .parseInt(workspaceID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                //TD: Special case - If a user is resuming a submission\n                //where the submission process now has less steps, then\n                //we will need to reset the stepReached in the database\n                //(Hopefully this will never happen, but just in case!)\n                if(getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps())\n                {\n                    //update Stage Reached to the last step in the Process\n                    int lastStep = si.getSubmissionConfig().getNumberOfSteps()-1;\n                    wi.setStageReached(lastStep);\n                    \n                    //flag that user is on last page of last step\n                    wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);\n                    \n                    //commit all changes to database immediately\n                    wi.update();\n                    context.commit();\n                    \n                    //update submission info\n                    si.setSubmissionItem(wi);\n                }\n                    \n                // start over at beginning of first step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workspace_id\",\n                        \"bad_id=\" + workspaceID));\n                JSPManager.showInvalidIDError(request, response, workspaceID,\n                        -1);\n            }\n        }\n        else if (workflowID != null) // if resuming a workflow item\n        {\n            try\n            {\n                // load the workflow item\n                WorkflowItem wi = WorkflowItem.find(context, Integer\n                        .parseInt(workflowID));\n\n                //load submission information\n                SubmissionInfo si = SubmissionInfo.load(request, wi);\n                \n                // start over at beginning of first workflow step\n                setBeginningOfStep(request, true);\n                doStep(context, request, response, si, WORKFLOW_FIRST_STEP);\n            }\n            catch (NumberFormatException nfe)\n            {\n                log.warn(LogManager.getHeader(context, \"bad_workflow_id\",\n                        \"bad_id=\" + workflowID));\n                JSPManager\n                        .showInvalidIDError(request, response, workflowID, -1);\n            }\n        }\n        else if (!StringUtils.isEmpty(resumableFilename)) // if resumable.js asks whether a part of af file was received\n        {\n            if (request.getMethod().equals(\"GET\"))\n            {\n                DoGetResumable(request, response);\n            }\n        }\n        else\n        {\n            // otherwise, forward to doDSPost() to do usual processing\n            doDSPost(context, request, response);\n        }\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          125,
          229
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/SubmissionController.java",
        "class_name": "SubmissionController",
        "method_name": "doPostResumable",
        "signature": "File doPostResumable(HttpServletRequest)",
        "lines_hint_csv": [
          1617,
          1693
        ],
        "code": "    protected File doPostResumable(HttpServletRequest request)\n            throws FileSizeLimitExceededException, IOException, ServletException \n    {\n        File completedFile = null;\n        FileUploadRequest wrapper = null;\n        \n        if (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n        {\n            tempDir = ConfigurationManager.getProperty(\"upload.temp.dir\");\n        }\n        else {\n            tempDir = System.getProperty(\"java.io.tmpdir\");\n        }\n        \n        try\n        {\n            // if we already have a FileUploadRequest, use it\n            if (Class.forName(\"org.dspace.app.webui.util.FileUploadRequest\").isInstance(request))\n            {\n                wrapper = (FileUploadRequest) request;\n            } \n            else // if not wrap the mulitpart request to get the submission info\n            {\n                wrapper = new FileUploadRequest(request);\n            }\n        }\n        catch (ClassNotFoundException ex)\n        {\n            // Cannot find a class that is part of the JSPUI?\n            log.fatal(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest\");\n            throw new ServletException(\"Cannot find class org.dspace.app.webui.util.FileUploadRequest.\", ex);\n        }\n\n        String resumableIdentifier = wrapper.getParameter(\"resumableIdentifier\");\n        long resumableTotalSize = Long.valueOf(wrapper.getParameter(\"resumableTotalSize\"));\n        int resumableTotalChunks = Integer.valueOf(wrapper.getParameter(\"resumableTotalChunks\"));\n\n        String chunkDirPath = tempDir + File.separator + resumableIdentifier;\n        File chunkDirPathFile = new File(chunkDirPath);\n        boolean foundAll = true;\n        long currentSize = 0l;\n        \n        // check whether all chunks were received.\n        if(chunkDirPathFile.exists())\n        {\n            for (int p = 1; p <= resumableTotalChunks; p++) \n            {\n                File file = new File(chunkDirPath + File.separator + \"part\" + Integer.toString(p));\n\n                if (!file.exists()) \n                {\n                    foundAll = false;\n                    break;\n                }\n                currentSize += file.length();\n            }\n        }\n        \n        if (foundAll && currentSize >= resumableTotalSize) \n        {\n            try {\n                // assemble the file from it chunks.\n                File file = makeFileFromChunks(tempDir, chunkDirPathFile, wrapper);\n            \n                if (file != null) \n                {\n                    completedFile = file;\n                }\n            } catch (IOException ex) {\n                // if the assembling of a file results in an IOException a\n                // retransmission has to be triggered. Throw the IOException\n                // here and handle it above.\n                throw ex;\n            }\n        }\n\n        return completedFile;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1617,
          1694
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/util/FileUploadRequest.java",
        "class_name": "FileUploadRequest",
        "method_name": "FileUploadRequest",
        "signature": "FileUploadRequest(HttpServletRequest)",
        "lines_hint_csv": [
          56,
          153
        ],
        "code": "    public FileUploadRequest(HttpServletRequest req) throws IOException, FileSizeLimitExceededException\n    {\n        super(req);\n\n        original = req;\n\n        tempDir = (ConfigurationManager.getProperty(\"upload.temp.dir\") != null)\n            ? ConfigurationManager.getProperty(\"upload.temp.dir\") : System.getProperty(\"java.io.tmpdir\"); \n        long maxSize = ConfigurationManager.getLongProperty(\"upload.max\");\n\n        // Create a factory for disk-based file items\n        DiskFileItemFactory factory = new DiskFileItemFactory();\n        factory.setRepository(new File(tempDir));\n\n        // Create a new file upload handler\n        ServletFileUpload upload = new ServletFileUpload(factory);\n\n        HttpSession session = req.getSession();\n        \n        if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n        {\n            // set file upload progress listener\n            FileUploadListener listener = new FileUploadListener();\n    \n            session.setAttribute(FILE_UPLOAD_LISTNER, listener);\n    \n            // upload servlet allows to set upload listener\n            upload.setProgressListener(listener);\n        }\n        \n        try\n        {\n            upload.setSizeMax(maxSize);\n            List<FileItem> items = upload.parseRequest(req);\n            for (FileItem item : items)\n            {\n                if (item.isFormField())\n                {\n                    parameters.put(item.getFieldName(), item.getString(\"UTF-8\"));\n                }\n                else\n                {\n                    if (parameters.containsKey(\"resumableIdentifier\")) \n                    {\n                        String filename = getFilename(parameters.get(\"resumableFilename\"));\n                        if (!StringUtils.isEmpty(filename)) \n                        {\n                            String chunkDirPath = tempDir + File.separator + parameters.get(\"resumableIdentifier\");\n                            String chunkPath = chunkDirPath + File.separator + \"part\" + parameters.get(\"resumableChunkNumber\");\n                            File fileDir = new File(chunkDirPath);\n                            \n                            if(fileDir.exists())\n                            {\n                                item.write(new File(chunkPath));\n                            }\n                        }\n                    }\n                    else\n                    {\n                        parameters.put(item.getFieldName(), item.getName());\n                        fileitems.put(item.getFieldName(), item);\n                        filenames.add(item.getName());\n\n                        String filename = getFilename(item.getName());\n                        if (filename != null && !\"\".equals(filename))\n                        {\n                            item.write(new File(tempDir + File.separator\n                                            + filename));\n                        }\n                    }\n                }\n            }\n        }\n        catch(IOFileUploadException e){\n            if (!(e.getMessage().contains(\"Stream ended unexpectedly\")))\n            {\n                throw new IOException(e.getMessage(), e);\n            }\n        }\n        catch (Exception e)\n        {\n            if(e.getMessage().contains(\"exceeds the configured maximum\"))\n            {\n                // ServletFileUpload is not throwing the correct error, so this is workaround\n                // the request was rejected because its size (11302) exceeds the configured maximum (536)\n                int startFirstParen = e.getMessage().indexOf(\"(\")+1;\n                int endFirstParen = e.getMessage().indexOf(\")\");\n                String uploadedSize = e.getMessage().substring(startFirstParen, endFirstParen).trim();\n                Long actualSize = Long.parseLong(uploadedSize);\n                throw new FileSizeLimitExceededException(e.getMessage(), actualSize, maxSize);\n            }\n            throw new IOException(e.getMessage(), e);\n        }\n        finally\n        {\n            if (ConfigurationManager.getBooleanProperty(\"webui.submit.upload.progressbar\", true))\n            {\n                session.removeAttribute(FILE_UPLOAD_LISTNER);\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          56,
          156
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-26049",
    "project_slug": "diffplug__goomph_CVE-2022-26049_3.37.1",
    "buggy_commit_id": "fe2083196f0d0a75885aea402baaa972254173d5",
    "github_url": "https://github.com/diffplug/goomph",
    "nvd_metadata": {
      "description": "This affects the package com.diffplug.gradle:goomph before 3.37.2. It allows a malicious zip file to potentially break out of the expected destination directory, writing contents into arbitrary locations on the file system. Overwriting certain files/directories could allow an attacker to achieve remote code execution on a target system by exploiting this vulnerability. **Note:** This could have allowed a malicious zip file to extract itself into an arbitrary directory. The only file that Goomph extracts is the p2 bootstrapper and eclipse metadata files hosted at eclipse.org, which are not malicious, so the only way this vulnerability could have affected you is if you had set a custom bootstrap zip, and that zip was malicious.",
      "published_date": "2022-09-11T14:15:08.887",
      "cvss_v3_score": 5.3,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/com/diffplug/gradle/ZipMisc.java",
        "class_name": "ZipMisc",
        "method_name": "unzip",
        "signature": "void unzip(File,File)",
        "lines_hint_csv": [
          176,
          186
        ],
        "code": "\tpublic static void unzip(File input, File destinationDir) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(input)))) {\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          176,
          191
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-26884",
    "project_slug": "apache__dolphinscheduler_CVE-2022-26884_2.0.5",
    "buggy_commit_id": "f31328276c12821c21d1ce07e824bc74146c19b2",
    "github_url": "https://github.com/apache/dolphinscheduler",
    "nvd_metadata": {
      "description": "Users can read any files by log server, Apache DolphinScheduler users should upgrade to version 2.0.6 or higher.",
      "published_date": "2022-10-28T08:15:08.927",
      "cvss_v3_score": 6.5,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java",
        "class_name": "LoggerRequestProcessor",
        "method_name": "checkPathSecurity",
        "signature": "boolean checkPathSecurity(String)",
        "lines_hint_csv": [
          142,
          148
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2022-34662",
    "project_slug": "apache__dolphinscheduler_CVE-2022-34662_2.0.9",
    "buggy_commit_id": "23302054559410093573fb169336bafeb02db97f",
    "github_url": "https://github.com/apache/dolphinscheduler",
    "nvd_metadata": {
      "description": "When users add resources to the resource center with a relation path will cause path traversal issues and only for logged-in users. You could upgrade to version 3.0.0 or higher",
      "published_date": "2022-11-01T16:15:13.447",
      "cvss_v3_score": 6.5,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/ResourcesServiceImpl.java",
        "class_name": "ResourcesServiceImpl",
        "method_name": "createDirectory",
        "signature": "Result<Object> createDirectory(User loginUser, String name, String description, ResourceType type, int pid, String currentDir)",
        "lines_hint_csv": [
          122,
          173
        ],
        "code": "    private void createDirectory(User loginUser,String fullName,ResourceType type,Result<Object> result) {\n        String tenantCode = tenantMapper.queryById(loginUser.getTenantId()).getTenantCode();\n        String directoryName = HadoopUtils.getHdfsFileName(type,tenantCode,fullName);\n        String resourceRootPath = HadoopUtils.getHdfsDir(type,tenantCode);\n        try {\n            if (!HadoopUtils.getInstance().exists(resourceRootPath)) {\n                createTenantDirIfNotExists(tenantCode);\n            }\n\n            if (!HadoopUtils.getInstance().mkdir(directoryName)) {\n                logger.error(\"create resource directory {} of hdfs failed\",directoryName);\n                putMsg(result,Status.HDFS_OPERATION_ERROR);\n                throw new ServiceException(String.format(\"create resource directory: %s failed.\", directoryName));\n            }\n        } catch (Exception e) {\n            logger.error(\"create resource directory {} of hdfs failed\",directoryName);\n            putMsg(result,Status.HDFS_OPERATION_ERROR);\n            throw new ServiceException(String.format(\"create resource directory: %s failed.\", directoryName));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          600,
          619
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/ResourcesServiceImpl.java",
        "class_name": "ResourcesServiceImpl",
        "method_name": "verifyFile",
        "signature": "Result<Object> verifyFile(String name, ResourceType type, MultipartFile file)",
        "lines_hint_csv": [
          517,
          566
        ],
        "code": "    private Result<Object> verifyFile(String name, ResourceType type, MultipartFile file) {\n        Result<Object> result = new Result<>();\n        putMsg(result, Status.SUCCESS);\n\n        if (FileUtils.directoryTraversal(name)) {\n            logger.error(\"file alias name {} verify failed\", name);\n            putMsg(result, Status.VERIFY_PARAMETER_NAME_FAILED);\n            return result;\n        }\n\n        if (file != null && FileUtils.directoryTraversal(Objects.requireNonNull(file.getOriginalFilename()))) {\n            logger.error(\"file original name {} verify failed\", file.getOriginalFilename());\n            putMsg(result, Status.VERIFY_PARAMETER_NAME_FAILED);\n            return result;\n        }\n\n        if (file != null) {\n            // file is empty\n            if (file.isEmpty()) {\n                logger.error(\"file is empty: {}\", RegexUtils.escapeNRT(file.getOriginalFilename()));\n                putMsg(result, Status.RESOURCE_FILE_IS_EMPTY);\n                return result;\n            }\n\n            // file suffix\n            String fileSuffix = Files.getFileExtension(file.getOriginalFilename());\n            String nameSuffix = Files.getFileExtension(name);\n\n            // determine file suffix\n            if (!(StringUtils.isNotEmpty(fileSuffix) && fileSuffix.equalsIgnoreCase(nameSuffix))) {\n                // rename file suffix and original suffix must be consistent\n                logger.error(\"rename file suffix and original suffix must be consistent: {}\", RegexUtils.escapeNRT(file.getOriginalFilename()));\n                putMsg(result, Status.RESOURCE_SUFFIX_FORBID_CHANGE);\n                return result;\n            }\n\n            //If resource type is UDF, only jar packages are allowed to be uploaded, and the suffix must be .jar\n            if (Constants.UDF.equals(type.name()) && !JAR.equalsIgnoreCase(fileSuffix)) {\n                logger.error(Status.UDF_RESOURCE_SUFFIX_NOT_JAR.getMsg());\n                putMsg(result, Status.UDF_RESOURCE_SUFFIX_NOT_JAR);\n                return result;\n            }\n            if (file.getSize() > Constants.MAX_FILE_SIZE) {\n                logger.error(\"file size is too large: {}\", RegexUtils.escapeNRT(file.getOriginalFilename()));\n                putMsg(result, Status.RESOURCE_SIZE_EXCEED_LIMIT);\n                return result;\n            }\n        }\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          503,
          552
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/ResourcesServiceImpl.java",
        "class_name": "ResourcesServiceImpl",
        "method_name": "onlineCreateResource",
        "signature": "Result<Object> onlineCreateResource(User loginUser, ResourceType type, String fileName, String fileSuffix, String desc, String content, int pid, String currentDir)",
        "lines_hint_csv": [
          984,
          1036
        ],
        "code": "    public Result<Object> onlineCreateResource(User loginUser, ResourceType type, String fileName, String fileSuffix, String desc, String content,int pid,String currentDir) {\n        Result<Object> result = checkResourceUploadStartupState();\n        if (!result.getCode().equals(Status.SUCCESS.getCode())) {\n            return result;\n        }\n        if (FileUtils.directoryTraversal(fileName)) {\n            putMsg(result, Status.VERIFY_PARAMETER_NAME_FAILED);\n            return result;\n        }\n\n        //check file suffix\n        String nameSuffix = fileSuffix.trim();\n        String resourceViewSuffixs = FileUtils.getResourceViewSuffixs();\n        if (StringUtils.isNotEmpty(resourceViewSuffixs)) {\n            List<String> strList = Arrays.asList(resourceViewSuffixs.split(\",\"));\n            if (!strList.contains(nameSuffix)) {\n                logger.error(\"resource suffix {} not support create\", nameSuffix);\n                putMsg(result, Status.RESOURCE_SUFFIX_NOT_SUPPORT_VIEW);\n                return result;\n            }\n        }\n\n        String name = fileName.trim() + \".\" + nameSuffix;\n        String fullName = currentDir.equals(\"/\") ? String.format(\"%s%s\",currentDir,name) : String.format(\"%s/%s\",currentDir,name);\n        result = verifyResource(loginUser, type, fullName, pid);\n        if (!result.getCode().equals(Status.SUCCESS.getCode())) {\n            return result;\n        }\n\n        // save data\n        Date now = new Date();\n        Resource resource = new Resource(pid,name,fullName,false,desc,name,loginUser.getId(),type,content.getBytes().length,now,now);\n\n        resourcesMapper.insert(resource);\n        updateParentResourceSize(resource, resource.getSize());\n\n        putMsg(result, Status.SUCCESS);\n        Map<Object, Object> dataMap = new BeanMap(resource);\n        Map<String, Object> resultMap = new HashMap<>();\n        for (Map.Entry<Object, Object> entry: dataMap.entrySet()) {\n            if (!Constants.CLASS.equalsIgnoreCase(entry.getKey().toString())) {\n                resultMap.put(entry.getKey().toString(), entry.getValue());\n            }\n        }\n        result.setData(resultMap);\n\n        String tenantCode = tenantMapper.queryById(loginUser.getTenantId()).getTenantCode();\n\n        result = uploadContentToHdfs(fullName, tenantCode, content);\n        if (!result.getCode().equals(Status.SUCCESS.getCode())) {\n            throw new ServiceException(result.getMsg());\n        }\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          950,
          1003
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-4065",
    "project_slug": "testng-team__testng_CVE-2022-4065_7.5",
    "buggy_commit_id": "d8adcef70a9e0b8fcef5eab92ca87a8d398cfb89",
    "github_url": "https://github.com/cbeust/testng",
    "nvd_metadata": {
      "description": "A vulnerability was found in cbeust testng 7.5.0/7.6.0/7.6.1/7.7.0. It has been declared as critical. Affected by this vulnerability is the function testngXmlExistsInJar of the file testng-core/src/main/java/org/testng/JarFileUtils.java of the component XML File Parser. The manipulation leads to path traversal. The attack can be launched remotely. Upgrading to version 7.5.1 and 7.7.1 is able to address this issue. The patch is named 9150736cd2c123a6a3b60e6193630859f9f0422b. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-214027.",
      "published_date": "2022-11-19T19:15:10.433",
      "cvss_v3_score": 5.5,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "testng-core/src/main/java/org/testng/JarFileUtils.java",
        "class_name": "JarFileUtils",
        "method_name": "testngXmlExistsInJar",
        "signature": "boolean testngXmlExistsInJar(File,List)",
        "lines_hint_csv": [
          68,
          105
        ],
        "code": "  private boolean testngXmlExistsInJar(File jarFile, List<String> classes) throws IOException {\n    try (JarFile jf = new JarFile(jarFile)) {\n      Enumeration<JarEntry> entries = jf.entries();\n      File file = java.nio.file.Files.createTempDirectory(\"testngXmlPathInJar-\").toFile();\n      String suitePath = null;\n      while (entries.hasMoreElements()) {\n        JarEntry je = entries.nextElement();\n        String jeName = je.getName();\n        if (Parser.canParse(jeName.toLowerCase())) {\n          InputStream inputStream = jf.getInputStream(je);\n          File copyFile = new File(file, jeName);\n          Files.copyFile(inputStream, copyFile);\n          if (matchesXmlPathInJar(je)) {\n            suitePath = copyFile.toString();\n          }\n        } else if (isJavaClass(je)) {\n          classes.add(constructClassName(je));\n        }\n      }\n      if (Strings.isNullOrEmpty(suitePath)) {\n        return false;\n      }\n      Collection<XmlSuite> parsedSuites = Parser.parse(suitePath, processor);\n      delete(file);\n      for (XmlSuite suite : parsedSuites) {\n        // If test names were specified, only run these test names\n        if (testNames != null) {\n          TestNamesMatcher testNamesMatcher = new TestNamesMatcher(suite, testNames);\n          List<String> missMatchedTestname = testNamesMatcher.getMissMatchedTestNames();\n          if (!missMatchedTestname.isEmpty()) {\n            throw new TestNGException(\"The test(s) <\" + missMatchedTestname + \"> cannot be found.\");\n          }\n          suites.addAll(testNamesMatcher.getSuitesMatchingTestNames());\n        } else {\n          suites.add(suite);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          68,
          108
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-32287",
    "project_slug": "apache__uima-uimaj_CVE-2022-32287_3.3.0",
    "buggy_commit_id": "f1f557a415ae38e383bf050587a510211515c21d",
    "github_url": "https://github.com/apache/uima-uimaj",
    "nvd_metadata": {
      "description": "A relative path traversal vulnerability in a FileUtil class used by the PEAR management component of Apache UIMA allows an attacker to create files outside the designated target directory using carefully crafted ZIP entry names. This issue affects Apache UIMA Apache UIMA version 3.3.0 and prior versions. Note that PEAR files should never be installed into an UIMA installation from untrusted sources because PEAR archives are executable plugins that will be able to perform any actions with the same privileges as the host Java Virtual Machine.",
      "published_date": "2022-11-03T12:15:09.743",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "zipFile",
        "signature": "File zipFile(File)",
        "lines_hint_csv": [
          1442,
          1449
        ],
        "code": "  public static File zipFile(File file2zip) throws IOException {\n    // construct zipped file path\n    String zipFileName = file2zip.getName();\n    int extIndex = zipFileName.lastIndexOf('.');\n    zipFileName = (extIndex >= 0) ? zipFileName.substring(0, extIndex) + \".zip\"\n            : zipFileName + \".zip\";\n    File zipFile = new File(file2zip.getParentFile(), zipFileName);\n    return zipFile(file2zip, zipFile);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1442,
          1450
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "extractDirectoryFromJar",
        "signature": "long extractDirectoryFromJar(JarFile,String,File)",
        "lines_hint_csv": [
          675,
          677
        ],
        "code": "  public static long extractDirectoryFromJar(JarFile jarFile, String dirPath, File targetDir)\n          throws IOException {\n    return extractFilesFromJar(jarFile, targetDir, new DirFileFilter(dirPath, null));\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          675,
          678
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "zipDirectory",
        "signature": "File zipDirectory(File)",
        "lines_hint_csv": [
          1335,
          1339
        ],
        "code": "  public static File zipDirectory(File dir2zip) throws IOException {\n    // construct zipped file path\n    String zipFileName = dir2zip.getName() + \".zip\";\n    File zipFile = new File(dir2zip, zipFileName);\n    return zipDirectory(dir2zip, zipFile);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1335,
          1340
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "NameFileFilter",
        "method_name": "accept",
        "signature": "boolean accept(File)",
        "lines_hint_csv": [
          170,
          180
        ],
        "code": "    public boolean accept(File file) {\n      String filePath = file.getAbsolutePath().replace('\\\\', '/');\n      if (filePath.endsWith(_fileName)) {\n        if (filePath.length() > _fileName.length()) {\n          char prevChar = filePath.charAt(filePath.length() - _fileName.length() - 1);\n          if (prevChar == ':' || prevChar == '/')\n            return true;\n        } else\n          return true;\n      }\n      return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          170,
          181
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "getRelativePath",
        "signature": "String getRelativePath(File,String)",
        "lines_hint_csv": [
          838,
          845
        ],
        "code": "  public static String getRelativePath(File rootDir, String absolutePath) {\n    String rootDirPath = rootDir.getAbsolutePath().replace('\\\\', '/');\n    String objectPath = absolutePath.replace('\\\\', '/');\n    if (objectPath.startsWith(rootDirPath))\n      objectPath = objectPath.substring(rootDirPath.length());\n    if (objectPath.startsWith(\"/\"))\n      objectPath = objectPath.substring(1);\n    return objectPath;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          838,
          846
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "zipDirectory",
        "signature": "ZipOutputStream zipDirectory(File,ZipOutputStream,File,File)",
        "lines_hint_csv": [
          1382,
          1429
        ],
        "code": "  public static ZipOutputStream zipDirectory(File dir2zip, ZipOutputStream zoStream,\n          File referenceDir, File[] excludeFiles) throws IOException {\n    byte[] block = new byte[4096];\n    int inBytes = 0;\n    FileInputStream iStream = null;\n    try {\n      // get list of all files/dirs in the given directory\n      File[] dirFileList = dir2zip.listFiles();\n      // compress all files and sub-dirs\n      for (int i = 0; i < dirFileList.length; i++) {\n        File entry = dirFileList[i];\n        // check if this entry is not in the list of exclusions\n        boolean isExcluded = false;\n        for (int n = 0; n < excludeFiles.length; n++) {\n          if (entry.equals(excludeFiles[n])) {\n            isExcluded = true;\n            break;\n          }\n        }\n        if (isExcluded)\n          continue;\n        // for each file - add ZipEntry and compress the file\n        if (entry.isFile()) {\n          // open input stream\n          iStream = new FileInputStream(entry);\n          // put ZipEntry for the file\n          String zipEntryName = (referenceDir != null)\n                  ? getRelativePath(referenceDir, entry.getAbsolutePath())\n                  : getRelativePath(dir2zip, entry.getAbsolutePath());\n          ZipEntry zipEntry = new ZipEntry(zipEntryName);\n          zoStream.putNextEntry(zipEntry);\n          // read input stream and write to output stream\n          while ((inBytes = iStream.read(block)) > 0)\n            zoStream.write(block, 0, inBytes);\n          // close input stream\n          iStream.close();\n        } else if (entry.isDirectory()) // zip sub-dir recursively\n          zipDirectory(entry, zoStream, referenceDir, excludeFiles);\n      }\n    } finally {\n      if (iStream != null) {\n        try {\n          iStream.close();\n        } catch (Exception e) {\n        }\n      }\n    }\n    return zoStream;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1382,
          1430
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "createFileList",
        "signature": "Collection createFileList(JarFile)",
        "lines_hint_csv": [
          579,
          594
        ],
        "code": "  public static Collection<File> createFileList(JarFile archive) throws IOException {\n    ArrayList<File> listOfFiles = new ArrayList<>();\n    // set root_dir_path = archive_file_path (w/o file name extension)\n    int nameEndIndex = archive.getName().lastIndexOf('.');\n    String rootDirPath = (nameEndIndex > 0) ? archive.getName().substring(0, nameEndIndex)\n            : archive.getName();\n    File rootDir = new File(rootDirPath);\n    // add directories to the list\n    Enumeration<JarEntry> entries = archive.entries();\n    while (entries.hasMoreElements()) {\n      JarEntry entry = entries.nextElement();\n      File file = new File(rootDir, entry.getName());\n      if (!entry.isDirectory())\n        listOfFiles.add(file);\n    }\n    return listOfFiles;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          579,
          595
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "deleteDirectory",
        "signature": "boolean deleteDirectory(File)",
        "lines_hint_csv": [
          639,
          658
        ],
        "code": "  public static boolean deleteDirectory(File dir) throws IOException {\n    boolean done = true;\n    // list immediate files/subdirs in this dir\n    File[] fileList = dir.listFiles();\n    // first, delete plain files and sub-directories (recursive)\n    for (int i = 0; i < fileList.length; i++) {\n      File entry = fileList[i];\n      if (entry.isDirectory())\n        done = deleteDirectory(entry);\n      else if (!entry.delete()) {\n        entry.deleteOnExit();\n        done = false;\n      }\n    }\n    // second, delete the root dir itself\n    if (!dir.delete()) {\n      dir.deleteOnExit();\n      done = false;\n    }\n    return done;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          639,
          659
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "DirFileFilter",
        "method_name": "DirFileFilter",
        "signature": "DirFileFilter(String,String)",
        "lines_hint_csv": [
          118,
          123
        ],
        "code": "    public DirFileFilter(String dirPath, String fileExt) {\n      _dirPath = (dirPath != null) ? dirPath.replace('\\\\', '/') : null;\n      if (fileExt != null)\n        _fileExt = fileExt.startsWith(\".\") ? fileExt.toLowerCase() : \".\" + fileExt.toLowerCase();\n      else\n        _fileExt = null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          118,
          124
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "getFileSize",
        "signature": "long getFileSize(String)",
        "lines_hint_csv": [
          808,
          825
        ],
        "code": "  public static long getFileSize(String fileLocation) {\n    long fileSize = 0;\n    // choose file size method: local FS or HTTP\n    File file = new File(fileLocation);\n    if (file.isFile())\n      fileSize = file.length();\n    else {\n      try {\n        URL fileUrl = new URL(fileLocation);\n        URLConnection urlConn = fileUrl.openConnection();\n        // See https://issues.apache.org/jira/browse/UIMA-1746\n        urlConn.setUseCaches(false);\n        fileSize = urlConn.getContentLength();\n      } catch (IOException e) {\n        fileSize = -1;\n      }\n    }\n    return fileSize;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          808,
          826
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "isAsciiStream",
        "signature": "boolean isAsciiStream(InputStream)",
        "lines_hint_csv": [
          924,
          938
        ],
        "code": "  public static boolean isAsciiStream(InputStream iStream) throws IOException {\n    boolean isAscii = true;\n    try {\n      int nextByte = 0;\n      while ((nextByte = iStream.read()) >= 0) {\n        if (nextByte > 127) {\n          isAscii = false;\n          break;\n        }\n      }\n    } catch (IOException exc) {\n      isAscii = false;\n      throw exc;\n    }\n    return isAscii;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          924,
          939
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "createDirList",
        "signature": "Collection createDirList(JarFile)",
        "lines_hint_csv": [
          494,
          518
        ],
        "code": "  public static Collection<File> createDirList(JarFile archive) throws IOException {\n    ArrayList<File> listOfDirs = new ArrayList<>();\n    // set root_dir_path = archive_file_path (w/o file name extension)\n    int nameEndIndex = archive.getName().lastIndexOf('.');\n    String rootDirPath = (nameEndIndex > 0) ? archive.getName().substring(0, nameEndIndex)\n            : archive.getName();\n    File rootDir = new File(rootDirPath);\n    // add directories to the list\n    Enumeration<JarEntry> entries = archive.entries();\n    while (entries.hasMoreElements()) {\n      JarEntry entry = entries.nextElement();\n      File file = new File(rootDir, entry.getName());\n      if (entry.isDirectory())\n        listOfDirs.add(file);\n      else {\n        // make sure the parent dir is added\n        File parentDir = file.getParentFile();\n        while (!parentDir.equals(rootDir)) {\n          if (!listOfDirs.contains(parentDir))\n            listOfDirs.add(parentDir);\n          parentDir = parentDir.getParentFile();\n        }\n      }\n    }\n    return listOfDirs;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          494,
          519
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "loadTextFileFromJar",
        "signature": "String loadTextFileFromJar(String,JarFile)",
        "lines_hint_csv": [
          1156,
          1166
        ],
        "code": "  public static String loadTextFileFromJar(String filePath, JarFile jarFile) throws IOException {\n    String content = null;\n    String name = filePath.replace('\\\\', '/');\n    JarEntry jarEntry = jarFile.getJarEntry(name);\n    if (jarEntry != null) {\n      try (BufferedReader iStream = new BufferedReader(\n              new InputStreamReader(jarFile.getInputStream(jarEntry)))) {\n        content = loadTextFile(iStream);\n      }\n    }\n    return content;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1156,
          1167
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "DirFileFilter",
        "method_name": "accept",
        "signature": "boolean accept(File)",
        "lines_hint_csv": [
          132,
          142
        ],
        "code": "    public boolean accept(File file) {\n      boolean dirAccepted = true;\n      boolean extAccepted = true;\n      if (_dirPath != null) {\n        String parentDir = file.getParent();\n        dirAccepted = parentDir != null && parentDir.replace('\\\\', '/').startsWith(_dirPath);\n      }\n      if (_fileExt != null) {\n        extAccepted = file.getPath().toLowerCase().endsWith(_fileExt);\n      }\n      return dirAccepted && extAccepted;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          132,
          143
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "moveFile",
        "signature": "boolean moveFile(File,File)",
        "lines_hint_csv": [
          1207,
          1215
        ],
        "code": "  public static boolean moveFile(File source, File destinationDir) throws IOException {\n    boolean completed = false;\n    File destination = new File(destinationDir, source.getName());\n    if (destination.exists())\n      destination.delete();\n    if (copyFile(source, destination)) {\n      completed = source.delete();\n    }\n    return completed;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1207,
          1216
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "loadListOfStrings",
        "signature": "String loadListOfStrings(BufferedReader)",
        "lines_hint_csv": [
          950,
          963
        ],
        "code": "  public static String[] loadListOfStrings(BufferedReader iStream) throws IOException {\n    String[] outputArray = null;\n    List<String> outputList = new ArrayList<>();\n    String line = null;\n    while ((line = iStream.readLine()) != null) {\n      String string = line.trim();\n      if (string.length() > 0)\n        outputList.add(string);\n    }\n    if (outputList.size() > 0) {\n      outputArray = new String[outputList.size()];\n      outputList.toArray(outputArray);\n    }\n    return (outputArray != null) ? outputArray : Constants.EMPTY_STRING_ARRAY;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          950,
          964
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "localPathToFileUrl",
        "signature": "String localPathToFileUrl(String)",
        "lines_hint_csv": [
          1176,
          1190
        ],
        "code": "  public static String localPathToFileUrl(String path) {\n    // get absolute path\n    File file = new File(path);\n    String absPath = file.getAbsolutePath().replace('\\\\', '/');\n    // construct file URL\n    StringBuffer urlBuffer = new StringBuffer(\"file:///\");\n    urlBuffer.append(absPath.replace(':', '|'));\n    String fileUrlString = urlBuffer.toString().replaceAll(\" \", \"%20\");\n    URL fileUrl = null;\n    try {\n      fileUrl = new URL(fileUrlString);\n    } catch (MalformedURLException e) {\n      fileUrl = null;\n    }\n    return (fileUrl != null) ? fileUrl.toExternalForm() : fileUrlString;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1176,
          1191
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "replaceStringInFile",
        "signature": "int replaceStringInFile(File,String,String)",
        "lines_hint_csv": [
          1233,
          1309
        ],
        "code": "  public static int replaceStringInFile(File textFile, String subStringRegex, String replacement)\n          throws IOException {\n    int counter = 0;\n    // for general text file - supporting ASCII encoding only\n    String encoding = \"ASCII\";\n    // check file extension\n    int extIndex = textFile.getName().lastIndexOf('.');\n    String fileExt = (extIndex > 0) ? textFile.getName().substring(extIndex) : null;\n    if (\".xml\".equalsIgnoreCase(fileExt)) {\n      // for XML file - supporting UTF-8 (ASCII) and UTF-16 encodings\n      String xmlEncoding = XMLUtil.detectXmlFileEncoding(textFile);\n      if (xmlEncoding != null) {\n        encoding = xmlEncoding;\n      } else {\n        encoding = \"UTF-8\";\n      }\n    }\n    // load text file, using supported encoding\n    String fileContent = loadTextFile(textFile, encoding);\n    BufferedReader sReader = null;\n    PrintStream fStream = null;\n    boolean done = false;\n    File backupFile = null;\n    // get pattern for given regex\n    Pattern pattern = Pattern.compile(subStringRegex);\n    // format replacement string\n    String replaceWith = StringUtil.toRegExpReplacement(replacement);\n    try {\n      // save backup copy of input file\n      backupFile = new File(textFile.getAbsolutePath() + \".bak\");\n      if (backupFile.exists())\n        backupFile.delete();\n      if (!textFile.renameTo(backupFile))\n        throw new IOException(\"can't save backup copy of \" + textFile.getAbsolutePath());\n      sReader = new BufferedReader(new StringReader(fileContent));\n      fStream = new PrintStream(new FileOutputStream(textFile), true, encoding);\n      String srcLine = null;\n      while ((srcLine = sReader.readLine()) != null) {\n        // count pattern matches in the source string\n        Matcher matcher = pattern.matcher(srcLine);\n        while (matcher.find())\n          counter++;\n        // replace all pattern matches in the source string\n        String resLine = srcLine.replaceAll(subStringRegex, replaceWith);\n        fStream.println(resLine);\n      }\n      fStream.close();\n      done = true;\n    } catch (IOException exc) {\n      throw exc;\n    } catch (Throwable err) {\n      if (err instanceof IOException)\n        throw new IOException(err.toString() + \" in \" + textFile.getAbsolutePath());\n      throw new RuntimeException(err.toString() + \" in \" + textFile.getAbsolutePath());\n    } finally {\n      if (sReader != null) {\n        try {\n          sReader.close();\n        } catch (Exception e) {\n        }\n      }\n      if (fStream != null) {\n        try {\n          fStream.close();\n        } catch (Exception e) {\n        }\n      }\n      if (done) {\n        // remove backup file\n        backupFile.delete();\n      } else {\n        // restore input file\n        textFile.delete();\n        backupFile.renameTo(textFile);\n      }\n    }\n    return counter;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1233,
          1310
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "loadTextFile",
        "signature": "String loadTextFile(File)",
        "lines_hint_csv": [
          1080,
          1085
        ],
        "code": "  public static String loadTextFile(File textFile) throws IOException {\n    String content;\n    try (BufferedReader iStream = new BufferedReader(new FileReader(textFile))) {\n      content = loadTextFile(iStream);\n    }\n    return content;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1080,
          1086
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "cleanUpDirectoryContent",
        "signature": "int cleanUpDirectoryContent(File)",
        "lines_hint_csv": [
          253,
          273
        ],
        "code": "  public static int cleanUpDirectoryContent(File directory) throws IOException {\n    int counter = 0;\n    File[] allDirFiles = directory.listFiles();\n    if (allDirFiles != null) {\n      for (int i = 0; i < allDirFiles.length; i++) {\n        File aFile = allDirFiles[i];\n        if (aFile.isDirectory()) {\n          counter += cleanUpDirectoryContent(aFile);\n          if (aFile.delete())\n            counter++;\n          else\n            aFile.deleteOnExit();\n        } else if (aFile.isFile()) {\n          if (aFile.delete())\n            counter++;\n          else\n            aFile.deleteOnExit();\n        }\n      }\n    }\n    return counter;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          253,
          274
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "identifyUtfSignature",
        "signature": "String identifyUtfSignature(int,int)",
        "lines_hint_csv": [
          860,
          879
        ],
        "code": "  public static String identifyUtfSignature(int[] prefix, int length) {\n    String utfSignature = null;\n    if (length == 3) {\n      // check for UTF-8 signature\n      if (prefix[0] == 0xEF && prefix[1] == 0xBB && prefix[2] == 0xBF)\n        utfSignature = \"UTF-8\";\n    } else if (length == 2) {\n      // check for UTF-16 signature\n      if (prefix[0] == 0xFE && prefix[1] == 0xFF)\n        utfSignature = \"UTF-16BE\";\n      else if (prefix[0] == 0xFF && prefix[1] == 0xFE)\n        utfSignature = \"UTF-16LE\";\n    } else if (length == 4) {\n      // check for UTF-32 signature\n      if (prefix[0] == 0x00 && prefix[1] == 0x00 && prefix[2] == 0xFE && prefix[3] == 0xFF)\n        utfSignature = \"UTF-32BE\";\n      else if (prefix[0] == 0xFF && prefix[1] == 0xFE && prefix[2] == 0x00 && prefix[3] == 0x00)\n        utfSignature = \"UTF-32LE\";\n    }\n    return utfSignature;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          860,
          880
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "zipFile",
        "signature": "File zipFile(File,File)",
        "lines_hint_csv": [
          1463,
          1494
        ],
        "code": "  public static File zipFile(File file2zip, File zippedFile) throws IOException {\n    byte[] block = new byte[4096];\n    int inBytes = 0;\n    FileInputStream iStream = null;\n    ZipOutputStream oStream = null;\n    try {\n      // open input stream\n      iStream = new FileInputStream(file2zip);\n      // create ZipEntry, using input file name\n      ZipEntry zipEntry = new ZipEntry(file2zip.getName());\n      // open compressed output stream\n      oStream = new ZipOutputStream(new FileOutputStream(zippedFile));\n      // add new ZipEntry\n      oStream.putNextEntry(zipEntry);\n      // read input stream and write to output stream\n      while ((inBytes = iStream.read(block)) > 0)\n        oStream.write(block, 0, inBytes);\n    } finally {\n      if (iStream != null) {\n        try {\n          iStream.close();\n        } catch (Exception e) {\n        }\n      }\n      if (oStream != null) {\n        try {\n          oStream.close();\n        } catch (Exception e) {\n        }\n      }\n    }\n    return zippedFile;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1463,
          1495
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "computeRelativePath",
        "signature": "String computeRelativePath(File,File)",
        "lines_hint_csv": [
          351,
          375
        ],
        "code": "  public static String computeRelativePath(File referenceDir, File file) throws IOException {\n    // get canonical path expressions\n    String refPath = referenceDir.getCanonicalPath().replace('\\\\', '/');\n    String filePath = file.getCanonicalPath().replace('\\\\', '/');\n    // compute relative path from reference dir to file dir-tree\n    StringBuffer relBuffer = new StringBuffer();\n    while (refPath != null && !filePath.startsWith(refPath)) {\n      relBuffer.append(\"../\");\n      refPath = (new File(refPath)).getParent();\n      if (refPath != null)\n        refPath = refPath.replace('\\\\', '/');\n    }\n    if (refPath != null) {\n      // construct relative path\n      String subPath = filePath.substring(refPath.length());\n      if (relBuffer.length() == 0)\n        relBuffer.append(\"./\");\n      if (subPath.startsWith(\"/\"))\n        relBuffer.append(subPath.substring(1));\n      else\n        relBuffer.append(subPath);\n      return relBuffer.toString();\n    }\n    // relative path does not exist\n    return null;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          351,
          376
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "createTempFile",
        "signature": "File createTempFile(String,String)",
        "lines_hint_csv": [
          615,
          624
        ],
        "code": "  public static File createTempFile(String prefix, String suffix) throws IOException {\n    String tempDirPath = System.getProperty(\"java.io.tmpdir\");\n    if (tempDirPath == null)\n      tempDirPath = System.getProperty(\"user.home\");\n    if (tempDirPath == null)\n      throw new IOException(\"could not find temporary directory\");\n    File tempDir = new File(tempDirPath);\n    if (!tempDir.isDirectory())\n      throw new IOException(\"temporary directory not available\");\n    return File.createTempFile(prefix, suffix, tempDir);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          615,
          625
        ]
      },
      {
        "file_path": "uimaj-core/src/main/java/org/apache/uima/pear/util/FileUtil.java",
        "class_name": "FileUtil",
        "method_name": "loadTextFile",
        "signature": "String loadTextFile(BufferedReader)",
        "lines_hint_csv": [
          1044,
          1064
        ],
        "code": "  public static String loadTextFile(BufferedReader iStream) throws IOException {\n    StringWriter buffer = null;\n    PrintWriter writer = null;\n    try {\n      buffer = new StringWriter();\n      writer = new PrintWriter(buffer);\n      String line = null;\n      while ((line = iStream.readLine()) != null)\n        writer.println(line);\n      writer.flush();\n    } catch (IOException exc) {\n      throw exc;\n    } finally {\n      if (writer != null) {\n        try {\n          writer.close();\n        } catch (Exception e) {\n        }\n      }\n    }\n    return buffer.toString();\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1044,
          1065
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-3782",
    "project_slug": "keycloak__keycloak_CVE-2022-3782_20.0.1",
    "buggy_commit_id": "cce8ee2b1ab7c925bfbb62d8f12a33e93d943040",
    "github_url": "https://github.com/keycloak/keycloak",
    "nvd_metadata": {
      "description": "keycloak: path traversal via double URL encoding. A flaw was found in Keycloak, where it does not properly validate URLs included in a redirect. An attacker can use this flaw to construct a malicious request to bypass validation and access other URLs and potentially sensitive information within the domain or possibly conduct further attacks. This flaw affects any client that utilizes a wildcard in the Valid Redirect URIs field.",
      "published_date": "2023-01-13T06:15:11.187",
      "cvss_v3_score": 9.1,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java",
        "class_name": "LogoutEndpoint",
        "method_name": "doBrowserLogout",
        "signature": "Response doBrowserLogout(AuthenticationSessionModel)",
        "lines_hint_csv": [
          435,
          483
        ],
        "code": "    private Response doBrowserLogout(AuthenticationSessionModel logoutSession) {\n        UserSessionModel userSession = null;\n        String userSessionIdFromIdToken = logoutSession.getAuthNote(OIDCLoginProtocol.LOGOUT_VALIDATED_ID_TOKEN_SESSION_STATE);\n        String idTokenIssuedAtStr = logoutSession.getAuthNote(OIDCLoginProtocol.LOGOUT_VALIDATED_ID_TOKEN_ISSUED_AT);\n        if (userSessionIdFromIdToken != null && idTokenIssuedAtStr != null) {\n            try {\n                userSession = lockUserSessionsForModification(session, () -> session.sessions().getUserSession(realm, userSessionIdFromIdToken));\n\n                if (userSession != null) {\n                    Integer idTokenIssuedAt = Integer.parseInt(idTokenIssuedAtStr);\n                    checkTokenIssuedAt(idTokenIssuedAt, userSession);\n                }\n            } catch (OAuthErrorException e) {\n                event.event(EventType.LOGOUT);\n                event.error(Errors.INVALID_TOKEN);\n                return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.SESSION_NOT_ACTIVE);\n            }\n        }\n\n        // authenticate identity cookie, but ignore an access token timeout as we're logging out anyways.\n        AuthenticationManager.AuthResult authResult = lockUserSessionsForModification(session,\n                () -> AuthenticationManager.authenticateIdentityCookie(session, realm, false));\n        if (authResult != null) {\n            userSession = userSession != null ? userSession : authResult.getSession();\n            return initiateBrowserLogout(userSession);\n        } else if (userSession != null) {\n            // identity cookie is missing but there's valid id_token_hint which matches session cookie => continue with browser logout\n            if (userSessionIdFromIdToken.equals(AuthenticationManager.getSessionIdFromSessionCookie(session))) {\n                return initiateBrowserLogout(userSession);\n            }\n            // check if the user session is not logging out or already logged out\n            // this might happen when a backChannelLogout is already initiated from AuthenticationManager.authenticateIdentityCookie\n            if (userSession.getState() != LOGGING_OUT && userSession.getState() != LOGGED_OUT) {\n                // non browser logout\n                event.event(EventType.LOGOUT);\n                AuthenticationManager.backchannelLogout(session, realm, userSession, session.getContext().getUri(), clientConnection, headers, true);\n\n                String redirectUri = logoutSession.getAuthNote(OIDCLoginProtocol.LOGOUT_REDIRECT_URI);\n                if (redirectUri != null) {\n                    event.detail(Details.REDIRECT_URI, redirectUri);\n                }\n                event.user(userSession.getUser()).session(userSession).success();\n            }\n        }\n\n        logger.tracef(\"Removing logout session '%s' used during logout.\", logoutSession.getParentSession().getId());\n        RootAuthenticationSessionModel rootAuthSession = logoutSession.getParentSession();\n        rootAuthSession.removeAuthenticationSessionByTabId(logoutSession.getTabId());\n        return LogoutUtil.sendResponseAfterLogoutFinished(session, logoutSession);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          435,
          484
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java",
        "class_name": "LogoutEndpoint",
        "method_name": "logoutConfirmGet",
        "signature": "Response logoutConfirmGet()",
        "lines_hint_csv": [
          396,
          430
        ],
        "code": "    public Response logoutConfirmGet() {\n        event.event(EventType.LOGOUT);\n\n        String clientId = session.getContext().getUri().getQueryParameters().getFirst(Constants.CLIENT_ID);\n        String tabId = session.getContext().getUri().getQueryParameters().getFirst(Constants.TAB_ID);\n\n        logger.tracef(\"Changing localization by user during logout. clientId=%s, tabId=%s, kc_locale: %s\", clientId, tabId, session.getContext().getUri().getQueryParameters().getFirst(LocaleSelectorProvider.KC_LOCALE_PARAM));\n\n        SessionCodeChecks checks = new LogoutSessionCodeChecks(realm, session.getContext().getUri(), request, clientConnection, session, event, null, clientId, tabId);\n        AuthenticationSessionModel logoutSession = checks.initialVerifyAuthSession();\n        if (logoutSession == null) {\n            logger.debugf(\"Failed verification when changing locale logout. clientId=%s, tabId=%s\", clientId, tabId);\n\n            LoginFormsProvider loginForm = session.getProvider(LoginFormsProvider.class);\n            if (clientId == null || clientId.equals(SystemClientUtil.getSystemClient(realm).getClientId())) {\n                // Cleanup system client URL to avoid links to account management\n                loginForm.setAttribute(Constants.SKIP_LINK, true);\n            }\n\n            AuthenticationManager.AuthResult authResult = AuthenticationManager.authenticateIdentityCookie(session, realm, false);\n            if (authResult != null) {\n                return ErrorPage.error(session, logoutSession, Response.Status.BAD_REQUEST, Messages.FAILED_LOGOUT);\n            } else {\n                // Probably changing locale on logout screen after logout was already performed. If there is no session in the browser, we can just display that logout was already finished\n                return loginForm.setSuccess(Messages.SUCCESS_LOGOUT).createInfoPage();\n            }\n        }\n\n        LocaleUtil.processLocaleParam(session, realm, logoutSession);\n\n        LoginFormsProvider loginForm = session.getProvider(LoginFormsProvider.class)\n                .setAuthenticationSession(logoutSession)\n                .setUser(logoutSession.getAuthenticatedUser());\n\n        return displayLogoutConfirmationScreen(loginForm, logoutSession);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          396,
          431
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java",
        "class_name": "LogoutEndpoint",
        "method_name": "logoutConfirmAction",
        "signature": "Response logoutConfirmAction()",
        "lines_hint_csv": [
          361,
          388
        ],
        "code": "    public Response logoutConfirmAction() {\n        MultivaluedMap<String, String> formData = request.getDecodedFormParameters();\n        event.event(EventType.LOGOUT);\n        String code = formData.getFirst(SESSION_CODE);\n        String clientId = session.getContext().getUri().getQueryParameters().getFirst(Constants.CLIENT_ID);\n        String tabId = session.getContext().getUri().getQueryParameters().getFirst(Constants.TAB_ID);\n\n        logger.tracef(\"Logout confirmed. sessionCode=%s, clientId=%s, tabId=%s\", code, clientId, tabId);\n\n        SessionCodeChecks checks = new LogoutSessionCodeChecks(realm, session.getContext().getUri(), request, clientConnection, session, event, code, clientId, tabId);\n        checks.initialVerify();\n        if (!checks.verifyActiveAndValidAction(AuthenticationSessionModel.Action.LOGGING_OUT.name(), ClientSessionCode.ActionType.USER) || !checks.isActionRequest() || !formData.containsKey(\"confirmLogout\")) {\n            AuthenticationSessionModel logoutSession = checks.getAuthenticationSession();\n            logger.debugf(\"Failed verification during logout. logoutSessionId=%s, clientId=%s, tabId=%s\",\n                    logoutSession != null ? logoutSession.getParentSession().getId() : \"unknown\", clientId, tabId);\n\n            if (logoutSession == null || logoutSession.getClient().equals(SystemClientUtil.getSystemClient(logoutSession.getRealm()))) {\n                // Cleanup system client URL to avoid links to account management\n                session.getProvider(LoginFormsProvider.class).setAttribute(Constants.SKIP_LINK, true);\n            }\n\n            return ErrorPage.error(session, logoutSession, Response.Status.BAD_REQUEST, Messages.FAILED_LOGOUT);\n        }\n\n        AuthenticationSessionModel logoutSession = checks.getAuthenticationSession();\n        logger.tracef(\"Logout code successfully verified. Logout Session is '%s'. Client ID is '%s'.\", logoutSession.getParentSession().getId(),\n                logoutSession.getClient().getClientId());\n        return doBrowserLogout(logoutSession);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          361,
          389
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "verifyRedirectUri",
        "signature": "String verifyRedirectUri(KeycloakSession,String,String,Set,boolean)",
        "lines_hint_csv": [
          90,
          151
        ],
        "code": "    public static String verifyRedirectUri(KeycloakSession session, String rootUrl, String redirectUri, Set<String> validRedirects, boolean requireRedirectUri) {\n        KeycloakUriInfo uriInfo = session.getContext().getUri();\n        RealmModel realm = session.getContext().getRealm();\n\n        if (redirectUri != null) {\n            try {\n                URI uri = URI.create(redirectUri);\n                redirectUri = uri.normalize().toString();\n            } catch (IllegalArgumentException cause) {\n                logger.debug(\"Invalid redirect uri\", cause);\n                return null;\n            } catch (Exception cause) {\n                logger.debug(\"Unexpected error when parsing redirect uri\", cause);\n                return null;\n            }\n        }\n\n        if (redirectUri == null) {\n            if (!requireRedirectUri) {\n                redirectUri = getSingleValidRedirectUri(validRedirects);\n            }\n\n            if (redirectUri == null) {\n                logger.debug(\"No Redirect URI parameter specified\");\n                return null;\n            }\n        } else if (validRedirects.isEmpty()) {\n            logger.debug(\"No Redirect URIs supplied\");\n            redirectUri = null;\n        } else {\n            redirectUri = lowerCaseHostname(redirectUri);\n\n            String r = redirectUri;\n            Set<String> resolveValidRedirects = resolveValidRedirects(session, rootUrl, validRedirects);\n\n            boolean valid = matchesRedirects(resolveValidRedirects, r);\n\n            if (!valid && (r.startsWith(Constants.INSTALLED_APP_URL) || r.startsWith(Constants.INSTALLED_APP_LOOPBACK)) && r.indexOf(':', Constants.INSTALLED_APP_URL.length()) >= 0) {\n                int i = r.indexOf(':', Constants.INSTALLED_APP_URL.length());\n\n                StringBuilder sb = new StringBuilder();\n                sb.append(r.substring(0, i));\n\n                i = r.indexOf('/', i);\n                if (i >= 0) {\n                    sb.append(r.substring(i));\n                }\n\n                r = sb.toString();\n\n                valid = matchesRedirects(resolveValidRedirects, r);\n            }\n            if (valid && redirectUri.startsWith(\"/\")) {\n                redirectUri = relativeToAbsoluteURI(session, rootUrl, redirectUri);\n            }\n            redirectUri = valid ? redirectUri : null;\n        }\n\n        if (Constants.INSTALLED_APP_URN.equals(redirectUri)) {\n            return Urls.realmInstalledAppUrnCallback(uriInfo.getBaseUri(), realm.getName()).toString();\n        } else {\n            return redirectUri;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          90,
          153
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "lowerCaseHostname",
        "signature": "String lowerCaseHostname(String)",
        "lines_hint_csv": [
          155,
          160
        ],
        "code": "    private static String lowerCaseHostname(String redirectUri) {\n        int n = redirectUri.indexOf('/', 7);\n        if (n == -1) {\n            return redirectUri.toLowerCase();\n        } else {\n            return redirectUri.substring(0, n).toLowerCase() + redirectUri.substring(n);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          155,
          162
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "getSingleValidRedirectUri",
        "signature": "String getSingleValidRedirectUri(Collection)",
        "lines_hint_csv": [
          196,
          199
        ],
        "code": "    private static String getSingleValidRedirectUri(Collection<String> validRedirects) {\n        if (validRedirects.size() != 1) return null;\n        String validRedirect = validRedirects.iterator().next();\n        return validateRedirectUriWildcard(validRedirect);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          196,
          200
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/services/managers/AuthenticationSessionManager.java",
        "class_name": "AuthenticationSessionManager",
        "method_name": "getAuthSessionCookies",
        "signature": "List getAuthSessionCookies(RealmModel)",
        "lines_hint_csv": [
          186,
          199
        ],
        "code": "    List<String> getAuthSessionCookies(RealmModel realm) {\n        Set<String> cookiesVal = CookieHelper.getCookieValue(AUTH_SESSION_ID);\n\n        if (cookiesVal.size() > 1) {\n            AuthenticationManager.expireOldAuthSessionCookie(realm, session.getContext().getUri(), session.getContext().getConnection());\n        }\n\n        List<String> authSessionIds = cookiesVal.stream().limit(AUTH_SESSION_COOKIE_LIMIT).collect(Collectors.toList());\n\n        if (authSessionIds.isEmpty()) {\n            log.debugf(\"Not found AUTH_SESSION_ID cookie\");\n        }\n\n        return authSessionIds;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          186,
          200
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/services/managers/UserSessionCrossDCManager.java",
        "class_name": "UserSessionCrossDCManager",
        "method_name": "getUserSessionIfExistsRemotely",
        "signature": "UserSessionModel getUserSessionIfExistsRemotely(AuthenticationSessionManager,RealmModel,UserSessionModel)",
        "lines_hint_csv": [
          65,
          83
        ],
        "code": "    public UserSessionModel getUserSessionIfExistsRemotely(AuthenticationSessionManager asm, RealmModel realm) {\n        List<String> sessionCookies = asm.getAuthSessionCookies(realm);\n\n        return sessionCookies.stream().map(oldEncodedId -> {\n            AuthSessionId authSessionId = asm.decodeAuthSessionId(oldEncodedId);\n            String sessionId = authSessionId.getDecodedId();\n\n            // This will remove userSession \"locally\" if it doesn't exist on remoteCache\n            lockUserSessionsForModification(kcSession, () -> kcSession.sessions().getUserSessionWithPredicate(realm, sessionId, false, (UserSessionModel userSession2) -> userSession2 == null));\n\n            UserSessionModel userSession = lockUserSessionsForModification(kcSession, () -> kcSession.sessions().getUserSession(realm, sessionId));\n\n            if (userSession != null) {\n                asm.reencodeAuthSessionCookie(oldEncodedId, authSessionId, realm);\n                return userSession;\n            }\n\n            return null;\n        }).filter(userSession -> Objects.nonNull(userSession)).findFirst().orElse(null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          65,
          84
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/services/resources/SessionCodeChecks.java",
        "class_name": "SessionCodeChecks",
        "method_name": "initialVerifyAuthSession",
        "signature": "AuthenticationSessionModel initialVerifyAuthSession()",
        "lines_hint_csv": [
          128,
          196
        ],
        "code": "    public AuthenticationSessionModel initialVerifyAuthSession() {\n        // Basic realm checks\n        if (!checkSsl()) {\n            event.error(Errors.SSL_REQUIRED);\n            response = ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.HTTPS_REQUIRED);\n            return null;\n        }\n        if (!realm.isEnabled()) {\n            event.error(Errors.REALM_DISABLED);\n            response = ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.REALM_NOT_ENABLED);\n            return null;\n        }\n\n        // Setup client to be shown on error/info page based on \"client_id\" parameter\n        logger.debugf(\"Will use client '%s' in back-to-application link\", clientId);\n        ClientModel client = null;\n        if (clientId != null) {\n            client = realm.getClientByClientId(clientId);\n        }\n        if (client != null) {\n            session.getContext().setClient(client);\n        }\n\n\n        // object retrieve\n        AuthenticationSessionManager authSessionManager = new AuthenticationSessionManager(session);\n        AuthenticationSessionModel authSession = null;\n        if (authSessionId != null)\n            authSession = authSessionManager.getAuthenticationSessionByIdAndClient(realm, authSessionId, client, tabId);\n        AuthenticationSessionModel authSessionCookie = authSessionManager.getCurrentAuthenticationSession(realm, client, tabId);\n\n        if (authSession != null && authSessionCookie != null && !authSession.getParentSession().getId().equals(authSessionCookie.getParentSession().getId())) {\n            event.detail(Details.REASON, \"cookie does not match auth_session query parameter\");\n            event.error(Errors.INVALID_CODE);\n            response = ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_CODE);\n            return null;\n\n        }\n\n        if (authSession != null) {\n            session.getProvider(LoginFormsProvider.class).setAuthenticationSession(authSession);\n            return authSession;\n        }\n\n        if (authSessionCookie != null) {\n            session.getProvider(LoginFormsProvider.class).setAuthenticationSession(authSessionCookie);\n            return authSessionCookie;\n\n        }\n\n        // See if we are already authenticated and userSession with same ID exists.\n        UserSessionModel userSession = authSessionManager.getUserSessionFromAuthCookie(realm);\n\n        if (userSession != null) {\n            LoginFormsProvider loginForm = session.getProvider(LoginFormsProvider.class).setAuthenticationSession(authSession)\n                    .setSuccess(Messages.ALREADY_LOGGED_IN);\n\n            if (client == null) {\n                loginForm.setAttribute(Constants.SKIP_LINK, true);\n            }\n\n            response = loginForm.createInfoPage();\n            return null;\n        }\n\n        // Otherwise just try to restart from the cookie\n        RootAuthenticationSessionModel existingRootAuthSession = authSessionManager.getCurrentRootAuthenticationSession(realm);\n        response = restartAuthenticationSessionFromCookie(existingRootAuthSession);\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          128,
          197
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/OAuthRedirectUriTest.java",
        "class_name": "OAuthRedirectUriTest",
        "method_name": "testWildcard",
        "signature": "void testWildcard()",
        "lines_hint_csv": [
          330,
          339
        ],
        "code": "    public void testWildcard() throws IOException {\n        oauth.clientId(\"test-wildcard\");\n        checkRedirectUri(\"http://example.com\", false);\n        checkRedirectUri(\"http://localhost:8080\", false, true);\n        checkRedirectUri(\"http://example.com/foo\", true);\n        checkRedirectUri(\"http://example.com/foo/bar\", true);\n        checkRedirectUri(\"http://localhost:8280/foo\", true, true);\n        checkRedirectUri(\"http://localhost:8280/foo/bar\", true, true);\n        checkRedirectUri(\"http://example.com/foobar\", false);\n        checkRedirectUri(\"http://localhost:8280/foobar\", false, true);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          330,
          340
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/OAuthRedirectUriTest.java",
        "class_name": "OAuthRedirectUriTest",
        "method_name": "testLocalhost",
        "signature": "void testLocalhost()",
        "lines_hint_csv": [
          388,
          406
        ],
        "code": "    public void testLocalhost() throws IOException {\n        oauth.clientId(\"test-installed\");\n\n        checkRedirectUri(\"urn:ietf:wg:oauth:2.0:oob\", true, true);\n        checkRedirectUri(\"http://localhost\", true);\n\n        checkRedirectUri(\"http://localhost:8280\", true, true);\n\n        checkRedirectUri(\"http://localhosts\", false);\n        checkRedirectUri(\"http://localhost/myapp\", false);\n        checkRedirectUri(\"http://localhost:8180/myapp\", false, true);\n        oauth.clientId(\"test-installed2\");\n\n        checkRedirectUri(\"http://localhost/myapp\", true);\n        checkRedirectUri(\"http://localhost:8280/myapp\", true, true);\n\n        checkRedirectUri(\"http://localhosts/myapp\", false);\n        checkRedirectUri(\"http://localhost\", false);\n        checkRedirectUri(\"http://localhost/myapp2\", false);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          388,
          407
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/OAuthRedirectUriTest.java",
        "class_name": "OAuthRedirectUriTest",
        "method_name": "testDifferentCaseInHostname",
        "signature": "void testDifferentCaseInHostname()",
        "lines_hint_csv": [
          350,
          360
        ],
        "code": "    public void testDifferentCaseInHostname() throws IOException {\n        oauth.clientId(\"test-dash\");\n\n        checkRedirectUri(\"http://with-dash.example.local\", true);\n        checkRedirectUri(\"http://wiTh-dAsh.example.local\", true);\n        checkRedirectUri(\"http://with-dash.example.local/foo\", true);\n        checkRedirectUri(\"http://wiTh-dAsh.example.local/foo\", true);\n        checkRedirectUri(\"http://with-dash.example.local/foo\", true);\n        checkRedirectUri(\"http://wiTh-dAsh.example.local/foo\", true);\n        checkRedirectUri(\"http://wiTh-dAsh.example.local/Foo\", false);\n        checkRedirectUri(\"http://wiTh-dAsh.example.local/foO\", false);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          350,
          361
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RPInitiatedLogoutTest.java",
        "class_name": "RPInitiatedLogoutTest",
        "method_name": "logoutSessionWhenLoggedOutByAdmin",
        "signature": "void logoutSessionWhenLoggedOutByAdmin()",
        "lines_hint_csv": [
          309,
          332
        ],
        "code": "    public void logoutSessionWhenLoggedOutByAdmin() {\n        OAuthClient.AccessTokenResponse tokenResponse = loginUser();\n        String sessionId = tokenResponse.getSessionState();\n        String idTokenString = tokenResponse.getIdToken();\n\n        adminClient.realm(\"test\").logoutAll();\n        MatcherAssert.assertThat(false, is(isSessionActive(sessionId)));\n\n        // Try logout even if user already logged-out by admin. Should redirect back to the application, but no logout-event should be triggered\n        String logoutUrl = oauth.getLogoutUrl().postLogoutRedirectUri(APP_REDIRECT_URI).idTokenHint(idTokenString).build();\n        driver.navigate().to(logoutUrl);\n        events.assertEmpty();\n        assertCurrentUrlEquals(APP_REDIRECT_URI);\n\n        // Login again in the browser. Ensure to use newest idTokenHint after logout\n        tokenResponse = loginUser();\n        String sessionId2 = tokenResponse.getSessionState();\n        idTokenString = tokenResponse.getIdToken();\n        assertNotEquals(sessionId, sessionId2);\n        logoutUrl = oauth.getLogoutUrl().postLogoutRedirectUri(APP_REDIRECT_URI).idTokenHint(idTokenString).build();\n\n        driver.navigate().to(logoutUrl);\n        events.expectLogout(sessionId2).detail(Details.REDIRECT_URI, APP_REDIRECT_URI).assertEvent();\n        MatcherAssert.assertThat(false, is(isSessionActive(sessionId2)));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          309,
          333
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RPInitiatedLogoutTest.java",
        "class_name": "RPInitiatedLogoutTest",
        "method_name": "logoutWithValidIdTokenWhenLoggedOutByAdmin",
        "signature": "void logoutWithValidIdTokenWhenLoggedOutByAdmin()",
        "lines_hint_csv": [
          386,
          405
        ],
        "code": "    public void logoutWithValidIdTokenWhenLoggedOutByAdmin() throws Exception {\n        OAuthClient.AccessTokenResponse tokenResponse = loginUser();\n        String idTokenString = tokenResponse.getIdToken();\n\n        adminClient.realm(\"test\").logoutAll();\n\n        // Logout with HTTP client. Logout should succeed with user already logged out, see KEYCLOAK-3399. But no logout event should be present\n        String logoutUrl = oauth.getLogoutUrl()\n                .idTokenHint(idTokenString)\n                .postLogoutRedirectUri(APP_REDIRECT_URI)\n                .build();\n\n        try (CloseableHttpClient c = HttpClientBuilder.create().disableRedirectHandling().build();\n             CloseableHttpResponse response = c.execute(new HttpGet(logoutUrl))) {\n            assertThat(response, Matchers.statusCodeIsHC(Response.Status.FOUND));\n            assertThat(response.getFirstHeader(HttpHeaders.LOCATION).getValue(), is(APP_REDIRECT_URI));\n        }\n        events.assertEmpty();\n\n        MatcherAssert.assertThat(false, is(isSessionActive(tokenResponse.getSessionState())));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          386,
          406
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RPInitiatedLogoutTest.java",
        "class_name": "RPInitiatedLogoutTest",
        "method_name": "logoutRedirectWithIdTokenHintPointToDifferentSession",
        "signature": "void logoutRedirectWithIdTokenHintPointToDifferentSession()",
        "lines_hint_csv": [
          212,
          242
        ],
        "code": "    public void logoutRedirectWithIdTokenHintPointToDifferentSession() {\n        OAuthClient.AccessTokenResponse tokenResponse = loginUser();\n        String sessionId = tokenResponse.getSessionState();\n\n        String redirectUri = APP_REDIRECT_URI + \"?logout\";\n\n        String idTokenString = tokenResponse.getIdToken();\n\n        String logoutUrl = oauth.getLogoutUrl().postLogoutRedirectUri(redirectUri).idTokenHint(idTokenString).build();\n        driver.navigate().to(logoutUrl);\n\n        events.expectLogout(sessionId).detail(Details.REDIRECT_URI, redirectUri).assertEvent();\n        MatcherAssert.assertThat(false, is(isSessionActive(sessionId)));\n\n        assertCurrentUrlEquals(redirectUri);\n\n        loginPage.open();\n        loginPage.login(\"test-user@localhost\", \"password\");\n        assertTrue(appPage.isCurrent());\n\n        String sessionId2 = events.expectLogin().assertEvent().getSessionId();\n        assertNotEquals(sessionId, sessionId2);\n\n        // Using idTokenHint of the 1st session. Logout confirmation is needed in such case. Test also \"state\" parameter is included in the URL after logout\n        logoutUrl = oauth.getLogoutUrl().postLogoutRedirectUri(redirectUri).idTokenHint(idTokenString).state(\"something\").build();\n        driver.navigate().to(logoutUrl);\n        logoutConfirmPage.assertCurrent();\n        logoutConfirmPage.confirmLogout();\n        events.expectLogout(sessionId2).detail(Details.REDIRECT_URI, redirectUri).assertEvent();\n        MatcherAssert.assertThat(false, is(isSessionActive(sessionId2)));\n        assertCurrentUrlEquals(redirectUri + \"&state=something\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          212,
          243
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RPInitiatedLogoutTest.java",
        "class_name": "RPInitiatedLogoutTest",
        "method_name": "testIncorrectChangingParameters",
        "signature": "void testIncorrectChangingParameters()",
        "lines_hint_csv": [
          913,
          934
        ],
        "code": "    public void testIncorrectChangingParameters() throws IOException {\n        OAuthClient.AccessTokenResponse tokenResponse = loginUser();\n\n        // Display the logout page. Then change the localization to Czech and logout\n        driver.navigate().to(oauth.getLogoutUrl().uiLocales(\"de\").build());\n\n        Assert.assertEquals(\"Abmelden\", PageUtils.getPageTitle(driver)); // Logging out\n        logoutConfirmPage.openLanguage(\"English\");\n\n        // Try to manually change value of parameter tab_id to some incorrect value. Error should be shown in this case\n        String currentUrl = driver.getCurrentUrl();\n        String changedUrl = UriBuilder.fromUri(currentUrl)\n                .replaceQueryParam(Constants.TAB_ID, \"invalid\")\n                .build().toString();\n\n        driver.navigate().to(changedUrl);\n        WaitUtils.waitForPageToLoad();\n\n        errorPage.assertCurrent();\n        Assert.assertEquals(\"Logout failed\", errorPage.getError());\n\n        events.expectLogoutError(Errors.SESSION_EXPIRED).assertEvent();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          913,
          935
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RPInitiatedLogoutTest.java",
        "class_name": "RPInitiatedLogoutTest",
        "method_name": "logoutWithExpiredIdToken",
        "signature": "void logoutWithExpiredIdToken()",
        "lines_hint_csv": [
          363,
          382
        ],
        "code": "    public void logoutWithExpiredIdToken() throws Exception {\n        OAuthClient.AccessTokenResponse tokenResponse = loginUser();\n        String idTokenString = tokenResponse.getIdToken();\n\n        // Logout should succeed with expired ID token, see KEYCLOAK-3399\n        setTimeOffset(60 * 60 * 24);\n\n        String logoutUrl = oauth.getLogoutUrl()\n                .idTokenHint(idTokenString)\n                .postLogoutRedirectUri(APP_REDIRECT_URI)\n                .build();\n\n        try (CloseableHttpClient c = HttpClientBuilder.create().disableRedirectHandling().build();\n             CloseableHttpResponse response = c.execute(new HttpGet(logoutUrl))) {\n            assertThat(response, Matchers.statusCodeIsHC(Response.Status.FOUND));\n            assertThat(response.getFirstHeader(HttpHeaders.LOCATION).getValue(), is(APP_REDIRECT_URI));\n        }\n        events.assertEmpty();\n\n        MatcherAssert.assertThat(false, is(isSessionActive(tokenResponse.getSessionState())));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          363,
          383
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RPInitiatedLogoutTest.java",
        "class_name": "RPInitiatedLogoutTest",
        "method_name": "logoutWithExpiredSession",
        "signature": "void logoutWithExpiredSession()",
        "lines_hint_csv": [
          247,
          269
        ],
        "code": "    public void logoutWithExpiredSession() throws Exception {\n        try (AutoCloseable c = new RealmAttributeUpdater(adminClient.realm(\"test\"))\n                .updateWith(r -> r.setSsoSessionMaxLifespan(20))\n                .update()) {\n\n            OAuthClient.AccessTokenResponse tokenResponse = loginUser();\n            String idTokenString = tokenResponse.getIdToken();\n\n            // expire online user session\n            setTimeOffset(9999);\n\n            String logoutUrl = oauth.getLogoutUrl().postLogoutRedirectUri(APP_REDIRECT_URI).idTokenHint(idTokenString).build();\n            driver.navigate().to(logoutUrl);\n\n            // should not throw an internal server error. But no logout event is sent as nothing was logged-out\n            appPage.assertCurrent();\n            events.assertEmpty();\n            MatcherAssert.assertThat(false, is(isSessionActive(tokenResponse.getSessionState())));\n\n            // check if the back channel logout succeeded\n            driver.navigate().to(oauth.getLoginFormUrl());\n            WaitUtils.waitForPageToLoad();\n            loginPage.assertCurrent();\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          247,
          271
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RefreshTokenTest.java",
        "class_name": "RefreshTokenTest",
        "method_name": "tokenRefreshWithAccessTokenShouldReturnIdTokenWithAccessTokenHash",
        "signature": "void tokenRefreshWithAccessTokenShouldReturnIdTokenWithAccessTokenHash()",
        "lines_hint_csv": [
          297,
          312
        ],
        "code": "    public void tokenRefreshWithAccessTokenShouldReturnIdTokenWithAccessTokenHash() {\n        oauth.doLogin(\"test-user@localhost\", \"password\");\n\n        String code = oauth.getCurrentQuery().get(OAuth2Constants.CODE);\n\n        OAuthClient.AccessTokenResponse tokenResponse = oauth.doAccessTokenRequest(code, \"password\");\n        String refreshToken = tokenResponse.getRefreshToken();\n\n        setTimeOffset(2);\n        try {\n            OAuthClient.AccessTokenResponse response = oauth.doRefreshTokenRequest(refreshToken, \"password\");\n            Assert.assertEquals(200, response.getStatusCode());\n            IDToken idToken = oauth.verifyToken(response.getIdToken());\n            Assert.assertNotNull(\"AccessTokenHash should not be null after token refresh\", idToken.getAccessTokenHash());\n        } finally {\n            setTimeOffset(0);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          297,
          314
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/RefreshTokenTest.java",
        "class_name": "RefreshTokenTest",
        "method_name": "refreshTokenReuseTokenWithRefreshTokensRevokedAfterSingleReuse",
        "signature": "void refreshTokenReuseTokenWithRefreshTokensRevokedAfterSingleReuse()",
        "lines_hint_csv": [
          401,
          473
        ],
        "code": "    public void refreshTokenReuseTokenWithRefreshTokensRevokedAfterSingleReuse() throws Exception {\n        try {\n            RealmManager.realm(adminClient.realm(\"test\"))\n                    .revokeRefreshToken(true)\n                    .refreshTokenMaxReuse(1);\n\n            oauth.doLogin(\"test-user@localhost\", \"password\");\n\n            EventRepresentation loginEvent = events.expectLogin().assertEvent();\n\n            String sessionId = loginEvent.getSessionId();\n            String codeId = loginEvent.getDetails().get(Details.CODE_ID);\n\n            String code = oauth.getCurrentQuery().get(OAuth2Constants.CODE);\n\n            OAuthClient.AccessTokenResponse initialResponse = oauth.doAccessTokenRequest(code, \"password\");\n            RefreshToken initialRefreshToken = oauth.parseRefreshToken(initialResponse.getRefreshToken());\n\n            events.expectCodeToToken(codeId, sessionId).assertEvent();\n\n            setTimeOffset(2);\n\n            // Initial refresh.\n            OAuthClient.AccessTokenResponse responseFirstUse = oauth.doRefreshTokenRequest(initialResponse.getRefreshToken(), \"password\");\n            RefreshToken newTokenFirstUse = oauth.parseRefreshToken(responseFirstUse.getRefreshToken());\n\n            assertEquals(200, responseFirstUse.getStatusCode());\n\n            events.expectRefresh(initialRefreshToken.getId(), sessionId).assertEvent();\n\n            setTimeOffset(4);\n\n            // Second refresh (allowed).\n            OAuthClient.AccessTokenResponse responseFirstReuse = oauth.doRefreshTokenRequest(initialResponse.getRefreshToken(), \"password\");\n            RefreshToken newTokenFirstReuse = oauth.parseRefreshToken(responseFirstReuse.getRefreshToken());\n\n            assertEquals(200, responseFirstReuse.getStatusCode());\n\n            events.expectRefresh(initialRefreshToken.getId(), sessionId).assertEvent();\n\n            setTimeOffset(6);\n            // Token reused twice, became invalid.\n            OAuthClient.AccessTokenResponse responseSecondReuse = oauth.doRefreshTokenRequest(initialResponse.getRefreshToken(), \"password\");\n\n            assertEquals(400, responseSecondReuse.getStatusCode());\n\n            events.expectRefresh(initialRefreshToken.getId(), sessionId).removeDetail(Details.TOKEN_ID)\n                    .removeDetail(Details.UPDATED_REFRESH_TOKEN_ID).error(\"invalid_token\").assertEvent();\n\n            setTimeOffset(8);\n            // Refresh token from first use became invalid.\n            OAuthClient.AccessTokenResponse responseUseOfInvalidatedRefreshToken =\n                    oauth.doRefreshTokenRequest(responseFirstUse.getRefreshToken(), \"password\");\n\n            assertEquals(400, responseUseOfInvalidatedRefreshToken.getStatusCode());\n\n            events.expectRefresh(newTokenFirstUse.getId(), sessionId).removeDetail(Details.TOKEN_ID)\n                    .removeDetail(Details.UPDATED_REFRESH_TOKEN_ID).error(\"invalid_token\").assertEvent();\n\n            setTimeOffset(10);\n            // Refresh token from reuse is not valid. Client session was invalidated\n            OAuthClient.AccessTokenResponse responseUseOfValidRefreshToken =\n                    oauth.doRefreshTokenRequest(responseFirstReuse.getRefreshToken(), \"password\");\n\n            assertEquals(400, responseUseOfValidRefreshToken.getStatusCode());\n\n            events.expectRefresh(newTokenFirstReuse.getId(), sessionId).removeDetail(Details.TOKEN_ID)\n                    .removeDetail(Details.UPDATED_REFRESH_TOKEN_ID).error(\"invalid_token\").assertEvent();\n        } finally {\n            setTimeOffset(0);\n            RealmManager.realm(adminClient.realm(\"test\"))\n                    .refreshTokenMaxReuse(0)\n                    .revokeRefreshToken(false);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          401,
          475
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-2712",
    "project_slug": "eclipse-ee4j__glassfish_CVE-2022-2712_6.2.5",
    "buggy_commit_id": "0159b68b362c7f4be78d1fa75aeaf2ec0b997f1d",
    "github_url": "https://github.com/eclipse-ee4j/glassfish",
    "nvd_metadata": {
      "description": "In Eclipse GlassFish versions 5.1.0 to 6.2.5, there is a vulnerability in relative path traversal because it does not filter request path starting with './'. Successful exploitation could allow an remote unauthenticated attacker to access critical data, such as configuration files and deployed application source code.",
      "published_date": "2023-01-27T10:15:09.033",
      "cvss_v3_score": 6.5,
      "severity": "MEDIUM"
    },
    "code_snippets": []
  },
  {
    "cve_id": "CVE-2023-24057",
    "project_slug": "hapifhir__org.hl7.fhir.core_CVE-2023-24057_5.6.91",
    "buggy_commit_id": "7b22d0355b1b12448e50b9cbfe2a8ae63f2ee828",
    "github_url": "https://github.com/hapifhir/org.hl7.fhir.core",
    "nvd_metadata": {
      "description": "HL7 (Health Level 7) FHIR Core Libraries before 5.6.92 allow attackers to extract files into arbitrary directories via directory traversal from a crafted ZIP or TGZ archive (for a prepackaged terminology cache, NPM package, or comparison archive).",
      "published_date": "2023-01-26T21:18:15.960",
      "cvss_v3_score": 8.1,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "org.hl7.fhir.convertors/src/main/java/org/hl7/fhir/convertors/misc/NpmPackageVersionConverter.java",
        "class_name": "NpmPackageVersionConverter",
        "method_name": "execute",
        "signature": "void execute()",
        "lines_hint_csv": [
          78,
          180
        ],
        "code": "  public void execute() throws IOException {\n    GzipCompressorInputStream gzipIn;\n    try {\n      gzipIn = new GzipCompressorInputStream(new FileInputStream(source));\n    } catch (Exception e) {\n      throw new IOException(\"Error reading \" + source + \": \" + e.getMessage(), e);\n    }\n    Map<String, byte[]> content = new HashMap<>();\n\n    try (TarArchiveInputStream tarIn = new TarArchiveInputStream(gzipIn)) {\n      TarArchiveEntry entry;\n\n      while ((entry = (TarArchiveEntry) tarIn.getNextEntry()) != null) {\n        String n = entry.getName();\n        if (!entry.isDirectory()) {\n          int count;\n          byte[] data = new byte[BUFFER_SIZE];\n          ByteArrayOutputStream fos = new ByteArrayOutputStream();\n          try (BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER_SIZE)) {\n            while ((count = tarIn.read(data, 0, BUFFER_SIZE)) != -1) {\n              dest.write(data, 0, count);\n            }\n          }\n          fos.close();\n          content.put(n, fos.toByteArray());\n        }\n      }\n    }\n\n    Map<String, byte[]> output = new HashMap<>();\n    output.put(\"package/package.json\", convertPackage(content.get(\"package/package.json\")));\n    output.put(\"package/other/spec.internals\", convertSpec(content.get(\"package/other/spec.internals\")));\n\n    for (Entry<String, byte[]> e : content.entrySet()) {\n      if (!e.getKey().equals(\"package/package.json\") && !e.getKey().equals(\"package/other/spec.internals\")) {\n        byte[] cnv = e.getValue();\n        try {\n          JsonObject json = JsonParser.parseObject(e.getValue());\n          if (json.has(\"resourceType\")) {\n            cnv = convertResource(e.getKey(), e.getValue());\n          }\n        } catch (Exception ex) {\n        }\n        if (cnv != null && cnv.length > 0) {\n          output.put(e.getKey(), cnv);\n        }\n      }\n    }\n\n    TarArchiveOutputStream tar;\n    ByteArrayOutputStream OutputStream;\n    BufferedOutputStream bufferedOutputStream;\n    GzipCompressorOutputStream gzipOutputStream;\n\n    OutputStream = new ByteArrayOutputStream();\n    bufferedOutputStream = new BufferedOutputStream(OutputStream);\n    gzipOutputStream = new GzipCompressorOutputStream(bufferedOutputStream);\n    tar = new TarArchiveOutputStream(gzipOutputStream);\n\n\n    Map<String, NpmPackageIndexBuilder> indexers = new HashMap<>();\n    for (Entry<String, byte[]> e : output.entrySet()) {\n      String n = e.getKey().substring(0, e.getKey().lastIndexOf(\"/\"));\n      String s = e.getKey().substring(n.length() + 1);\n      byte[] b = e.getValue();\n      NpmPackageIndexBuilder indexer = indexers.get(n);\n      if (indexer == null) {\n        indexer = new NpmPackageIndexBuilder();\n        indexer.start();\n        indexers.put(n, indexer);\n      }\n      indexer.seeFile(s, b);\n      if (!s.equals(\".index.json\") && !s.equals(\"package.json\")) {\n        TarArchiveEntry entry = new TarArchiveEntry(e.getKey());\n        entry.setSize(b.length);\n        tar.putArchiveEntry(entry);\n        tar.write(b);\n        tar.closeArchiveEntry();\n      }\n    }\n    for (Entry<String, NpmPackageIndexBuilder> e : indexers.entrySet()) {\n      byte[] cnt = e.getValue().build().getBytes(StandardCharsets.UTF_8);\n      TarArchiveEntry entry = new TarArchiveEntry(e.getKey() + \"/.index.json\");\n      entry.setSize(cnt.length);\n      tar.putArchiveEntry(entry);\n      tar.write(cnt);\n      tar.closeArchiveEntry();\n    }\n\n    byte[] cnt = output.get(\"package/package.json\");\n    TarArchiveEntry entry = new TarArchiveEntry(\"package/package.json\");\n    entry.setSize(cnt.length);\n    tar.putArchiveEntry(entry);\n    tar.write(cnt);\n    tar.closeArchiveEntry();\n\n    tar.finish();\n    tar.close();\n    gzipOutputStream.close();\n    bufferedOutputStream.close();\n    OutputStream.close();\n    byte[] b = OutputStream.toByteArray();\n    TextFile.bytesToFile(b, dest);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          78,
          181
        ]
      },
      {
        "file_path": "org.hl7.fhir.convertors/src/main/java/org/hl7/fhir/convertors/misc/NpmPackageVersionConverter.java",
        "class_name": "NpmPackageVersionConverter",
        "method_name": "getErrors",
        "signature": "List getErrors()",
        "lines_hint_csv": [
          74,
          75
        ],
        "code": "  public List<String> getErrors() {\n    return errors;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          74,
          76
        ]
      },
      {
        "file_path": "org.hl7.fhir.convertors/src/main/java/org/hl7/fhir/convertors/misc/NpmPackageVersionConverter.java",
        "class_name": "NpmPackageVersionConverter",
        "method_name": "convertPackage",
        "signature": "byte convertPackage(byte)",
        "lines_hint_csv": [
          183,
          198
        ],
        "code": "  private byte[] convertPackage(byte[] cnt) throws IOException {\n    JsonObject json = JsonParser.parseObject(cnt);\n    currentVersion = json.getJsonArray(\"fhirVersions\").get(0).asString();\n    String name = json.asString(\"name\");\n    assert(packageId.equals(name + \".\" + vCode));\n    json.remove(\"name\");\n    json.add(\"name\", name + \".\" + vCode);\n    json.remove(\"fhirVersions\");\n    json.remove(\"dependencies\");\n    JsonArray fv = new JsonArray();\n    json.add(\"fhirVersions\", fv);\n    fv.add(version);\n    JsonObject dep = new JsonObject();\n    json.add(\"dependencies\", dep);\n    dep.add(VersionUtilities.packageForVersion(version), version);\n    return JsonParser.composeBytes(json);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          183,
          199
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/terminologies/TerminologyCacheManager.java",
        "class_name": "TerminologyCacheManager",
        "method_name": "unzip",
        "signature": "void unzip(InputStream,String)",
        "lines_hint_csv": [
          97,
          109
        ],
        "code": "  public static void unzip(InputStream is, String targetDir) throws IOException {\r\n    try (ZipInputStream zipIn = new ZipInputStream(is)) {\r\n      for (ZipEntry ze; (ze = zipIn.getNextEntry()) != null; ) {\r\n        String path = Utilities.path(targetDir, ze.getName());\r\n        if (!path.startsWith(targetDir)) {\r\n          // see: https://snyk.io/research/zip-slip-vulnerability\r\n          throw new RuntimeException(\"Entry with an illegal path: \" + ze.getName());\r\n        }\r\n        if (ze.isDirectory()) {\r\n          Utilities.createDirectory(path);\r\n        } else {\r\n          Utilities.createDirectory(Utilities.getDirectoryForFile(path));\r\n          TextFile.streamToFileNoClose(zipIn, path);\r\n        }\r\n      }\r\n    }\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          97,
          113
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/terminologies/TerminologyCacheManager.java",
        "class_name": "TerminologyCacheManager",
        "method_name": "initialize",
        "signature": "void initialize()",
        "lines_hint_csv": [
          61,
          81
        ],
        "code": "  public void initialize() throws IOException {\r\n    File f = new File(cacheFolder);\r\n    if (!f.exists()) {\r\n      Utilities.createDirectory(cacheFolder);      \r\n    }\r\n    if (!version.equals(getCacheVersion())) {\r\n      clearCache();\r\n      fillCache(\"http://tx.fhir.org/tx-cache/\"+ghOrg+\"/\"+ghRepo+\"/\"+ghBranch+\".zip\");\r\n    }\r\n    if (!version.equals(getCacheVersion())) {\r\n      clearCache();\r\n      fillCache(\"http://tx.fhir.org/tx-cache/\"+ghOrg+\"/\"+ghRepo+\"/default.zip\");\r\n    }\r\n    if (!version.equals(getCacheVersion())) {\r\n      clearCache();\r\n    }\r\n\r\n    IniFile ini = new IniFile(Utilities.path(cacheFolder, \"cache.ini\"));\r\n    ini.setStringProperty(\"cache\", \"version\", version, null);\r\n    ini.setDateProperty(\"cache\", \"last-use\", new Date(), null);\r\n    ini.save();\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          61,
          82
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/terminologies/TerminologyCacheManager.java",
        "class_name": "TerminologyCacheManager",
        "method_name": "initialize",
        "signature": "void initialize()",
        "lines_hint_csv": [
          61,
          81
        ],
        "code": "  public void initialize() throws IOException {\r\n    File f = new File(cacheFolder);\r\n    if (!f.exists()) {\r\n      Utilities.createDirectory(cacheFolder);      \r\n    }\r\n    if (!version.equals(getCacheVersion())) {\r\n      clearCache();\r\n      fillCache(\"http://tx.fhir.org/tx-cache/\"+ghOrg+\"/\"+ghRepo+\"/\"+ghBranch+\".zip\");\r\n    }\r\n    if (!version.equals(getCacheVersion())) {\r\n      clearCache();\r\n      fillCache(\"http://tx.fhir.org/tx-cache/\"+ghOrg+\"/\"+ghRepo+\"/default.zip\");\r\n    }\r\n    if (!version.equals(getCacheVersion())) {\r\n      clearCache();\r\n    }\r\n\r\n    IniFile ini = new IniFile(Utilities.path(cacheFolder, \"cache.ini\"));\r\n    ini.setStringProperty(\"cache\", \"version\", version, null);\r\n    ini.setDateProperty(\"cache\", \"last-use\", new Date(), null);\r\n    ini.save();\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          61,
          82
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/terminologies/TerminologyCacheManager.java",
        "class_name": "TerminologyCacheManager",
        "method_name": "unzip",
        "signature": "void unzip(InputStream,String)",
        "lines_hint_csv": [
          97,
          109
        ],
        "code": "  public static void unzip(InputStream is, String targetDir) throws IOException {\r\n    try (ZipInputStream zipIn = new ZipInputStream(is)) {\r\n      for (ZipEntry ze; (ze = zipIn.getNextEntry()) != null; ) {\r\n        String path = Utilities.path(targetDir, ze.getName());\r\n        if (!path.startsWith(targetDir)) {\r\n          // see: https://snyk.io/research/zip-slip-vulnerability\r\n          throw new RuntimeException(\"Entry with an illegal path: \" + ze.getName());\r\n        }\r\n        if (ze.isDirectory()) {\r\n          Utilities.createDirectory(path);\r\n        } else {\r\n          Utilities.createDirectory(Utilities.getDirectoryForFile(path));\r\n          TextFile.streamToFileNoClose(zipIn, path);\r\n        }\r\n      }\r\n    }\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          97,
          113
        ]
      },
      {
        "file_path": "org.hl7.fhir.utilities/src/main/java/org/hl7/fhir/utilities/npm/NpmPackage.java",
        "class_name": "NpmPackage",
        "method_name": "readStream",
        "signature": "void readStream(InputStream,String,boolean)",
        "lines_hint_csv": [
          394,
          443
        ],
        "code": "  public void readStream(InputStream tgz, String desc, boolean progress) throws IOException {\n    GzipCompressorInputStream gzipIn;\n    try {\n      gzipIn = new GzipCompressorInputStream(tgz);\n    } catch (Exception e) {\n      throw new IOException(\"Error reading \"+(desc == null ? \"package\" : desc)+\": \"+e.getMessage(), e);      \n    }\n    try (TarArchiveInputStream tarIn = new TarArchiveInputStream(gzipIn)) {\n      TarArchiveEntry entry;\n\n      int i = 0;\n      int c = 12;\n      while ((entry = (TarArchiveEntry) tarIn.getNextEntry()) != null) {\n        i++;\n        String n = entry.getName();\n        if (entry.isDirectory()) {\n          String dir = n.substring(0, n.length()-1);\n          if (dir.startsWith(\"package/\")) {\n            dir = dir.substring(8);\n          }\n          folders.put(dir, new NpmPackageFolder(dir));\n        } else {\n          int count;\n          byte data[] = new byte[BUFFER_SIZE];\n          ByteArrayOutputStream fos = new ByteArrayOutputStream();\n          try (BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER_SIZE)) {\n            while ((count = tarIn.read(data, 0, BUFFER_SIZE)) != -1) {\n              dest.write(data, 0, count);\n            }\n          }\n          fos.close();\n          loadFile(n, fos.toByteArray());\n        }\n        if (progress && i % 50 == 0) {\n          c++;\n          System.out.print(\".\");\n          if (c == 120) {\n            System.out.println(\"\");\n            System.out.print(\"  \");\n            c = 2;\n          }\n        }\n      }\n    } \n    try {\n      npm = JsonParser.parseObject(folders.get(\"package\").fetchFile(\"package.json\"));\n    } catch (Exception e) {\n      throw new IOException(\"Error parsing \"+(desc == null ? \"\" : desc+\"#\")+\"package/package.json: \"+e.getMessage(), e);\n    }\n    checkIndexed(desc);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          394,
          444
        ]
      },
      {
        "file_path": "org.hl7.fhir.utilities/src/main/java/org/hl7/fhir/utilities/npm/NpmPackage.java",
        "class_name": "NpmPackage",
        "method_name": "fromPackage",
        "signature": "NpmPackage fromPackage(InputStream,String)",
        "lines_hint_csv": [
          384,
          385
        ],
        "code": "  public static NpmPackage fromPackage(InputStream tgz, String desc) throws IOException {\n    return fromPackage(tgz, desc, false);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          384,
          386
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/main/java/org/hl7/fhir/validation/Scanner.java",
        "class_name": "Scanner",
        "method_name": "extractFile",
        "signature": "void extractFile(ZipInputStream,String)",
        "lines_hint_csv": [
          359,
          366
        ],
        "code": "  protected void extractFile(ZipInputStream zipIn, String filePath) throws IOException {\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));\n    byte[] bytesIn = new byte[BUFFER_SIZE];\n    int read;\n    while ((read = zipIn.read(bytesIn)) != -1) {\n      bos.write(bytesIn, 0, read);\n    }\n    bos.close();\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          359,
          367
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/main/java/org/hl7/fhir/validation/Scanner.java",
        "class_name": "Scanner",
        "method_name": "genScanOutput",
        "signature": "void genScanOutput(String,List)",
        "lines_hint_csv": [
          134,
          255
        ],
        "code": "  protected void genScanOutput(String folder, List<ScanOutputItem> items) throws IOException, FHIRException, EOperationOutcome {\n    String f = Utilities.path(folder, \"comparison.zip\");\n    download(\"http://fhir.org/archive/comparison.zip\", f);\n    unzip(f, folder);\n\n    for (int i = 0; i < items.size(); i++) {\n      items.get(i).setId(\"c\" + i);\n      genScanOutputItem(items.get(i), Utilities.path(folder, items.get(i).getId() + \".html\"));\n    }\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"<html>\");\n    b.append(\"<head>\");\n    b.append(\"<title>Implementation Guide Scan</title>\");\n    b.append(\"<link rel=\\\"stylesheet\\\" href=\\\"fhir.css\\\"/>\\r\\n\");\n    b.append(\"<style>\\r\\n\");\n    b.append(\"th \\r\\n\");\n    b.append(\"{\\r\\n\");\n    b.append(\"  vertical-align: bottom;\\r\\n\");\n    b.append(\"  text-align: center;\\r\\n\");\n    b.append(\"}\\r\\n\");\n    b.append(\"\\r\\n\");\n    b.append(\"th span\\r\\n\");\n    b.append(\"{\\r\\n\");\n    b.append(\"  -ms-writing-mode: tb-rl;\\r\\n\");\n    b.append(\"  -webkit-writing-mode: vertical-rl;\\r\\n\");\n    b.append(\"  writing-mode: vertical-rl;\\r\\n\");\n    b.append(\"  transform: rotate(180deg);\\r\\n\");\n    b.append(\"  white-space: nowrap;\\r\\n\");\n    b.append(\"}\\r\\n\");\n    b.append(\"</style>\\r\\n\");\n    b.append(\"</head>\");\n    b.append(\"<body>\");\n    b.append(\"<h2>Implementation Guide Scan</h2>\");\n\n    // organise\n    Set<String> refs = new HashSet<>();\n    Set<String> igs = new HashSet<>();\n    Map<String, Set<String>> profiles = new HashMap<>();\n    for (ScanOutputItem item : items) {\n      refs.add(item.getRef());\n      if (item.getIg() != null) {\n        igs.add(item.getIg().getUrl());\n        if (!profiles.containsKey(item.getIg().getUrl())) {\n          profiles.put(item.getIg().getUrl(), new HashSet<>());\n        }\n        if (item.getProfile() != null)\n          profiles.get(item.getIg().getUrl()).add(item.getProfile().getUrl());\n      }\n    }\n\n    b.append(\"<h2>By reference</h2>\\r\\n\");\n    b.append(\"<table class=\\\"grid\\\">\");\n    b.append(\"<tr><th></th><th></th>\");\n    for (String s : sort(igs)) {\n      ImplementationGuide ig = getContext().fetchResource(ImplementationGuide.class, s);\n      b.append(\"<th colspan=\\\"\" + Integer.toString(profiles.get(s).size() + 1) + \"\\\"><b title=\\\"\" + s + \"\\\">\" + ig.present() + \"</b></th>\");\n    }\n    b.append(\"</tr>\\r\\n\");\n    b.append(\"<tr><th><b>Source</b></th><th><span>Core Spec</span></th>\");\n    for (String s : sort(igs)) {\n      ImplementationGuide ig = getContext().fetchResource(ImplementationGuide.class, s);\n      b.append(\"<th><span>Global</span></th>\");\n      for (String sp : sort(profiles.get(s))) {\n        StructureDefinition sd = getContext().fetchResource(StructureDefinition.class, sp);\n        b.append(\"<th><b title=\\\"\" + sp + \"\\\"><span>\" + sd.present() + \"</span></b></th>\");\n      }\n    }\n    b.append(\"</tr>\\r\\n\");\n\n    for (String s : sort(refs)) {\n      b.append(\"<tr>\");\n      b.append(\"<td>\" + s + \"</td>\");\n      b.append(genOutcome(items, s, null, null));\n      for (String si : sort(igs)) {\n        ImplementationGuide ig = getContext().fetchResource(ImplementationGuide.class, si);\n        b.append(genOutcome(items, s, si, null));\n        for (String sp : sort(profiles.get(ig.getUrl()))) {\n          b.append(genOutcome(items, s, si, sp));\n        }\n      }\n      b.append(\"</tr>\\r\\n\");\n    }\n    b.append(\"</table>\\r\\n\");\n\n    b.append(\"<h2>By IG</h2>\\r\\n\");\n    b.append(\"<table class=\\\"grid\\\">\");\n    b.append(\"<tr><th></th><th></th>\");\n    for (String s : sort(refs)) {\n      b.append(\"<th><span>\" + s + \"</span></th>\");\n    }\n    b.append(\"</tr>\\r\\n\");\n    b.append(\"<tr><td></td><td>Core Spec</td>\");\n    for (String s : sort(refs)) {\n      b.append(genOutcome(items, s, null, null));\n    }\n    b.append(\"</tr>\\r\\n\");\n    for (String si : sort(igs)) {\n      b.append(\"<tr>\");\n      ImplementationGuide ig = getContext().fetchResource(ImplementationGuide.class, si);\n      b.append(\"<td><b title=\\\"\" + si + \"\\\">\" + ig.present() + \"</b></td>\");\n      b.append(\"<td>Global</td>\");\n      for (String s : sort(refs)) {\n        b.append(genOutcome(items, s, si, null));\n      }\n      b.append(\"</tr>\\r\\n\");\n\n      for (String sp : sort(profiles.get(ig.getUrl()))) {\n        b.append(\"<tr>\");\n        StructureDefinition sd = getContext().fetchResource(StructureDefinition.class, sp);\n        b.append(\"<td></td><td><b title=\\\"\" + sp + \"\\\">\" + sd.present() + \"</b></td>\");\n        for (String s : sort(refs)) {\n          b.append(genOutcome(items, s, si, sp));\n        }\n        b.append(\"</tr>\\r\\n\");\n      }\n    }\n    b.append(\"</table>\\r\\n\");\n\n    b.append(\"</body>\");\n    b.append(\"</html>\");\n    TextFile.stringToFile(b.toString(), Utilities.path(folder, \"scan.html\"));\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          134,
          256
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/main/java/org/hl7/fhir/validation/Scanner.java",
        "class_name": "Scanner",
        "method_name": "unzip",
        "signature": "void unzip(String,String)",
        "lines_hint_csv": [
          335,
          356
        ],
        "code": "  protected void unzip(String zipFilePath, String destDirectory) throws IOException {\n    File destDir = new File(destDirectory);\n    if (!destDir.exists()) {\n      destDir.mkdir();\n    }\n    ZipInputStream zipIn = new ZipInputStream(new FileInputStream(zipFilePath));\n    ZipEntry entry = zipIn.getNextEntry();\n    // iterates over entries in the zip file\n    while (entry != null) {\n      String filePath = destDirectory + File.separator + entry.getName();\n      if (!entry.isDirectory()) {\n        // if the entry is a file, extracts it\n        extractFile(zipIn, filePath);\n      } else {\n        // if the entry is a directory, make the directory\n        File dir = new File(filePath);\n        dir.mkdir();\n      }\n      zipIn.closeEntry();\n      entry = zipIn.getNextEntry();\n    }\n    zipIn.close();\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          335,
          357
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-28465",
    "project_slug": "hapifhir__org.hl7.fhir.core_CVE-2023-28465_5.6.105",
    "buggy_commit_id": "0b8e2c39841b51def04e29d3b745602517602d5b",
    "github_url": "https://github.com/hapifhir/org.hl7.fhir.core",
    "nvd_metadata": {
      "description": "The package-decompression feature in HL7 (Health Level 7) FHIR Core Libraries before 5.6.106 allows attackers to copy arbitrary files to certain directories via directory traversal, if an allowed directory name is a substring of the directory name chosen by the attacker. NOTE: this issue exists because of an incomplete fix for CVE-2023-24057.",
      "published_date": "2023-12-12T17:15:07.770",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/context/SimpleWorkerContext.java",
        "class_name": "SimpleWorkerContext",
        "method_name": "readVersionInfo",
        "signature": "void readVersionInfo(InputStream)",
        "lines_hint_csv": [
          482,
          497
        ],
        "code": "  private void readVersionInfo(InputStream stream) throws IOException, DefinitionException {\n    byte[] bytes = IOUtils.toByteArray(stream);\n    binaries.put(\"version.info\", bytes);\n\n    String[] vi = new String(bytes).split(\"\\\\r?\\\\n\");\n    for (String s : vi) {\n      if (s.startsWith(\"version=\")) {\n        if (version == null)\n        version = s.substring(8);\n        else if (!version.equals(s.substring(8))) \n          throw new DefinitionException(formatMessage(I18nConstants.VERSION_MISMATCH_THE_CONTEXT_HAS_VERSION__LOADED_AND_THE_NEW_CONTENT_BEING_LOADED_IS_VERSION_, version, s.substring(8)));\n      }\n      if (s.startsWith(\"revision=\"))\n        revision = s.substring(9);\n      if (s.startsWith(\"date=\"))\n        date = s.substring(5);\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          482,
          499
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderFormItem",
        "signature": "boolean renderFormItem(XhtmlNode,Questionnaire,QuestionnaireItemComponent,String,int)",
        "lines_hint_csv": [
          592,
          788
        ],
        "code": "  private boolean renderFormItem(XhtmlNode x, Questionnaire q, QuestionnaireItemComponent i, String pfx, int indent) throws IOException {\r\n    boolean hasExt = false;\r\n    XhtmlNode d = x.div().style(\"width: \"+Integer.toString(900-indent*10)+\"px; border-top: 1px #eeeeee solid\");\r\n    if (indent > 0) {\r\n      d.style(\"margin-left: \"+Integer.toString(10*indent)+\"px\");\r\n    }\r\n    XhtmlNode display = d.div().style(\"display: inline-block; width: \"+Integer.toString(500-indent*10)+\"px\");\r\n    XhtmlNode details = d.div().style(\"border: 1px #ccccff solid; padding: 2px; display: inline-block; background-color: #fefce7; width: 380px\");\r\n    XhtmlNode p = display.para();\r\n    if (i.getType() == QuestionnaireItemType.GROUP) {\r\n      p = p.b();\r\n    }\r\n    if (i.hasPrefix()) {\r\n      p.tx(i.getPrefix());\r\n      p.tx(\": \");\r\n    }\r\n    p.span(null, \"linkId: \"+i.getLinkId()).tx(i.getText());\r\n    if (i.getRequired()) {\r\n      p.span(\"color: red\", \"Mandatory\").tx(\"*\");\r\n    }\r\n\r\n    XhtmlNode input = null;\r\n    switch (i.getType()) {\r\n    case STRING:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"text\", i.getType().getDisplay(), 60);\r\n      break;\r\n    case ATTACHMENT:\r\n      break;\r\n    case BOOLEAN:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"checkbox\", i.getType().getDisplay(), 1);\r\n      break;\r\n    case CHOICE:\r\n    case OPENCHOICE:\r\n      input = p.select(i.getLinkId());\r\n      listOptions(q, i, input);\r\n      break;\r\n    case DATE:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"date\", i.getType().getDisplay(), 10);\r\n      break;\r\n    case DATETIME:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"datetime-local\", i.getType().getDisplay(), 25);\r\n      break;\r\n    case DECIMAL:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"number\", i.getType().getDisplay(), 15);\r\n      break;\r\n    case DISPLAY:\r\n      break;\r\n    case GROUP:\r\n      \r\n      break;\r\n    case INTEGER:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"number\", i.getType().getDisplay(), 10);\r\n      break;\r\n    case QUANTITY:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"number\", \"value\", 15);\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"unit\", \"unit\", 10);\r\n      break;\r\n    case QUESTION:\r\n      break;\r\n    case REFERENCE:\r\n      break;\r\n    case TEXT:\r\n      break;\r\n    case TIME:\r\n      break;\r\n    case URL:\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n    if (input != null) {\r\n      if (i.getReadOnly()) {\r\n        input.attribute(\"readonly\", \"1\");\r\n        input.style(\"background-color: #eeeeee\");\r\n      }\r\n    }\r\n    \r\n//  if (i.hasExtension(\"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\")) {\r\n//  String code = ToolingExtensions.readStringExtension(i,  \"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\");\r\n//  flags.addPiece(gen.new Piece(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\", null, \"Orientation: \"+code).addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"))));\r\n//}\r\n\r\n    \r\n    XhtmlNode ul = details.ul();\r\n    boolean hasFlag = false; \r\n    XhtmlNode flags = item(ul, \"Flags\");\r\n    item(ul, \"linkId\", i.getLinkId());\r\n    \r\n    if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\")) {\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\"), \"Can change the subject of the questionnaire\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-subject.png\"), \"icon\");\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/StructureDefinition/questionnaire-hidden\")) {\r\n      hasFlag = true;\r\n      flags.ah(Utilities.pathURL(context.getSpecificationLink(), \"extension-questionnaire-hidden.html\"), \"Is a hidden item\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-hidden.png\"), \"icon\");\r\n      d.style(\"background-color: #eeeeee\");\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-optionalDisplay\")) {\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-optionalDisplay\"), \"Is optional to display\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-optional.png\"), \"icon\");\r\n    }\r\n    if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\")) {\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\"), \"Is linked to an observation\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-observation.png\"), \"icon\");\r\n    }\r\n    if (i.hasExtension(\"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\")) {\r\n      CodeableConcept cc = i.getExtensionByUrl(\"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\").getValueCodeableConcept();\r\n      String code = cc.getCode(\"http://hl7.org/fhir/questionnaire-display-category\");\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-displayCategory\"), \"Category: \"+code).img(Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"), \"icon\");\r\n    }\r\n\r\n    if (i.hasMaxLength()) {\r\n      item(ul, \"Max Length\", Integer.toString(i.getMaxLength()));\r\n    }\r\n    if (i.hasDefinition()) {\r\n      genDefinitionLink(item(ul, \"Definition\"), i);      \r\n    }\r\n    if (i.hasEnableWhen()) {\r\n      item(ul, \"Enable When\", \"todo\");\r\n    }\r\n    if (i.hasAnswerValueSet()) {\r\n      XhtmlNode ans = item(ul, \"Answers\");\r\n      if (!Utilities.noString(i.getAnswerValueSet()) && i.getAnswerValueSet().startsWith(\"#\")) {\r\n        ValueSet vs = (ValueSet) q.getContained(i.getAnswerValueSet().substring(1));\r\n        if (vs == null || !vs.hasUserData(\"path\")) {\r\n          ans.tx(i.getAnswerValueSet());                    \r\n        } else {\r\n          ans.ah(vs.getUserString(\"path\")).tx(vs.present());                              \r\n        }\r\n      } else {\r\n        ValueSet vs = context.getWorker().fetchResource(ValueSet.class, i.getAnswerValueSet());\r\n        if (vs == null  || !vs.hasUserData(\"path\")) {\r\n          ans.tx(i.getAnswerValueSet());                    \r\n        } else {\r\n          ans.ah(vs.getUserString(\"path\")).tx(vs.present());                              \r\n        }             \r\n      }\r\n    }\r\n    if (i.hasAnswerOption()) {\r\n      item(ul, \"Answers\", Integer.toString(i.getAnswerOption().size())+\" \"+Utilities.pluralize(\"option\", i.getAnswerOption().size()), context.getDefinitionsTarget()+\"#item.\"+i.getLinkId());\r\n    }\r\n    if (i.hasInitial()) {\r\n      XhtmlNode vi = item(ul, \"Initial Values\");\r\n      boolean first = true;\r\n      for (QuestionnaireItemInitialComponent v : i.getInitial()) {\r\n        if (first) first = false; else vi.tx(\", \");\r\n        if (v.getValue().isPrimitive()) {\r\n          vi.tx(v.getValue().primitiveValue());\r\n        } else {\r\n          renderCoding(vi, v.getValueCoding(), true);           \r\n        }\r\n      }\r\n    }\r\n    if (!hasFlag) {\r\n      ul.remove(flags);\r\n    }\r\n//    if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n//      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n//      defn.getPieces().add(gen.new Piece(null, \"Expressions: \", null));\r\n//      Piece p = gen.new Piece(\"ul\");\r\n//      defn.getPieces().add(p);\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Initial Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Item Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Enable When\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Calculated Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Candidates\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\");\r\n//      } \r\n//    }\r\n//\r\n\r\n    int t = 1;\r\n    for (QuestionnaireItemComponent c : i.getItem()) {\r\n      hasExt = renderFormItem(x, q, c, pfx == null ? null : pfx+\".\"+Integer.toString(t), indent+1) || hasExt;\r\n      t++;\r\n    }\r\n    return hasExt; \r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          592,
          789
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderTreeItem",
        "signature": "boolean renderTreeItem(HierarchicalTableGenerator,List,Questionnaire,QuestionnaireItemComponent,boolean)",
        "lines_hint_csv": [
          232,
          386
        ],
        "code": "  private boolean renderTreeItem(HierarchicalTableGenerator gen, List<Row> rows, Questionnaire q, QuestionnaireItemComponent i, boolean hasFlags) throws IOException {\r\n    Row r = gen.new Row();\r\n    rows.add(r);\r\n    boolean hasExt = false;\r\n\r\n    r.setIcon(\"icon-q-\"+i.getType().toCode().toLowerCase()+\".png\", i.getType().getDisplay());\r\n    r.getCells().add(gen.new Cell(null, context.getDefinitionsTarget() == null ? \"\" : context.getDefinitionsTarget()+\"#item.\"+i.getLinkId(), i.getLinkId(), null, null));\r\n    String txt = (i.hasPrefix() ? i.getPrefix() + \". \" : \"\") + i.getText();\r\n    r.getCells().add(gen.new Cell(null, null, txt, null, null));\r\n    r.getCells().add(gen.new Cell(null, null, (i.getRequired() ? \"1\" : \"0\")+\"..\"+(i.getRepeats() ? \"*\" : \"1\"), null, null));\r\n    if (i.getTypeElement().hasExtension(EXT_QUESTIONNAIRE_ITEM_TYPE_ORIGINAL)) {\r\n      String t = i.getTypeElement().getExtensionString(EXT_QUESTIONNAIRE_ITEM_TYPE_ORIGINAL);\r\n      r.getCells().add(gen.new Cell(null, context.getSpecificationLink()+\"codesystem-item-type.html#item-type-\"+t, t, null, null));\r\n    } else {\r\n      r.getCells().add(gen.new Cell(null, context.getSpecificationLink()+\"codesystem-item-type.html#item-type-\"+i.getType().toCode(), i.getType().toCode(), null, null));\r\n    }\r\n\r\n    if (hasFlags) {\r\n      // flags:\r\n      Cell flags = gen.new Cell();\r\n      r.getCells().add(flags);\r\n      if (i.getReadOnly()) {\r\n        flags.addPiece(gen.new Piece(Utilities.pathURL(context.getSpecificationLink(), \"questionnaire-definitions.html#Questionnaire.item.readOnly\"), null, \"Is Readonly\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-readonly.png\"))));\r\n      }\r\n      if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\")) {\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-isSubject.html\"), null, \"Can change the subject of the questionnaire\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-subject.png\"))));\r\n      }\r\n      if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/StructureDefinition/questionnaire-hidden\")) {\r\n        flags.addPiece(gen.new Piece(getSpecLink(\"extension-questionnaire-hidden.html\"), null, \"Is a hidden item\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-hidden.png\"))));\r\n      }\r\n      if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-optionalDisplay\")) {\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-optionalDisplay.html\"), null, \"Is optional to display\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-optional.png\"))));\r\n      }\r\n      if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\")) {\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-observationLinkPeriod.html\"), null, \"Is linked to an observation\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-observation.png\"))));\r\n      }\r\n      if (i.hasExtension(\"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\")) {\r\n        String code = ToolingExtensions.readStringExtension(i,  \"http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation\");\r\n        flags.addPiece(gen.new Piece(getSpecLink(\"extension-questionnaire-choiceorientation.html\"), null, \"Orientation: \"+code).addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"))));\r\n      }\r\n      if (i.hasExtension(\"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\")) {\r\n        CodeableConcept cc = i.getExtensionByUrl(\"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\").getValueCodeableConcept();\r\n        String code = cc.getCode(\"http://hl7.org/fhir/questionnaire-display-category\");\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-displayCategory.html\"), null, \"Category: \"+code).addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"))));\r\n      }\r\n    }    \r\n    Cell defn = gen.new Cell();\r\n    r.getCells().add(defn);\r\n\r\n    if (i.hasMaxLength()) {\r\n      defn.getPieces().add(gen.new Piece(null, \"Max Length: \", null));\r\n      defn.getPieces().add(gen.new Piece(null, Integer.toString(i.getMaxLength()), null));\r\n    }\r\n    if (i.hasDefinition()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Definition: \", null));\r\n      genDefinitionLink(gen, i, defn);      \r\n    }\r\n    if (i.hasEnableWhen()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      Piece p = gen.new Piece(null, \"Enable When: \", null);\r\n      defn.getPieces().add(p);\r\n      if (i.getEnableWhen().size() == 0) {\r\n        XhtmlNode x = new XhtmlNode(NodeType.Element, \"span\");\r\n        p.getChildren().add(x);\r\n        renderEnableWhen(x, i.getEnableWhenFirstRep());        \r\n      } else {\r\n        XhtmlNode x = new XhtmlNode(NodeType.Element, \"ul\");\r\n        p.getChildren().add(x);\r\n        for (QuestionnaireItemEnableWhenComponent qi : i.getEnableWhen()) {\r\n          renderEnableWhen(x.li(), qi);\r\n        }\r\n      }\r\n    }\r\n    if (i.hasAnswerValueSet()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Value Set: \", null));\r\n      if (!Utilities.noString(i.getAnswerValueSet()) && i.getAnswerValueSet().startsWith(\"#\")) {\r\n        ValueSet vs = (ValueSet) q.getContained(i.getAnswerValueSet().substring(1));\r\n        if (vs == null) {\r\n          defn.getPieces().add(gen.new Piece(null, i.getAnswerValueSet(), null));                    \r\n        } else {\r\n          defn.getPieces().add(gen.new Piece(vs.getUserString(\"path\"), vs.present(), null));                              \r\n        }\r\n      } else {\r\n        ValueSet vs = context.getWorker().fetchResource(ValueSet.class, i.getAnswerValueSet());\r\n        if (vs == null  || !vs.hasUserData(\"path\")) {\r\n          defn.getPieces().add(gen.new Piece(null, i.getAnswerValueSet(), null));                    \r\n        } else {\r\n          defn.getPieces().add(gen.new Piece(vs.getUserString(\"path\"), vs.present(), null));                    \r\n        }             \r\n      }\r\n    }\r\n    if (i.hasAnswerOption()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Options: \", null));\r\n      if (context.getDefinitionsTarget() == null) {\r\n        // if we don't have a definitions target, we'll add them below. \r\n        defn.getPieces().add(gen.new Piece(\"#opt-item.\"+i.getLinkId(), Integer.toString(i.getAnswerOption().size())+\" \"+Utilities.pluralize(\"option\", i.getAnswerOption().size()), null));\r\n      } else {\r\n        defn.getPieces().add(gen.new Piece(context.getDefinitionsTarget()+\"#item.\"+i.getLinkId(), Integer.toString(i.getAnswerOption().size())+\" \"+Utilities.pluralize(\"option\", i.getAnswerOption().size()), null));\r\n      }\r\n    }\r\n    if (i.hasInitial()) {\r\n      for (QuestionnaireItemInitialComponent v : i.getInitial()) {\r\n        if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n        defn.getPieces().add(gen.new Piece(null, \"Initial Value: \", null));\r\n        defn.getPieces().add(gen.new Piece(null, v.getValue().fhirType(), null));\r\n        defn.getPieces().add(gen.new Piece(null, \" = \", null));\r\n        if (v.getValue().isPrimitive()) {\r\n          defn.getPieces().add(gen.new Piece(null, v.getValue().primitiveValue(), null));\r\n        } else {\r\n          renderCoding(gen, defn.getPieces(), v.getValueCoding());          \r\n        }\r\n      }\r\n    }\r\n    // still todo\r\n\r\n//\r\n//http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-choiceColumn\r\n//\r\n//http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-width\r\n//http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\r\n//http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\r\n//http://hl7.org/fhir/StructureDefinition/questionnaire-sliderStepValue\r\n    \r\n    if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Expressions: \", null));\r\n      Piece p = gen.new Piece(\"ul\");\r\n      defn.getPieces().add(p);\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Initial Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\")) {\r\n        addExpression(p, e.getValueExpression(), \"Item Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Enable When\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Calculated Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Candidates\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\");\r\n      } \r\n    }\r\n\r\n    for (QuestionnaireItemComponent c : i.getItem()) {\r\n      hasExt = renderTreeItem(gen, r.getSubRows(), q, c, hasFlags) || hasExt;\r\n    }\r\n    return hasExt;    \r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          232,
          387
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderDefinition",
        "signature": "boolean renderDefinition(XhtmlNode,Questionnaire,QuestionnaireItemComponent,List)",
        "lines_hint_csv": [
          913,
          1027
        ],
        "code": "  private boolean renderDefinition(XhtmlNode tbl, Questionnaire q, QuestionnaireItemComponent qi, List<QuestionnaireItemComponent> parents) throws IOException {\r\n    boolean ext = false;\r\n    XhtmlNode td = tbl.tr().td(\"structure\").colspan(\"2\").span(null, null).attribute(\"class\", \"self-link-parent\");\r\n    td.an(\"item.\"+qi.getLinkId());\r\n    for (QuestionnaireItemComponent p : parents) {\r\n      td.ah(\"#item.\"+p.getLinkId()).img(Utilities.path(context.getLocalPrefix(), \"icon_q_item.png\"), \"icon\");\r\n      td.tx(\" > \");\r\n    }\r\n    td.img(Utilities.path(context.getLocalPrefix(), \"icon_q_item.png\"), \"icon\");\r\n    td.tx(\" Item \");\r\n    td.b().tx(qi.getLinkId());\r\n    \r\n    // general information\r\n    defn(tbl, \"Link Id\", qi.getLinkId());\r\n    defn(tbl, \"Prefix\", qi.getPrefix());\r\n    defn(tbl, \"Text\", qi.getText());\r\n    defn(tbl, \"Type\", qi.getType().getDisplay());\r\n    defn(tbl, \"Required\", qi.getRequired(), true);\r\n    defn(tbl, \"Repeats\", qi.getRepeats(), true);\r\n    defn(tbl, \"Read Only\", qi.getReadOnly(), false);\r\n    if (ToolingExtensions.readBoolExtension(qi, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\")) {\r\n      defn(tbl, \"Subject\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\", \"This element changes who the subject of the question is\", null);\r\n    }\r\n    \r\n    // content control\r\n    defn(tbl, \"Max Length\", qi.getMaxLength());\r\n    if (qi.hasAnswerValueSet()) {\r\n      defn(tbl, \"Value Set\", qi.getDefinition(), context.getWorker().fetchResource(ValueSet.class,  qi.getAnswerValueSet()));\r\n    }\r\n    if (qi.hasAnswerOption()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(\"Allowed Answers\");\r\n      XhtmlNode ul = tr.td().ul();\r\n      for (QuestionnaireItemAnswerOptionComponent ans : qi.getAnswerOption()) {\r\n        XhtmlNode li = ul.li();\r\n        render(li, ans.getValue());\r\n        if (ans.getInitialSelected()) {\r\n          li.tx(\" (initially selected)\");\r\n        }\r\n      }      \r\n    }\r\n    if (qi.hasInitial()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(Utilities.pluralize(\"Initial Answer\", qi.getInitial().size()));\r\n      if (qi.getInitial().size() == 1) {\r\n        render(tr.td(), qi.getInitialFirstRep().getValue());\r\n      } else {\r\n        XhtmlNode ul = tr.td().ul();\r\n        for (QuestionnaireItemInitialComponent ans : qi.getInitial()) {\r\n          XhtmlNode li = ul.li();\r\n          render(li, ans.getValue());\r\n        }\r\n      }      \r\n    }\r\n\r\n    // appearance \r\n    if (qi.hasExtension(\"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\")) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().ah(\"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\").tx(\"Display Category\");\r\n      render(tr.td(), qi.getExtensionByUrl(\"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\").getValue());\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(qi, \"http://hl7.org/fhir/StructureDefinition/questionnaire-hidden\")) {\r\n      defn(tbl, \"Hidden Item\", \"http://hl7.org/fhir/StructureDefinition/questionnaire-displayCategory\", \"This item is a hidden question\", null);\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(qi, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-optionalDisplay\")) {\r\n      defn(tbl, \"Hidden Item\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-optionalDisplay\", \"This item is optional to display\", null);\r\n    }\r\n    \r\n    // formal definitions\r\n    if (qi.hasDefinition()) {\r\n      genDefinitionLink(defn(tbl, \"Definition\"), qi);\r\n    }\r\n      \r\n    if (qi.hasCode()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(Utilities.pluralize(\"Code\", qi.getCode().size()));\r\n      XhtmlNode ul = tr.td().ul();\r\n      for (Coding c : qi.getCode()) {\r\n        renderCodingWithDetails(ul.li(), c);\r\n      }\r\n    }\r\n    if (qi.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\")) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\")).tx(\"Observation Link Period\");\r\n      render(tr.td(), qi.getExtensionByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\").getValue());\r\n    }\r\n    \r\n    // dynamic management\r\n    if (qi.hasEnableWhen()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(\"Enable When\");\r\n      td = tr.td();\r\n      if (qi.getEnableWhen().size() == 1) {\r\n        renderEnableWhen(td, qi.getEnableWhen().get(0));\r\n      } else {\r\n        td.tx(qi.getEnableBehavior().getDisplay()+\" are true:\");\r\n        XhtmlNode ul = td.ul();\r\n        for (QuestionnaireItemEnableWhenComponent ew : qi.getEnableWhen()) {\r\n          renderEnableWhen(ul.li(), ew);\r\n        }\r\n      }      \r\n    }\r\n    \r\n    \r\n    // other stuff\r\n    \r\n\r\n    \r\n    List<QuestionnaireItemComponent> curr = new ArrayList<>();\r\n    curr.addAll(parents);\r\n    curr.add(qi);\r\n    for (QuestionnaireItemComponent qic : qi.getItem()) {\r\n      ext = renderDefinition(tbl, q, qic, curr) || ext;\r\n    }\r\n    return ext;\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          913,
          1028
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderRootDefinition",
        "signature": "boolean renderRootDefinition(XhtmlNode,Questionnaire,List)",
        "lines_hint_csv": [
          861,
          910
        ],
        "code": "  private boolean renderRootDefinition(XhtmlNode tbl, Questionnaire q, List<QuestionnaireItemComponent> parents) throws IOException {\r\n    boolean ext = false;\r\n    XhtmlNode td = tbl.tr().td(\"structure\").colspan(\"2\").span(null, null).attribute(\"class\", \"self-link-parent\");\r\n    td.an(q.getId());\r\n    td.img(Utilities.path(context.getLocalPrefix(), \"icon_q_root.gif\"), \"icon\");\r\n    td.tx(\" Questionnaire \");\r\n    td.b().tx(q.getId());\r\n    \r\n    // general information\r\n    defn(tbl, \"URL\", q.getUrl());\r\n    defn(tbl, \"Version\", q.getVersion());\r\n    defn(tbl, \"Name\", q.getName());\r\n    defn(tbl, \"Title\", q.getTitle());\r\n    if (q.hasDerivedFrom()) {\r\n      td = defn(tbl, \"Derived From\");\r\n      boolean first = true;\r\n      for (CanonicalType c : q.getDerivedFrom()) {\r\n        if (first) first = false; else td.tx(\", \");\r\n        td.tx(c.asStringValue()); // todo: make these a reference\r\n      }\r\n    }\r\n    defn(tbl, \"Status\", q.getStatus().getDisplay());\r\n    defn(tbl, \"Experimental\", q.getExperimental());\r\n    defn(tbl, \"Publication Date\", q.getDateElement().primitiveValue());\r\n    defn(tbl, \"Approval Date\", q.getApprovalDateElement().primitiveValue());\r\n    defn(tbl, \"Last Review Date\", q.getLastReviewDateElement().primitiveValue());\r\n    if (q.hasEffectivePeriod()) {\r\n      renderPeriod(defn(tbl, \"Effective Period\"), q.getEffectivePeriod());\r\n    }\r\n    \r\n    if (q.hasSubjectType()) {\r\n      td = defn(tbl, \"Subject Type\");\r\n      boolean first = true;\r\n      for (CodeType c : q.getSubjectType()) {\r\n        if (first) first = false; else td.tx(\", \");\r\n        td.tx(c.asStringValue());\r\n      }\r\n    }\r\n    defn(tbl, \"Description\", q.getDescription());\r\n    defn(tbl, \"Purpose\", q.getPurpose());\r\n    defn(tbl, \"Copyright\", q.getCopyright());\r\n    if (q.hasCode()) {\r\n      td = defn(tbl, Utilities.pluralize(\"Code\", q.getCode().size()));\r\n      boolean first = true;\r\n      for (Coding c : q.getCode()) {\r\n        if (first) first = false; else td.tx(\", \");\r\n        renderCodingWithDetails(td,  c);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          861,
          911
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "item",
        "signature": "XhtmlNode item(XhtmlNode,String)",
        "lines_hint_csv": [
          802,
          805
        ],
        "code": "  private XhtmlNode item(XhtmlNode ul, String name) {\r\n    XhtmlNode li = ul.li();\r\n    li.style(\"font-size: 10px\").tx(name+\": \");\r\n    return li;\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          802,
          806
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "QuestionnaireRenderer",
        "signature": "QuestionnaireRenderer(RenderingContext)",
        "lines_hint_csv": [
          43,
          44
        ],
        "code": "  public QuestionnaireRenderer(RenderingContext context) {\r\n    super(context);\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          43,
          45
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/terminologies/TerminologyCacheManager.java",
        "class_name": "TerminologyCacheManager",
        "method_name": "unzip",
        "signature": "void unzip(InputStream,String)",
        "lines_hint_csv": [
          97,
          110
        ],
        "code": "  public static void unzip(InputStream is, String targetDir) throws IOException {\r\n    try (ZipInputStream zipIn = new ZipInputStream(is)) {\r\n      for (ZipEntry ze; (ze = zipIn.getNextEntry()) != null; ) {\r\n        String path = Path.of(Utilities.path(targetDir, ze.getName())).normalize().toFile().getAbsolutePath();\r\n\r\n        if (!path.startsWith(targetDir)) {\r\n          // see: https://snyk.io/research/zip-slip-vulnerability\r\n          throw new RuntimeException(\"Entry with an illegal path: \" + ze.getName());\r\n        }\r\n        if (ze.isDirectory()) {\r\n          Utilities.createDirectory(path);\r\n        } else {\r\n          Utilities.createDirectory(Utilities.getDirectoryForFile(path));\r\n          TextFile.streamToFileNoClose(zipIn, path);\r\n        }\r\n      }\r\n    }\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          97,
          114
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/test/utils/ToolsHelper.java",
        "class_name": "ToolsHelper",
        "method_name": "getDefinitions",
        "signature": "Map getDefinitions(String)",
        "lines_hint_csv": [
          149,
          152
        ],
        "code": "\tprivate Map<String, byte[]> getDefinitions(String definitions) throws IOException, FHIRException {\n\t\tMap<String, byte[]> results = new HashMap<String, byte[]>();\n\t\treadDefinitions(results, loadDefinitions(definitions));\n\t\treturn results;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          149,
          153
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/main/java/org/hl7/fhir/r4b/test/utils/ToolsHelper.java",
        "class_name": "ToolsHelper",
        "method_name": "testRoundTrip",
        "signature": "void testRoundTrip(String,String,Collection)",
        "lines_hint_csv": [
          386,
          421
        ],
        "code": "\tpublic void testRoundTrip(String rootDir, String tmpDir, Collection<String> names) throws Throwable {\n\t\ttry {\n\t\t\tSystem.err.println(\"Round trip from \"+rootDir+\" to \"+tmpDir+\":\"+Integer.toString(names.size())+\" files\");\n\t\t\tfor (String n : names) {\n\t\t\t\tSystem.err.print(\"  \"+n);\n\t\t\t\tString source = rootDir + n + \".xml\";\n\t\t\t\t// String tmpJson = tmpDir + n + \".json\";\n\t\t\t\tString tmp = tmpDir + n.replace(File.separator, \"-\") + \".tmp\";\n\t\t\t\tString dest = tmpDir + n.replace(File.separator, \"-\") + \".java.xml\";\n\n\t\t\t\tFileInputStream in = new FileInputStream(source);\n\t\t\t\tXmlParser xp = new XmlParser();\n\t\t\t\tResource r = xp.parse(in);\n\t\t\t\tSystem.err.print(\".\");\n\t\t\t\tJsonParser jp = new JsonParser();\n\t\t\t\tFileOutputStream out = new FileOutputStream(tmp);\n\t\t\t\tjp.setOutputStyle(OutputStyle.PRETTY);\n\t\t\t\tjp.compose(out, r);\n\t\t\t\tout.close();\n\t\t\t\tr = null;\n\t\t\t\tSystem.err.print(\".\");\n\n\t\t\t\tin = new FileInputStream(tmp);\n\t\t\t\tSystem.err.print(\",\");\n\t\t\t\tr = jp.parse(in);\n\t\t\t\tSystem.err.print(\".\");\n\t\t\t\tout = new FileOutputStream(dest);\n\t\t\t\tnew XmlParser().compose(out, r, true);\n\t\t\t\tSystem.err.println(\"!\");\n\t\t\t\tout.close();\n\t\t\t\tr = null;\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\tSystem.err.println(\"Error: \"+e.getMessage());\n\t\t\tthrow e;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          386,
          423
        ]
      },
      {
        "file_path": "org.hl7.fhir.r4b/src/test/java/org/hl7/fhir/r4b/terminologies/TerminologyCacheManagerTests.java",
        "class_name": "TerminologyCacheManagerTests",
        "method_name": "testSlip2Zip",
        "signature": "void testSlip2Zip()",
        "lines_hint_csv": [
          57,
          64
        ],
        "code": "  public void testSlip2Zip() throws IOException {\n    RuntimeException thrown = Assertions.assertThrows(RuntimeException.class, () -> {\n      InputStream slipInputStream = getResourceAsInputStream( \"terminologyCacheManager\", ZIP_SLIP_2_ZIP);\n      TerminologyCacheManager.unzip( slipInputStream, tempDir.toFile().getAbsolutePath());\n      //Code under test\n    });\n    assertNotNull(thrown);\n    assertEquals(\"Entry with an illegal path: child/../../evil.txt\", thrown.getMessage());\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          57,
          65
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/context/SimpleWorkerContext.java",
        "class_name": "SimpleWorkerContext",
        "method_name": "readVersionInfo",
        "signature": "void readVersionInfo(InputStream)",
        "lines_hint_csv": [
          531,
          546
        ],
        "code": "  private void readVersionInfo(InputStream stream) throws IOException, DefinitionException {\n    byte[] bytes = IOUtils.toByteArray(stream);\n    binaries.put(\"version.info\", bytes);\n\n    String[] vi = new String(bytes).split(\"\\\\r?\\\\n\");\n    for (String s : vi) {\n      if (s.startsWith(\"version=\")) {\n        if (version == null)\n        version = s.substring(8);\n        else if (!version.equals(s.substring(8))) \n          throw new DefinitionException(formatMessage(I18nConstants.VERSION_MISMATCH_THE_CONTEXT_HAS_VERSION__LOADED_AND_THE_NEW_CONTENT_BEING_LOADED_IS_VERSION_, version, s.substring(8)));\n      }\n      if (s.startsWith(\"revision=\"))\n        revision = s.substring(9);\n      if (s.startsWith(\"date=\"))\n        date = s.substring(5);\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          531,
          548
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderDefinition",
        "signature": "boolean renderDefinition(XhtmlNode,Questionnaire,QuestionnaireItemComponent,List)",
        "lines_hint_csv": [
          916,
          1030
        ],
        "code": "  private boolean renderDefinition(XhtmlNode tbl, Questionnaire q, QuestionnaireItemComponent qi, List<QuestionnaireItemComponent> parents) throws IOException {\r\n    boolean ext = false;\r\n    XhtmlNode td = tbl.tr().td(\"structure\").colspan(\"2\").span(null, null).attribute(\"class\", \"self-link-parent\");\r\n    td.an(\"item.\"+qi.getLinkId());\r\n    for (QuestionnaireItemComponent p : parents) {\r\n      td.ah(\"#item.\"+p.getLinkId()).img(Utilities.path(context.getLocalPrefix(), \"icon_q_item.png\"), \"icon\");\r\n      td.tx(\" > \");\r\n    }\r\n    td.img(Utilities.path(context.getLocalPrefix(), \"icon_q_item.png\"), \"icon\");\r\n    td.tx(\" Item \");\r\n    td.b().tx(qi.getLinkId());\r\n    \r\n    // general information\r\n    defn(tbl, \"Link Id\", qi.getLinkId());\r\n    defn(tbl, \"Prefix\", qi.getPrefix());\r\n    defn(tbl, \"Text\", qi.getText());\r\n    defn(tbl, \"Type\", qi.getType().getDisplay());\r\n    defn(tbl, \"Required\", qi.getRequired(), true);\r\n    defn(tbl, \"Repeats\", qi.getRepeats(), true);\r\n    defn(tbl, \"Read Only\", qi.getReadOnly(), false);\r\n    if (ToolingExtensions.readBoolExtension(qi, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\")) {\r\n      defn(tbl, \"Subject\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\", \"This element changes who the subject of the question is\", null);\r\n    }\r\n    \r\n    // content control\r\n    defn(tbl, \"Max Length\", qi.getMaxLength());\r\n    if (qi.hasAnswerValueSet()) {\r\n      defn(tbl, \"Value Set\", qi.getDefinition(), context.getWorker().fetchResource(ValueSet.class,  qi.getAnswerValueSet(), q));\r\n    }\r\n    if (qi.hasAnswerOption()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(\"Allowed Answers\");\r\n      XhtmlNode ul = tr.td().ul();\r\n      for (QuestionnaireItemAnswerOptionComponent ans : qi.getAnswerOption()) {\r\n        XhtmlNode li = ul.li();\r\n        render(li, ans.getValue());\r\n        if (ans.getInitialSelected()) {\r\n          li.tx(\" (initially selected)\");\r\n        }\r\n      }      \r\n    }\r\n    if (qi.hasInitial()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(Utilities.pluralize(\"Initial Answer\", qi.getInitial().size()));\r\n      if (qi.getInitial().size() == 1) {\r\n        render(tr.td(), qi.getInitialFirstRep().getValue());\r\n      } else {\r\n        XhtmlNode ul = tr.td().ul();\r\n        for (QuestionnaireItemInitialComponent ans : qi.getInitial()) {\r\n          XhtmlNode li = ul.li();\r\n          render(li, ans.getValue());\r\n        }\r\n      }      \r\n    }\r\n\r\n    // appearance \r\n    if (qi.hasExtension(ToolingExtensions.EXT_Q_DISPLAY_CAT)) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().ah(ToolingExtensions.EXT_Q_DISPLAY_CAT).tx(\"Display Category\");\r\n      render(tr.td(), qi.getExtensionByUrl(ToolingExtensions.EXT_Q_DISPLAY_CAT).getValue());\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(qi, ToolingExtensions.EXT_Q_HIDDEN)) {\r\n      defn(tbl, \"Hidden Item\", ToolingExtensions.EXT_Q_DISPLAY_CAT, \"This item is a hidden question\", null);\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(qi, ToolingExtensions.EXT_Q_OTP_DISP)) {\r\n      defn(tbl, \"Hidden Item\", ToolingExtensions.EXT_Q_OTP_DISP, \"This item is optional to display\", null);\r\n    }\r\n    \r\n    // formal definitions\r\n    if (qi.hasDefinition()) {\r\n      genDefinitionLink(defn(tbl, \"Definition\"), qi, q);\r\n    }\r\n      \r\n    if (qi.hasCode()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(Utilities.pluralize(\"Code\", qi.getCode().size()));\r\n      XhtmlNode ul = tr.td().ul();\r\n      for (Coding c : qi.getCode()) {\r\n        renderCodingWithDetails(ul.li(), c);\r\n      }\r\n    }\r\n    if (qi.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\")) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().ah(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\").tx(\"Observation Link Period\");\r\n      render(tr.td(), qi.getExtensionByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\").getValue());\r\n    }\r\n    \r\n    // dynamic management\r\n    if (qi.hasEnableWhen()) {\r\n      XhtmlNode tr = tbl.tr();\r\n      tr.td().tx(\"Enable When\");\r\n      td = tr.td();\r\n      if (qi.getEnableWhen().size() == 1) {\r\n        renderEnableWhen(td, qi.getEnableWhen().get(0));\r\n      } else {\r\n        td.tx(qi.getEnableBehavior().getDisplay()+\" are true:\");\r\n        XhtmlNode ul = td.ul();\r\n        for (QuestionnaireItemEnableWhenComponent ew : qi.getEnableWhen()) {\r\n          renderEnableWhen(ul.li(), ew);\r\n        }\r\n      }      \r\n    }\r\n    \r\n    \r\n    // other stuff\r\n    \r\n\r\n    \r\n    List<QuestionnaireItemComponent> curr = new ArrayList<>();\r\n    curr.addAll(parents);\r\n    curr.add(qi);\r\n    for (QuestionnaireItemComponent qic : qi.getItem()) {\r\n      ext = renderDefinition(tbl, q, qic, curr) || ext;\r\n    }\r\n    return ext;\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          916,
          1031
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "item",
        "signature": "XhtmlNode item(XhtmlNode,String)",
        "lines_hint_csv": [
          805,
          808
        ],
        "code": "  private XhtmlNode item(XhtmlNode ul, String name) {\r\n    XhtmlNode li = ul.li();\r\n    li.style(\"font-size: 10px\").tx(name+\": \");\r\n    return li;\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          805,
          809
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderFormItem",
        "signature": "boolean renderFormItem(XhtmlNode,Questionnaire,QuestionnaireItemComponent,String,int)",
        "lines_hint_csv": [
          596,
          791
        ],
        "code": "  private boolean renderFormItem(XhtmlNode x, Questionnaire q, QuestionnaireItemComponent i, String pfx, int indent) throws IOException {\r\n    boolean hasExt = false;\r\n    XhtmlNode d = x.div().style(\"width: \"+Integer.toString(900-indent*10)+\"px; border-top: 1px #eeeeee solid\");\r\n    if (indent > 0) {\r\n      d.style(\"margin-left: \"+Integer.toString(10*indent)+\"px\");\r\n    }\r\n    XhtmlNode display = d.div().style(\"display: inline-block; width: \"+Integer.toString(500-indent*10)+\"px\");\r\n    XhtmlNode details = d.div().style(\"border: 1px #ccccff solid; padding: 2px; display: inline-block; background-color: #fefce7; width: 380px\");\r\n    XhtmlNode p = display.para();\r\n    if (i.getType() == QuestionnaireItemType.GROUP) {\r\n      p = p.b();\r\n    }\r\n    if (i.hasPrefix()) {\r\n      p.tx(i.getPrefix());\r\n      p.tx(\": \");\r\n    }\r\n    p.span(null, \"linkId: \"+i.getLinkId()).tx(i.getText());\r\n    if (i.getRequired()) {\r\n      p.span(\"color: red\", \"Mandatory\").tx(\"*\");\r\n    }\r\n\r\n    XhtmlNode input = null;\r\n    switch (i.getType()) {\r\n    case STRING:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"text\", i.getType().getDisplay(), 60);\r\n      break;\r\n    case ATTACHMENT:\r\n      break;\r\n    case BOOLEAN:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"checkbox\", i.getType().getDisplay(), 1);\r\n      break;\r\n    case CODING:\r\n      input = p.select(i.getLinkId());\r\n      listOptions(q, i, input);\r\n      break;\r\n    case DATE:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"date\", i.getType().getDisplay(), 10);\r\n      break;\r\n    case DATETIME:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"datetime-local\", i.getType().getDisplay(), 25);\r\n      break;\r\n    case DECIMAL:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"number\", i.getType().getDisplay(), 15);\r\n      break;\r\n    case DISPLAY:\r\n      break;\r\n    case GROUP:\r\n      \r\n      break;\r\n    case INTEGER:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"number\", i.getType().getDisplay(), 10);\r\n      break;\r\n    case QUANTITY:\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"number\", \"value\", 15);\r\n      p.tx(\" \");\r\n      input = p.input(i.getLinkId(), \"unit\", \"unit\", 10);\r\n      break;\r\n    case QUESTION:\r\n      break;\r\n    case REFERENCE:\r\n      break;\r\n    case TEXT:\r\n      break;\r\n    case TIME:\r\n      break;\r\n    case URL:\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n    if (input != null) {\r\n      if (i.getReadOnly()) {\r\n        input.attribute(\"readonly\", \"1\");\r\n        input.style(\"background-color: #eeeeee\");\r\n      }\r\n    }\r\n    \r\n//  if (i.hasExtension(ToolingExtensions.EXT_Q_CHOICE_ORIENT)) {\r\n//  String code = ToolingExtensions.readStringExtension(i,  ToolingExtensions.EXT_Q_CHOICE_ORIENT);\r\n//  flags.addPiece(gen.new Piece(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\", null, \"Orientation: \"+code).addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"))));\r\n//}\r\n\r\n    \r\n    XhtmlNode ul = details.ul();\r\n    boolean hasFlag = false; \r\n    XhtmlNode flags = item(ul, \"Flags\");\r\n    item(ul, \"linkId\", i.getLinkId());\r\n    \r\n    if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\")) {\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\"), \"Can change the subject of the questionnaire\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-subject.png\"), \"icon\");\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(i, ToolingExtensions.EXT_Q_HIDDEN)) {\r\n      hasFlag = true;\r\n      flags.ah(Utilities.pathURL(context.getLink(KnownLinkType.SPEC), \"extension-questionnaire-hidden.html\"), \"Is a hidden item\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-hidden.png\"), \"icon\");\r\n      d.style(\"background-color: #eeeeee\");\r\n    }\r\n    if (ToolingExtensions.readBoolExtension(i, ToolingExtensions.EXT_Q_OTP_DISP)) {\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(ToolingExtensions.EXT_Q_OTP_DISP), \"Is optional to display\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-optional.png\"), \"icon\");\r\n    }\r\n    if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\")) {\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\"), \"Is linked to an observation\").img(Utilities.path(context.getLocalPrefix(), \"icon-qi-observation.png\"), \"icon\");\r\n    }\r\n    if (i.hasExtension(ToolingExtensions.EXT_Q_DISPLAY_CAT)) {\r\n      CodeableConcept cc = i.getExtensionByUrl(ToolingExtensions.EXT_Q_DISPLAY_CAT).getValueCodeableConcept();\r\n      String code = cc.getCode(\"http://hl7.org/fhir/questionnaire-display-category\");\r\n      hasFlag = true;\r\n      flags.ah(getSDCLink(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-displayCategory\"), \"Category: \"+code).img(Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"), \"icon\");\r\n    }\r\n\r\n    if (i.hasMaxLength()) {\r\n      item(ul, \"Max Length\", Integer.toString(i.getMaxLength()));\r\n    }\r\n    if (i.hasDefinition()) {\r\n      genDefinitionLink(item(ul, \"Definition\"), i, q);      \r\n    }\r\n    if (i.hasEnableWhen()) {\r\n      item(ul, \"Enable When\", \"todo\");\r\n    }\r\n    if (i.hasAnswerValueSet()) {\r\n      XhtmlNode ans = item(ul, \"Answers\");\r\n      if (!Utilities.noString(i.getAnswerValueSet()) && i.getAnswerValueSet().startsWith(\"#\")) {\r\n        ValueSet vs = (ValueSet) q.getContained(i.getAnswerValueSet().substring(1));\r\n        if (vs == null || !vs.hasUserData(\"path\")) {\r\n          ans.tx(i.getAnswerValueSet());                    \r\n        } else {\r\n          ans.ah(vs.getUserString(\"path\")).tx(vs.present());                              \r\n        }\r\n      } else {\r\n        ValueSet vs = context.getWorker().fetchResource(ValueSet.class, i.getAnswerValueSet(), q);\r\n        if (vs == null  || !vs.hasUserData(\"path\")) {\r\n          ans.tx(i.getAnswerValueSet());                    \r\n        } else {\r\n          ans.ah(vs.getUserString(\"path\")).tx(vs.present());                              \r\n        }             \r\n      }\r\n    }\r\n    if (i.hasAnswerOption()) {\r\n      item(ul, \"Answers\", Integer.toString(i.getAnswerOption().size())+\" \"+Utilities.pluralize(\"option\", i.getAnswerOption().size()), context.getDefinitionsTarget()+\"#item.\"+i.getLinkId());\r\n    }\r\n    if (i.hasInitial()) {\r\n      XhtmlNode vi = item(ul, \"Initial Values\");\r\n      boolean first = true;\r\n      for (QuestionnaireItemInitialComponent v : i.getInitial()) {\r\n        if (first) first = false; else vi.tx(\", \");\r\n        if (v.getValue().isPrimitive()) {\r\n          vi.tx(v.getValue().primitiveValue());\r\n        } else {\r\n          renderCoding(vi, v.getValueCoding(), true);           \r\n        }\r\n      }\r\n    }\r\n    if (!hasFlag) {\r\n      ul.remove(flags);\r\n    }\r\n//    if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n//      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n//      defn.getPieces().add(gen.new Piece(null, \"Expressions: \", null));\r\n//      Piece p = gen.new Piece(\"ul\");\r\n//      defn.getPieces().add(p);\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Initial Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Item Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Enable When\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Calculated Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\");\r\n//      }\r\n//      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\")) {\r\n//        addExpression(p, e.getValueExpression(), \"Candidates\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\");\r\n//      } \r\n//    }\r\n//\r\n\r\n    int t = 1;\r\n    for (QuestionnaireItemComponent c : i.getItem()) {\r\n      hasExt = renderFormItem(x, q, c, pfx == null ? null : pfx+\".\"+Integer.toString(t), indent+1) || hasExt;\r\n      t++;\r\n    }\r\n    return hasExt; \r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          596,
          792
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderTreeItem",
        "signature": "boolean renderTreeItem(HierarchicalTableGenerator,List,Questionnaire,QuestionnaireItemComponent,boolean)",
        "lines_hint_csv": [
          234,
          390
        ],
        "code": "  private boolean renderTreeItem(HierarchicalTableGenerator gen, List<Row> rows, Questionnaire q, QuestionnaireItemComponent i, boolean hasFlags) throws IOException {\r\n    Row r = gen.new Row();\r\n    rows.add(r);\r\n    boolean hasExt = false;\r\n\r\n    r.setIcon(\"icon-q-\"+i.getType().toCode().toLowerCase()+\".png\", i.getType().getDisplay());\r\n    Cell c1 = gen.new Cell(null, context.getDefinitionsTarget() == null ? \"\" : context.getDefinitionsTarget()+\"#item.\"+i.getLinkId(), i.getLinkId(), null, null);\r\n    c1.setId(\"item.\"+i.getLinkId());\r\n    r.getCells().add(c1);\r\n    String txt = (i.hasPrefix() ? i.getPrefix() + \". \" : \"\") + i.getText();\r\n    r.getCells().add(gen.new Cell(null, null, txt, null, null));\r\n    r.getCells().add(gen.new Cell(null, null, (i.getRequired() ? \"1\" : \"0\")+\"..\"+(i.getRepeats() ? \"*\" : \"1\"), null, null));\r\n    if (i.getTypeElement().hasExtension(EXT_QUESTIONNAIRE_ITEM_TYPE_ORIGINAL)) {\r\n      String t = i.getTypeElement().getExtensionString(EXT_QUESTIONNAIRE_ITEM_TYPE_ORIGINAL);\r\n      r.getCells().add(gen.new Cell(null, context.getLink(KnownLinkType.SPEC)+\"codesystem-item-type.html#item-type-\"+t, t, null, null));\r\n    } else {\r\n      r.getCells().add(gen.new Cell(null, context.getLink(KnownLinkType.SPEC)+\"codesystem-item-type.html#item-type-\"+i.getType().toCode(), i.getType().toCode(), null, null));\r\n    }\r\n\r\n    if (hasFlags) {\r\n      // flags:\r\n      Cell flags = gen.new Cell();\r\n      r.getCells().add(flags);\r\n      if (i.getReadOnly()) {\r\n        flags.addPiece(gen.new Piece(Utilities.pathURL(context.getLink(KnownLinkType.SPEC), \"questionnaire-definitions.html#Questionnaire.item.readOnly\"), null, \"Is Readonly\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-readonly.png\"))));\r\n      }\r\n      if (ToolingExtensions.readBoolExtension(i, \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-isSubject\")) {\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-isSubject.html\"), null, \"Can change the subject of the questionnaire\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-subject.png\"))));\r\n      }\r\n      if (ToolingExtensions.readBoolExtension(i, ToolingExtensions.EXT_Q_HIDDEN)) {\r\n        flags.addPiece(gen.new Piece(getSpecLink(\"extension-questionnaire-hidden.html\"), null, \"Is a hidden item\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-hidden.png\"))));\r\n      }\r\n      if (ToolingExtensions.readBoolExtension(i, ToolingExtensions.EXT_Q_OTP_DISP)) {\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-optionalDisplay.html\"), null, \"Is optional to display\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-optional.png\"))));\r\n      }\r\n      if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\")) {\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-observationLinkPeriod.html\"), null, \"Is linked to an observation\").addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-observation.png\"))));\r\n      }\r\n      if (i.hasExtension(ToolingExtensions.EXT_Q_CHOICE_ORIENT)) {\r\n        String code = ToolingExtensions.readStringExtension(i,  ToolingExtensions.EXT_Q_CHOICE_ORIENT);\r\n        flags.addPiece(gen.new Piece(getSpecLink(\"extension-questionnaire-choiceorientation.html\"), null, \"Orientation: \"+code).addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"))));\r\n      }\r\n      if (i.hasExtension(ToolingExtensions.EXT_Q_DISPLAY_CAT)) {\r\n        CodeableConcept cc = i.getExtensionByUrl(ToolingExtensions.EXT_Q_DISPLAY_CAT).getValueCodeableConcept();\r\n        String code = cc.getCode(\"http://hl7.org/fhir/questionnaire-display-category\");\r\n        flags.addPiece(gen.new Piece(getSDCLink(\"StructureDefinition-sdc-questionnaire-displayCategory.html\"), null, \"Category: \"+code).addHtml(new XhtmlNode(NodeType.Element, \"img\").attribute(\"alt\", \"icon\").attribute(\"src\", Utilities.path(context.getLocalPrefix(), \"icon-qi-\"+code+\".png\"))));\r\n      }\r\n    }    \r\n    Cell defn = gen.new Cell();\r\n    r.getCells().add(defn);\r\n\r\n    if (i.hasMaxLength()) {\r\n      defn.getPieces().add(gen.new Piece(null, \"Max Length: \", null));\r\n      defn.getPieces().add(gen.new Piece(null, Integer.toString(i.getMaxLength()), null));\r\n    }\r\n    if (i.hasDefinition()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Definition: \", null));\r\n      genDefinitionLink(gen, i, defn, q);      \r\n    }\r\n    if (i.hasEnableWhen()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      Piece p = gen.new Piece(null, \"Enable When: \", null);\r\n      defn.getPieces().add(p);\r\n      if (i.getEnableWhen().size() == 1) {\r\n        XhtmlNode x = new XhtmlNode(NodeType.Element, \"span\");\r\n        p.getChildren().add(x);\r\n        renderEnableWhen(x, i.getEnableWhenFirstRep());        \r\n      } else {\r\n        XhtmlNode x = new XhtmlNode(NodeType.Element, \"ul\");\r\n        p.getChildren().add(x);\r\n        for (QuestionnaireItemEnableWhenComponent qi : i.getEnableWhen()) {\r\n          renderEnableWhen(x.li(), qi);\r\n        }\r\n      }\r\n    }\r\n    if (i.hasAnswerValueSet()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Value Set: \", null));\r\n      if (!Utilities.noString(i.getAnswerValueSet()) && i.getAnswerValueSet().startsWith(\"#\")) {\r\n        ValueSet vs = (ValueSet) q.getContained(i.getAnswerValueSet().substring(1));\r\n        if (vs == null) {\r\n          defn.getPieces().add(gen.new Piece(null, i.getAnswerValueSet(), null));                    \r\n        } else {\r\n          defn.getPieces().add(gen.new Piece(vs.getUserString(\"path\"), vs.present(), null));                              \r\n        }\r\n      } else {\r\n        ValueSet vs = context.getWorker().fetchResource(ValueSet.class, i.getAnswerValueSet(), q);\r\n        if (vs == null  || !vs.hasUserData(\"path\")) {\r\n          defn.getPieces().add(gen.new Piece(null, i.getAnswerValueSet(), null));                    \r\n        } else {\r\n          defn.getPieces().add(gen.new Piece(vs.getUserString(\"path\"), vs.present(), null));                    \r\n        }             \r\n      }\r\n    }\r\n    if (i.hasAnswerOption()) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Options: \", null));\r\n      if (context.getDefinitionsTarget() == null) {\r\n        // if we don't have a definitions target, we'll add them below. \r\n        defn.getPieces().add(gen.new Piece(\"#opt-item.\"+i.getLinkId(), Integer.toString(i.getAnswerOption().size())+\" \"+Utilities.pluralize(\"option\", i.getAnswerOption().size()), null));\r\n      } else {\r\n        defn.getPieces().add(gen.new Piece(context.getDefinitionsTarget()+\"#item.\"+i.getLinkId(), Integer.toString(i.getAnswerOption().size())+\" \"+Utilities.pluralize(\"option\", i.getAnswerOption().size()), null));\r\n      }\r\n    }\r\n    if (i.hasInitial()) {\r\n      for (QuestionnaireItemInitialComponent v : i.getInitial()) {\r\n        if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n        defn.getPieces().add(gen.new Piece(null, \"Initial Value: \", null));\r\n        defn.getPieces().add(gen.new Piece(null, v.getValue().fhirType(), null));\r\n        defn.getPieces().add(gen.new Piece(null, \" = \", null));\r\n        if (v.getValue().isPrimitive()) {\r\n          defn.getPieces().add(gen.new Piece(null, v.getValue().primitiveValue(), null));\r\n        } else {\r\n          renderCoding(gen, defn.getPieces(), v.getValueCoding());          \r\n        }\r\n      }\r\n    }\r\n    // still todo\r\n\r\n//\r\n//http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-choiceColumn\r\n//\r\n//http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-width\r\n//http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod\r\n//http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl\r\n//http://hl7.org/fhir/StructureDefinition/questionnaire-sliderStepValue\r\n    \r\n    if (i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\") || i.hasExtension(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n      if (!defn.getPieces().isEmpty()) defn.addPiece(gen.new Piece(\"br\"));\r\n      defn.getPieces().add(gen.new Piece(null, \"Expressions: \", null));\r\n      Piece p = gen.new Piece(\"ul\");\r\n      defn.getPieces().add(p);\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Initial Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-contextExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\")) {\r\n        addExpression(p, e.getValueExpression(), \"Item Context\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-itemContext\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Enable When\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Calculated Value\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression\");\r\n      }\r\n      for (Extension e : i.getExtensionsByUrl(\"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\")) {\r\n        addExpression(p, e.getValueExpression(), \"Candidates\", \"http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-candidateExpression\");\r\n      } \r\n    }\r\n\r\n    for (QuestionnaireItemComponent c : i.getItem()) {\r\n      hasExt = renderTreeItem(gen, r.getSubRows(), q, c, hasFlags) || hasExt;\r\n    }\r\n    return hasExt;    \r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          234,
          391
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "renderRootDefinition",
        "signature": "boolean renderRootDefinition(XhtmlNode,Questionnaire,List)",
        "lines_hint_csv": [
          864,
          913
        ],
        "code": "  private boolean renderRootDefinition(XhtmlNode tbl, Questionnaire q, List<QuestionnaireItemComponent> parents) throws IOException {\r\n    boolean ext = false;\r\n    XhtmlNode td = tbl.tr().td(\"structure\").colspan(\"2\").span(null, null).attribute(\"class\", \"self-link-parent\");\r\n    td.an(q.getId());\r\n    td.img(Utilities.path(context.getLocalPrefix(), \"icon_q_root.gif\"), \"icon\");\r\n    td.tx(\" Questionnaire \");\r\n    td.b().tx(q.getId());\r\n    \r\n    // general information\r\n    defn(tbl, \"URL\", q.getUrl());\r\n    defn(tbl, \"Version\", q.getVersion());\r\n    defn(tbl, \"Name\", q.getName());\r\n    defn(tbl, \"Title\", q.getTitle());\r\n    if (q.hasDerivedFrom()) {\r\n      td = defn(tbl, \"Derived From\");\r\n      boolean first = true;\r\n      for (CanonicalType c : q.getDerivedFrom()) {\r\n        if (first) first = false; else td.tx(\", \");\r\n        td.tx(c.asStringValue()); // todo: make these a reference\r\n      }\r\n    }\r\n    defn(tbl, \"Status\", q.getStatus().getDisplay());\r\n    defn(tbl, \"Experimental\", q.getExperimental());\r\n    defn(tbl, \"Publication Date\", q.getDateElement().primitiveValue());\r\n    defn(tbl, \"Approval Date\", q.getApprovalDateElement().primitiveValue());\r\n    defn(tbl, \"Last Review Date\", q.getLastReviewDateElement().primitiveValue());\r\n    if (q.hasEffectivePeriod()) {\r\n      renderPeriod(defn(tbl, \"Effective Period\"), q.getEffectivePeriod());\r\n    }\r\n    \r\n    if (q.hasSubjectType()) {\r\n      td = defn(tbl, \"Subject Type\");\r\n      boolean first = true;\r\n      for (CodeType c : q.getSubjectType()) {\r\n        if (first) first = false; else td.tx(\", \");\r\n        td.tx(c.asStringValue());\r\n      }\r\n    }\r\n    defn(tbl, \"Description\", q.getDescription());\r\n    defn(tbl, \"Purpose\", q.getPurpose());\r\n    defn(tbl, \"Copyright\", q.getCopyright());\r\n    if (q.hasCode()) {\r\n      td = defn(tbl, Utilities.pluralize(\"Code\", q.getCode().size()));\r\n      boolean first = true;\r\n      for (Coding c : q.getCode()) {\r\n        if (first) first = false; else td.tx(\", \");\r\n        renderCodingWithDetails(td,  c);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          864,
          914
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/renderers/QuestionnaireRenderer.java",
        "class_name": "QuestionnaireRenderer",
        "method_name": "QuestionnaireRenderer",
        "signature": "QuestionnaireRenderer(RenderingContext)",
        "lines_hint_csv": [
          43,
          44
        ],
        "code": "  public QuestionnaireRenderer(RenderingContext context) {\r\n    super(context);\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          43,
          45
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/terminologies/TerminologyCacheManager.java",
        "class_name": "TerminologyCacheManager",
        "method_name": "unzip",
        "signature": "void unzip(InputStream,String)",
        "lines_hint_csv": [
          97,
          109
        ],
        "code": "  public static void unzip(InputStream is, String targetDir) throws IOException {\r\n    try (ZipInputStream zipIn = new ZipInputStream(is)) {\r\n      for (ZipEntry ze; (ze = zipIn.getNextEntry()) != null; ) {\r\n        String path = Path.of(Utilities.path(targetDir, ze.getName())).normalize().toFile().getAbsolutePath();\r\n        if (!path.startsWith(targetDir)) {\r\n          // see: https://snyk.io/research/zip-slip-vulnerability\r\n          throw new RuntimeException(\"Entry with an illegal path: \" + ze.getName());\r\n        }\r\n        if (ze.isDirectory()) {\r\n          Utilities.createDirectory(path);\r\n        } else {\r\n          Utilities.createDirectory(Utilities.getDirectoryForFile(path));\r\n          TextFile.streamToFileNoClose(zipIn, path);\r\n        }\r\n      }\r\n    }\r\n  }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          97,
          113
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/test/utils/ToolsHelper.java",
        "class_name": "ToolsHelper",
        "method_name": "testRoundTrip",
        "signature": "void testRoundTrip(String,String,Collection)",
        "lines_hint_csv": [
          386,
          421
        ],
        "code": "\tpublic void testRoundTrip(String rootDir, String tmpDir, Collection<String> names) throws Throwable {\n\t\ttry {\n\t\t\tSystem.err.println(\"Round trip from \"+rootDir+\" to \"+tmpDir+\":\"+Integer.toString(names.size())+\" files\");\n\t\t\tfor (String n : names) {\n\t\t\t\tSystem.err.print(\"  \"+n);\n\t\t\t\tString source = rootDir + n + \".xml\";\n\t\t\t\t// String tmpJson = tmpDir + n + \".json\";\n\t\t\t\tString tmp = tmpDir + n.replace(File.separator, \"-\") + \".tmp\";\n\t\t\t\tString dest = tmpDir + n.replace(File.separator, \"-\") + \".java.xml\";\n\n\t\t\t\tFileInputStream in = new FileInputStream(source);\n\t\t\t\tXmlParser xp = new XmlParser();\n\t\t\t\tResource r = xp.parse(in);\n\t\t\t\tSystem.err.print(\".\");\n\t\t\t\tJsonParser jp = new JsonParser();\n\t\t\t\tFileOutputStream out = new FileOutputStream(tmp);\n\t\t\t\tjp.setOutputStyle(OutputStyle.PRETTY);\n\t\t\t\tjp.compose(out, r);\n\t\t\t\tout.close();\n\t\t\t\tr = null;\n\t\t\t\tSystem.err.print(\".\");\n\n\t\t\t\tin = new FileInputStream(tmp);\n\t\t\t\tSystem.err.print(\",\");\n\t\t\t\tr = jp.parse(in);\n\t\t\t\tSystem.err.print(\".\");\n\t\t\t\tout = new FileOutputStream(dest);\n\t\t\t\tnew XmlParser().compose(out, r, true);\n\t\t\t\tSystem.err.println(\"!\");\n\t\t\t\tout.close();\n\t\t\t\tr = null;\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\tSystem.err.println(\"Error: \"+e.getMessage());\n\t\t\tthrow e;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          386,
          423
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/main/java/org/hl7/fhir/r5/test/utils/ToolsHelper.java",
        "class_name": "ToolsHelper",
        "method_name": "getDefinitions",
        "signature": "Map getDefinitions(String)",
        "lines_hint_csv": [
          149,
          152
        ],
        "code": "\tprivate Map<String, byte[]> getDefinitions(String definitions) throws IOException, FHIRException {\n\t\tMap<String, byte[]> results = new HashMap<String, byte[]>();\n\t\treadDefinitions(results, loadDefinitions(definitions));\n\t\treturn results;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          149,
          153
        ]
      },
      {
        "file_path": "org.hl7.fhir.r5/src/test/java/org/hl7/fhir/r5/terminologies/TerminologyCacheManagerTests.java",
        "class_name": "TerminologyCacheManagerTests",
        "method_name": "testSlip2Zip",
        "signature": "void testSlip2Zip()",
        "lines_hint_csv": [
          58,
          65
        ],
        "code": "  public void testSlip2Zip() throws IOException {\n    RuntimeException thrown = Assertions.assertThrows(RuntimeException.class, () -> {\n      InputStream slipInputStream = getResourceAsInputStream( \"terminologyCacheManager\", ZIP_SLIP_2_ZIP);\n      TerminologyCacheManager.unzip( slipInputStream, tempDir.toFile().getAbsolutePath());\n      //Code under test\n    });\n    assertNotNull(thrown);\n    assertEquals(\"Entry with an illegal path: child/../../evil.txt\", thrown.getMessage());\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          58,
          66
        ]
      },
      {
        "file_path": "org.hl7.fhir.utilities/src/main/java/org/hl7/fhir/utilities/Utilities.java",
        "class_name": "Utilities",
        "method_name": "padLeft",
        "signature": "String padLeft(String,char,int)",
        "lines_hint_csv": [
          608,
          613
        ],
        "code": "  public static String padLeft(String src, char c, int len) {\n    StringBuilder s = new StringBuilder();\n    for (int i = 0; i < len - src.length(); i++)\n      s.append(c);\n    s.append(src);\n    return s.toString();\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          608,
          614
        ]
      },
      {
        "file_path": "org.hl7.fhir.utilities/src/main/java/org/hl7/fhir/utilities/Utilities.java",
        "class_name": "Utilities",
        "method_name": "path",
        "signature": "String path(String)",
        "lines_hint_csv": [
          617,
          674
        ],
        "code": "  public static String path(String... args) throws IOException {\n    StringBuilder s = new StringBuilder();\n    boolean d = false;\n    boolean first = true;\n    for (String arg : args) {\n      if (first && arg == null)\n        continue;\n      first = false;\n      if (!d)\n        d = !noString(arg);\n      else if (!s.toString().endsWith(File.separator))\n        s.append(File.separator);\n      String a = arg;\n      if (s.length() == 0) {\n        if (\"[tmp]\".equals(a)) {\n          if (hasCTempDir()) {\n            a = C_TEMP_DIR;\n          } else if (ToolGlobalSettings.hasTempPath()) {            \n            a = ToolGlobalSettings.getTempPath();\n          } else {\n            a = System.getProperty(\"java.io.tmpdir\");\n          }\n        } else if (\"[user]\".equals(a)) {\n          a = System.getProperty(\"user.home\");\n        } else if (a.startsWith(\"[\") && a.endsWith(\"]\")) {\n          String ev = System.getenv(a.replace(\"[\", \"\").replace(\"]\", \"\"));\n          if (ev != null) {\n            a = ev;\n          } else {\n            a = \"null\";\n          }\n        }\n      }\n      a = a.replace(\"\\\\\", File.separator);\n      a = a.replace(\"/\", File.separator);\n      if (s.length() > 0 && a.startsWith(File.separator))\n        a = a.substring(File.separator.length());\n\n      while (a.startsWith(\"..\" + File.separator)) {\n        if (s.length() == 0) {\n          s = new StringBuilder(Paths.get(\".\").toAbsolutePath().normalize().toString());\n        } else {\n          String p = s.toString().substring(0, s.length() - 1);\n          if (!p.contains(File.separator)) {\n            s = new StringBuilder();\n          } else {\n            s = new StringBuilder(p.substring(0, p.lastIndexOf(File.separator)) + File.separator);\n          }\n        }\n        a = a.substring(3);\n      }\n      if (\"..\".equals(a)) {\n        int i = s.substring(0, s.length() - 1).lastIndexOf(File.separator);\n        s = new StringBuilder(s.substring(0, i + 1));\n      } else\n        s.append(a);\n    }\n    return s.toString();\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          617,
          675
        ]
      },
      {
        "file_path": "org.hl7.fhir.utilities/src/test/java/org/hl7/fhir/utilities/UtilitiesTest.java",
        "class_name": "UtilitiesTest",
        "method_name": "getJavaHomeDirectory",
        "signature": "String getJavaHomeDirectory()",
        "lines_hint_csv": [
          60,
          69
        ],
        "code": "  private String getJavaHomeDirectory() {\n    String os = SystemUtils.OS_NAME;\n    if (os.contains(OSX) || os.contains(MAC)) {\n      return OSX_JAVA_HOME;\n    } else if (os.contains(LINUX)) {\n      return LINUX_JAVA_HOME;\n    } else if (os.toUpperCase().contains(WINDOWS)) {\n      return WIN_JAVA_HOME;\n    } else {\n      throw new IllegalStateException(\"OS not recognized...cannot verify created directories.\");\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          60,
          71
        ]
      },
      {
        "file_path": "org.hl7.fhir.utilities/src/test/java/org/hl7/fhir/utilities/UtilitiesTest.java",
        "class_name": "UtilitiesTest",
        "method_name": "testDecimalRoutines",
        "signature": "void testDecimalRoutines()",
        "lines_hint_csv": [
          173,
          191
        ],
        "code": "  void testDecimalRoutines() {\n    Assertions.assertEquals(\"-0.500000\", Utilities.lowBoundaryForDecimal(\"0\", 6));\n    Assertions.assertEquals(\"0.50000000\", Utilities.lowBoundaryForDecimal(\"1\", 8));\n    Assertions.assertEquals(\"0.950000\", Utilities.lowBoundaryForDecimal(\"1.0\", 6));\n    Assertions.assertEquals(\"0.95\", Utilities.lowBoundaryForDecimal(\"1.0\", 2));\n    Assertions.assertEquals(\"-1.05000000\", Utilities.lowBoundaryForDecimal(\"-1.0\", 8));\n    Assertions.assertEquals(\"1.23\", Utilities.lowBoundaryForDecimal(\"1.234\", 2));\n    Assertions.assertEquals(\"1.57\", Utilities.lowBoundaryForDecimal(\"1.567\", 2));\n\n    Assertions.assertEquals(\"0.50000000\", Utilities.highBoundaryForDecimal(\"0\", 8));\n    Assertions.assertEquals(\"1.500000\", Utilities.highBoundaryForDecimal(\"1\", 6));\n    Assertions.assertEquals(\"1.0500000000\", Utilities.highBoundaryForDecimal(\"1.0\", 10));\n    Assertions.assertEquals(\"-0.9500\", Utilities.highBoundaryForDecimal(\"-1.0\", 4));\n\n    Assertions.assertEquals(0, Utilities.getDecimalPrecision(\"0\"));\n    Assertions.assertEquals(0, Utilities.getDecimalPrecision(\"1\"));\n    Assertions.assertEquals(1, Utilities.getDecimalPrecision(\"1.0\"));\n    Assertions.assertEquals(1, Utilities.getDecimalPrecision(\"-1.0\"));\n    Assertions.assertEquals(4, Utilities.getDecimalPrecision(\"-1.0200\"));\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          173,
          192
        ]
      },
      {
        "file_path": "org.hl7.fhir.utilities/src/test/java/org/hl7/fhir/utilities/UtilitiesTest.java",
        "class_name": "UtilitiesTest",
        "method_name": "testDateRoutines",
        "signature": "void testDateRoutines()",
        "lines_hint_csv": [
          196,
          229
        ],
        "code": "  void testDateRoutines() {\n//    Assertions.assertEquals(\"2021-01-01T00:00:00.000\", Utilities.lowBoundaryForDate(\"2021\"));\n//    Assertions.assertEquals(\"2021-04-01T00:00:00.000\", Utilities.lowBoundaryForDate(\"2021-04\"));\n//    Assertions.assertEquals(\"2020-02-01T00:00:00.000\", Utilities.lowBoundaryForDate(\"2020-02\"));\n//    Assertions.assertEquals(\"2021-04-04T00:00:00.000\", Utilities.lowBoundaryForDate(\"2021-04-04\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.000\", Utilities.lowBoundaryForDate(\"2021-04-04T21:22:23\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.245\", Utilities.lowBoundaryForDate(\"2021-04-04T21:22:23.245\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.000Z\", Utilities.lowBoundaryForDate(\"2021-04-04T21:22:23Z\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.245+10:00\", Utilities.lowBoundaryForDate(\"2021-04-04T21:22:23.245+10:00\"));\n//\n//    Assertions.assertEquals(\"2021-12-31T23:23:59.999\", Utilities.highBoundaryForDate(\"2021\"));\n//    Assertions.assertEquals(\"2021-04-30T23:23:59.999\", Utilities.highBoundaryForDate(\"2021-04\"));\n//    Assertions.assertEquals(\"2020-02-29T23:23:59.999\", Utilities.highBoundaryForDate(\"2020-02\"));\n//    Assertions.assertEquals(\"2021-04-04T23:23:59.999\", Utilities.highBoundaryForDate(\"2021-04-04\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.999\", Utilities.highBoundaryForDate(\"2021-04-04T21:22:23\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.245\", Utilities.highBoundaryForDate(\"2021-04-04T21:22:23.245\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.999Z\", Utilities.highBoundaryForDate(\"2021-04-04T21:22:23Z\"));\n//    Assertions.assertEquals(\"2021-04-04T21:22:23.245+10:00\", Utilities.highBoundaryForDate(\"2021-04-04T21:22:23.245+10:00\"));\n    \n    Assertions.assertEquals(8, Utilities.getDatePrecision(\"1900-01-01\"));\n    Assertions.assertEquals(4, Utilities.getDatePrecision(\"1900\"));\n    Assertions.assertEquals(6, Utilities.getDatePrecision(\"1900-06\"));\n    Assertions.assertEquals(14, Utilities.getDatePrecision(\"1900-06-06T14:00:00\"));\n    Assertions.assertEquals(17, Utilities.getDatePrecision(\"1900-06-06T14:00:00.000\"));\n    Assertions.assertEquals(8, Utilities.getDatePrecision(\"1900-01-01Z\"));\n    Assertions.assertEquals(4, Utilities.getDatePrecision(\"1900Z\"));\n    Assertions.assertEquals(6, Utilities.getDatePrecision(\"1900-06Z\"));\n    Assertions.assertEquals(14, Utilities.getDatePrecision(\"1900-06-06T14:00:00Z\"));\n    Assertions.assertEquals(17, Utilities.getDatePrecision(\"1900-06-06T14:00:00.000Z\"));\n    Assertions.assertEquals(8, Utilities.getDatePrecision(\"1900-01-01+10:00\"));\n    Assertions.assertEquals(4, Utilities.getDatePrecision(\"1900+10:00\"));\n    Assertions.assertEquals(6, Utilities.getDatePrecision(\"1900-06+10:00\"));\n    Assertions.assertEquals(14, Utilities.getDatePrecision(\"1900-06-06T14:00:00+10:00\"));\n    Assertions.assertEquals(17, Utilities.getDatePrecision(\"1900-06-06T14:00:00.000-10:00\"));\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          196,
          230
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/main/java/org/hl7/fhir/validation/IgLoader.java",
        "class_name": "IgLoader",
        "method_name": "readZip",
        "signature": "Map readZip(InputStream)",
        "lines_hint_csv": [
          374,
          390
        ],
        "code": "  protected Map<String, byte[]> readZip(InputStream stream) throws IOException {\n    Map<String, byte[]> res = new HashMap<>();\n    ZipInputStream zip = new ZipInputStream(stream);\n    ZipEntry ze;\n    while ((ze = zip.getNextEntry()) != null) {\n      String name = ze.getName();\n      ByteArrayOutputStream b = new ByteArrayOutputStream();\n      int n;\n      byte[] buf = new byte[1024];\n      while ((n = ((InputStream) zip).read(buf, 0, 1024)) > -1) {\n        b.write(buf, 0, n);\n      }\n      res.put(name, b.toByteArray());\n      zip.closeEntry();\n    }\n    zip.close();\n    return res;\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          374,
          391
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/main/java/org/hl7/fhir/validation/IgLoader.java",
        "class_name": "IgLoader",
        "method_name": "loadPackageForVersion",
        "signature": "String loadPackageForVersion(InputStream)",
        "lines_hint_csv": [
          393,
          394
        ],
        "code": "  private String loadPackageForVersion(InputStream stream) throws FHIRException, IOException {\n    return NpmPackage.fromPackage(stream).fhirVersion();\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          393,
          395
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/test/java/org/hl7/fhir/conversion/tests/UtilitiesXTests.java",
        "class_name": "UtilitiesXTests",
        "method_name": "findTestResource",
        "signature": "boolean findTestResource(String)",
        "lines_hint_csv": [
          479,
          489
        ],
        "code": "  public static boolean findTestResource(String... paths) throws IOException { \n    if (new File(\"../../fhir-test-cases\").exists() && isTryToLoadFromFileSystem()) {\n      String n = Utilities.path(System.getProperty(\"user.dir\"), \"..\", \"..\", \"fhir-test-cases\", Utilities.path(paths));\n      return new File(n).exists();\n    } else {\n      String classpath = (\"/org/hl7/fhir/testcases/\"+ Utilities.pathURL(paths));\n      try {\n        InputStream inputStream = UtilitiesXTests.class.getResourceAsStream(classpath);\n        return inputStream != null;\n      } catch (Throwable t) {\n        return false;\n      }\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          479,
          492
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/test/java/org/hl7/fhir/conversion/tests/UtilitiesXTests.java",
        "class_name": "UtilitiesXTests",
        "method_name": "loadTestResource",
        "signature": "String loadTestResource(String)",
        "lines_hint_csv": [
          499,
          514
        ],
        "code": "  public static String loadTestResource(String... paths) throws IOException {\n    if (new File(\"../../fhir-test-cases\").exists() && isTryToLoadFromFileSystem()) {\n      String n = Utilities.path(System.getProperty(\"user.dir\"), \"..\", \"..\", \"fhir-test-cases\", Utilities.path(paths));\n      // ok, we'll resolve this locally\n      return TextFile.fileToString(new File(n));\n    } else {\n      // resolve from the package \n      String contents;\n      String classpath = (\"/org/hl7/fhir/testcases/\"+ Utilities.pathURL(paths));\n      try (InputStream inputStream = UtilitiesXTests.class.getResourceAsStream(classpath)) {\n        if (inputStream == null) {\n          throw new IOException(\"Can't find file on classpath: \" + classpath);\n        }\n        contents = IOUtils.toString(inputStream, java.nio.charset.StandardCharsets.UTF_8);\n      }\n      return contents;\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          499,
          516
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/test/java/org/hl7/fhir/validation/IgLoaderTests.java",
        "class_name": "IgLoaderTests",
        "method_name": "testFailIfInvalidFHIRVersion",
        "signature": "void testFailIfInvalidFHIRVersion()",
        "lines_hint_csv": [
          83,
          98
        ],
        "code": "  public void testFailIfInvalidFHIRVersion() throws IOException {\n    IgLoader igLoader = Mockito.spy(new IgLoader(\n      filesystemPackageCacheManager,\n      simpleWorkerContext,\n      \"4.0.1\"\n    ));\n    Exception exception = assertThrows(FHIRException.class, () -> {\n\n      List<ImplementationGuide> igs = Collections.emptyList();\n      igLoader.loadIg(igs,\n        Collections.emptyMap(),\n        \"[0.1.2]\" + DUMMY_PATH,\n        false);\n    });\n\n    assertLinesMatch(Arrays.asList(\".*Unsupported FHIR Version.*\"), Arrays.asList(exception.getMessage()));\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          83,
          99
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/test/java/org/hl7/fhir/validation/ScannerTest.java",
        "class_name": "ScannerTest",
        "method_name": "testSlipZipWin",
        "signature": "void testSlipZipWin()",
        "lines_hint_csv": [
          81,
          88
        ],
        "code": "  public void testSlipZipWin() throws IOException {\n    RuntimeException thrown = Assertions.assertThrows(RuntimeException.class, () -> {\n      Scanner scanner = new Scanner(null,null,null,null);\n      scanner.unzip(zipSlipWinPath.toFile().getAbsolutePath(), tempDir.toFile().getAbsolutePath());\n      //Code under test\n    });\n    assertNotNull(thrown);\n    assertEquals(\"Entry with an illegal path: ../evil.txt\", thrown.getMessage());\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          81,
          89
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/test/java/org/hl7/fhir/validation/ScannerTest.java",
        "class_name": "ScannerTest",
        "method_name": "beforeAll",
        "signature": "void beforeAll()",
        "lines_hint_csv": [
          34,
          45
        ],
        "code": "  public void beforeAll() throws IOException {\n    tempDir = Files.createTempDirectory(\"scanner-zip\");\n    tempDir.resolve(\"child\").toFile().mkdir();\n    zipNormalPath = tempDir.resolve(ZIP_NORMAL_ZIP);\n    zipSlipPath = tempDir.resolve(ZIP_SLIP_ZIP);\n    zipSlip2Path = tempDir.resolve(ZIP_SLIP_2_ZIP);\n    zipSlipWinPath = tempDir.resolve(ZIP_SLIP_WIN_ZIP);\n\n    copyResourceToFile(zipNormalPath, \"scanner\", ZIP_NORMAL_ZIP);\n    copyResourceToFile(zipSlipPath, \"scanner\", ZIP_SLIP_ZIP);\n    copyResourceToFile(zipSlip2Path, \"scanner\", ZIP_SLIP_2_ZIP);\n    copyResourceToFile(zipSlipWinPath, \"scanner\", ZIP_SLIP_WIN_ZIP);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          34,
          46
        ]
      },
      {
        "file_path": "org.hl7.fhir.validation/src/test/java/org/hl7/fhir/validation/ScannerTest.java",
        "class_name": "ScannerTest",
        "method_name": "testSlipZip",
        "signature": "void testSlipZip()",
        "lines_hint_csv": [
          59,
          66
        ],
        "code": "  public void testSlipZip() throws IOException {\n    RuntimeException thrown = Assertions.assertThrows(RuntimeException.class, () -> {\n      Scanner scanner = new Scanner(null,null,null,null);\n      scanner.unzip(zipSlipPath.toFile().getAbsolutePath(), tempDir.toFile().getAbsolutePath());\n      //Code under test\n    });\n    assertNotNull(thrown);\n    assertEquals(\"Entry with an illegal path: ../evil.txt\", thrown.getMessage());\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          59,
          67
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-41044",
    "project_slug": "Graylog2__graylog2-server_CVE-2023-41044_5.1.2",
    "buggy_commit_id": "d970230b6f3ecb83e07dd43df56428d1421c40e9",
    "github_url": "https://github.com/Graylog2/graylog2-server",
    "nvd_metadata": {
      "description": "Graylog is a free and open log management platform. A partial path traversal vulnerability exists in Graylog's `Support Bundle` feature. The vulnerability is caused by incorrect user input validation in an HTTP API resource. Graylog's Support Bundle feature allows an attacker with valid Admin role credentials to download or delete files in sibling directories of the support bundle directory. The default `data_dir` in operating system packages (DEB, RPM) is set to `/var/lib/graylog-server`. The data directory for the Support Bundle feature is always `<data_dir>/support-bundle`. Due to the partial path traversal vulnerability, an attacker with valid Admin role credentials can read or delete files in directories that start with a `/var/lib/graylog-server/support-bundle` directory name. The vulnerability would allow the download or deletion of files in the following example directories: `/var/lib/graylog-server/support-bundle-test` and `/var/lib/graylog-server/support-bundlesdirectory`. For the Graylog Docker images, the `data_dir` is set to `/usr/share/graylog/data` by default. This vulnerability is fixed in Graylog version 5.1.3 and later. Users are advised to upgrade. Users unable to upgrade should block all HTTP requests to the following HTTP API endpoints by using a reverse proxy server in front of Graylog. `GET /api/system/debug/support/bundle/download/{filename}` and `DELETE /api/system/debug/support/bundle/{filename}`.\n",
      "published_date": "2023-08-31T18:15:09.187",
      "cvss_v3_score": 3.3,
      "severity": "LOW"
    },
    "code_snippets": [
      {
        "file_path": "graylog2-server/src/main/java/org/graylog2/rest/resources/system/debug/bundle/SupportBundleService.java",
        "class_name": "SupportBundleService",
        "method_name": "downloadBundle",
        "signature": "void downloadBundle(String,OutputStream)",
        "lines_hint_csv": [
          502,
          511
        ],
        "code": "    public void downloadBundle(String filename, OutputStream outputStream) throws IOException {\n        ensureFileWithinBundleDir(filename);\n\n        try {\n            final Path filePath = bundleDir.resolve(filename);\n            Files.copy(filePath, outputStream);\n        } catch (NoSuchFileException e) {\n            throw new NotFoundException(e);\n        } catch (Exception e) {\n            outputStream.close();\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          502,
          513
        ]
      },
      {
        "file_path": "graylog2-server/src/main/java/org/graylog2/rest/resources/system/debug/bundle/SupportBundleService.java",
        "class_name": "SupportBundleService",
        "method_name": "ensureFileWithinBundleDir",
        "signature": "void ensureFileWithinBundleDir(Path, String)",
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "    private void ensureFileWithinBundleDir(String filename) throws IOException {\n        if (!bundleDir.resolve(filename).toFile().getCanonicalPath().startsWith(bundleDir.toFile().getCanonicalPath())) {\n            throw new NotFoundException();\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          515,
          519
        ]
      },
      {
        "file_path": "graylog2-server/src/main/java/org/graylog2/rest/resources/system/debug/bundle/SupportBundleService.java",
        "class_name": "SupportBundleService",
        "method_name": "deleteBundle",
        "signature": "void deleteBundle(String)",
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "    public void deleteBundle(String filename) throws IOException {\n        ensureFileWithinBundleDir(filename);\n        final Path filePath = bundleDir.resolve(filename);\n        Files.delete(filePath);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          521,
          525
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-35887",
    "project_slug": "apache__mina-sshd_CVE-2023-35887_2.9.2",
    "buggy_commit_id": "fbbbb7b6af7fdf1765f297a96dfec3f198f5fd7d",
    "github_url": "https://github.com/apache/mina-sshd",
    "nvd_metadata": {
      "description": "Exposure of Sensitive Information to an Unauthorized Actor vulnerability in Apache Software Foundation Apache MINA.\n\nIn SFTP servers implemented using Apache MINA SSHD that use a RootedFileSystem, logged users may be able to discover \"exists/does not exist\" information about items outside the rooted tree via paths including parent navigation (\"..\") beyond the root, or involving symlinks.\n\nThis issue affects Apache MINA: from 1.0 before 2.10. Users are recommended to upgrade to 2.10\n",
      "published_date": "2023-07-10T16:15:53.050",
      "cvss_v3_score": 5.0,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/CliSupport.java",
        "class_name": "CliSupport",
        "method_name": "setupIoServiceFactory",
        "signature": "M setupIoServiceFactory(M,Map,PrintStream,PrintStream,String,IoConnector,SocketAddress,SocketAddress,IoConnector,SocketAddress,SocketAddress,Throwable,IoAcceptor,SocketAddress,SocketAddress,IoAcceptor,SocketAddress,SocketAddress,Throwable)",
        "lines_hint_csv": [
          99,
          168
        ],
        "code": "    public static <M extends AbstractFactoryManager> M setupIoServiceFactory(\n            M manager, PropertyResolver resolver, Level level,\n            PrintStream stdout, PrintStream stderr, String... args) {\n        BuiltinIoServiceFactoryFactories factory = resolveIoServiceFactory(stderr, args);\n        if (factory == null) {\n            return null;\n        }\n\n        manager.setIoServiceFactoryFactory(factory.create());\n\n        Logger logger = CliLogger.resolveLogger(CliSupport.class, level, stdout, stderr);\n        if (logger.isInfoEnabled()) {\n            manager.setIoServiceEventListener(createLoggingIoServiceEventListener(logger));\n            manager.addSessionListener(createLoggingSessionListener(logger));\n        }\n        return manager;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          141,
          157
        ]
      },
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/client/SshClientCliSupport.java",
        "class_name": "SshClientCliSupport",
        "method_name": "setupMacs",
        "signature": "List setupMacs(String,String,List,PrintStream)",
        "lines_hint_csv": [
          552,
          570
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/client/SshClientCliSupport.java",
        "class_name": "SshClientCliSupport",
        "method_name": "setupServerKeyVerifier",
        "signature": "ServerKeyVerifier setupServerKeyVerifier(ClientAuthenticationManager,Map,BufferedReader,PrintStream,PrintStream)",
        "lines_hint_csv": [
          418,
          455
        ],
        "code": "    public static ServerKeyVerifier setupServerKeyVerifier(\n            ClientAuthenticationManager manager, PropertyResolver resolver,\n            BufferedReader stdin, PrintStream stdout, PrintStream stderr) {\n        ServerKeyVerifier current = manager.getServerKeyVerifier();\n        if (current == null) {\n            current = ClientBuilder.DEFAULT_SERVER_KEY_VERIFIER;\n            manager.setServerKeyVerifier(current);\n        }\n\n        Map<String, ?> options = resolver.getProperties();\n        String strictValue = Objects.toString(\n                options.remove(KnownHostsServerKeyVerifier.STRICT_CHECKING_OPTION), \"true\");\n        if (!ConfigFileReaderSupport.parseBooleanValue(strictValue)) {\n            return current;\n        }\n\n        String filePath = Objects.toString(\n                options.remove(KnownHostsServerKeyVerifier.KNOWN_HOSTS_FILE_OPTION), null);\n        if (GenericUtils.isEmpty(filePath)) {\n            current = new DefaultKnownHostsServerKeyVerifier(current);\n        } else { // if user specifies a different location than default be lenient\n            current = new DefaultKnownHostsServerKeyVerifier(current, false, Paths.get(filePath));\n        }\n\n        ((KnownHostsServerKeyVerifier) current).setModifiedServerKeyAcceptor(\n                (clientSession, remoteAddress, entry, expected, actual) -> {\n                    stderr.append(\"WARNING: Mismatched keys presented by \").append(Objects.toString(remoteAddress))\n                            .append(\" for entry=\").println(entry);\n                    stderr.append(\"    \").append(\"Expected=\").append(KeyUtils.getKeyType(expected))\n                            .append('-').println(KeyUtils.getFingerPrint(expected));\n                    stderr.append(\"    \").append(\"Actual=\").append(KeyUtils.getKeyType(actual))\n                            .append('-').println(KeyUtils.getFingerPrint(actual));\n                    stderr.flush(); // just making sure\n\n                    stdout.append(\"Accept key and update known hosts: y/[N]\");\n                    stdout.flush(); // just making sure\n\n                    String ans = GenericUtils.trimToEmpty(stdin.readLine());\n                    return (GenericUtils.length(ans) > 0)\n                            && (Character.toLowerCase(ans.charAt(0)) == 'y');\n                });\n\n        manager.setServerKeyVerifier(current);\n        return current;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          599,
          643
        ]
      },
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/client/SshClientCliSupport.java",
        "class_name": "SshClientCliSupport",
        "method_name": "setupClientSession",
        "signature": "ClientSession setupClientSession(String,BufferedReader,PrintStream,PrintStream,String)",
        "lines_hint_csv": [
          107,
          256
        ],
        "code": "    public static ClientSession setupClientSession(\n            String portOption, BufferedReader stdin, Level level,\n            PrintStream stdout, PrintStream stderr, String... args)\n            throws Exception {\n        int port = -1;\n        String host = null;\n        String login = null;\n        String proxyJump = null;\n        String password = null;\n        boolean error = false;\n        List<Path> identities = new ArrayList<>();\n        Map<String, Object> options = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        List<NamedFactory<Cipher>> ciphers = null;\n        List<NamedFactory<Mac>> macs = null;\n        List<NamedFactory<Compression>> compressions = null;\n        int numArgs = GenericUtils.length(args);\n        for (int i = 0; (!error) && (i < numArgs); i++) {\n            String argName = args[i];\n            String argVal = null;\n            if (isArgumentedOption(portOption, argName)) {\n                i++;\n                if (i >= numArgs) {\n                    error = CliLogger.showError(stderr, \"option requires an argument: \" + argName);\n                    break;\n                }\n\n                argVal = args[i];\n            }\n\n            if (portOption.equals(argName)) {\n                if (port > 0) {\n                    error = CliLogger.showError(stderr, argName + \" option value re-specified: \" + port);\n                    break;\n                }\n\n                port = Integer.parseInt(argVal);\n                if (port <= 0) {\n                    error = CliLogger.showError(stderr, \"Bad option value for \" + argName + \": \" + port);\n                    break;\n                }\n            } else if (\"-J\".equals(argName)) {\n                if (proxyJump != null) {\n                    error = CliLogger.showError(stderr, argName + \" option value re-specified: \" + proxyJump);\n                    break;\n                }\n                proxyJump = argVal;\n            } else if (\"-w\".equals(argName)) {\n                if (GenericUtils.length(password) > 0) {\n                    error = CliLogger.showError(stderr, argName + \" option value re-specified: \" + password);\n                    break;\n                }\n                password = argVal;\n            } else if (\"-c\".equals(argName)) {\n                ciphers = setupCiphers(argName, argVal, ciphers, stderr);\n                if (GenericUtils.isEmpty(ciphers)) {\n                    error = true;\n                    break;\n                }\n            } else if (\"-m\".equals(argName)) {\n                macs = setupMacs(argName, argVal, macs, stderr);\n                if (GenericUtils.isEmpty(macs)) {\n                    error = true;\n                    break;\n                }\n            } else if (\"-i\".equals(argName)) {\n                Path idFile = resolveIdentityFile(argVal);\n                identities.add(idFile);\n            } else if (\"-C\".equals(argName)) {\n                compressions = setupCompressions(argName, argVal, compressions, stderr);\n                if (GenericUtils.isEmpty(compressions)) {\n                    error = true;\n                    break;\n                }\n            } else if (\"-o\".equals(argName)) {\n                String opt = argVal;\n                int idx = opt.indexOf('=');\n                if (idx <= 0) {\n                    error = CliLogger.showError(stderr, \"bad syntax for option: \" + opt);\n                    break;\n                }\n\n                String optName = opt.substring(0, idx);\n                String optValue = opt.substring(idx + 1);\n                if (HostConfigEntry.IDENTITY_FILE_CONFIG_PROP.equals(optName)) {\n                    Path idFile = resolveIdentityFile(optValue);\n                    identities.add(idFile);\n                } else {\n                    options.merge(optName, optValue, (a, b) -> a + \",\" + b);\n                }\n            } else if (\"-l\".equals(argName)) {\n                if (login != null) {\n                    error = CliLogger.showError(stderr, argName + \" option value re-specified: \" + port);\n                    break;\n                }\n\n                login = argVal;\n            } else if (argName.charAt(0) != '-') {\n                if (host != null) { // assume part of a command following it\n                    break;\n                }\n\n                host = argName;\n                int pos = host.indexOf('@'); // check if user@host\n                if (pos > 0) {\n                    if (login == null) {\n                        login = host.substring(0, pos);\n                        host = host.substring(pos + 1);\n                    } else {\n                        error = CliLogger.showError(stderr, \"Login already specified using -l option (\" + login + \"): \" + host);\n                        break;\n                    }\n                }\n            }\n        }\n\n        if ((!error) && GenericUtils.isEmpty(host)) {\n            error = CliLogger.showError(stderr, \"Hostname not specified\");\n        }\n\n        if (error) {\n            return null;\n        }\n\n        PropertyResolver resolver = PropertyResolverUtils.toPropertyResolver(options);\n        SshClient client = setupClient(\n                resolver, ciphers, macs, compressions, identities,\n                stdin, stdout, stderr, level, args);\n        if (client == null) {\n            return null;\n        }\n\n        try {\n            client.start();\n\n            if (login == null) {\n                login = OsUtils.getCurrentUser();\n            }\n\n            port = SshConstants.TO_EFFECTIVE_PORT.applyAsInt(port);\n\n            HostConfigEntry entry = resolveHost(client, login, host, port, proxyJump);\n            ClientSession session = client.connect(entry, null, null)\n                    .verify(CliClientModuleProperties.CONECT_TIMEOUT.getRequired(client))\n                    .getSession();\n            try {\n                if (GenericUtils.length(password) > 0) {\n                    session.addPasswordIdentity(password);\n                }\n                session.auth().verify(CliClientModuleProperties.AUTH_TIMEOUT.getRequired(session));\n                return session;\n            } catch (Exception e) {\n                session.close(true);\n                throw e;\n            }\n        } catch (Exception e) {\n            client.close();\n            throw e;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          120,
          278
        ]
      },
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/client/SshClientCliSupport.java",
        "class_name": "SshClientCliSupport",
        "method_name": "setupCompressions",
        "signature": "List setupCompressions(PropertyResolver,PrintStream)",
        "lines_hint_csv": [
          508,
          520
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/client/SshKeyScanMain.java",
        "class_name": "SshKeyScanMain",
        "method_name": "initializeScanner",
        "signature": "S initializeScanner(S,Collection)",
        "lines_hint_csv": [
          711,
          729
        ],
        "code": "    public static <S extends SshKeyScanMain> S initializeScanner(S scanner, Collection<String> hosts) throws IOException {\n        setInputStream(scanner, hosts);\n        if (scanner.getPort() <= 0) {\n            scanner.setPort(SshConstants.DEFAULT_PORT);\n        }\n\n        if (scanner.getTimeout() <= 0L) {\n            scanner.setTimeout(DEFAULT_TIMEOUT);\n        }\n\n        if (GenericUtils.isEmpty(scanner.getKeyTypes())) {\n            scanner.setKeyTypes(DEFAULT_KEY_TYPES);\n        }\n\n        if (scanner.getLogLevel() == null) {\n            scanner.setLogLevel(DEFAULT_LEVEL);\n        }\n\n        return scanner;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          734,
          753
        ]
      },
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/server/SshServerCliSupport.java",
        "class_name": "SshServerCliSupport",
        "method_name": "resolveServerSubsystems",
        "signature": "List resolveServerSubsystems(PrintStream,PropertyResolver)",
        "lines_hint_csv": [
          146,
          190
        ],
        "code": "    public static List<SubsystemFactory> resolveServerSubsystems(\n            ServerFactoryManager server, Level level, PrintStream stdout, PrintStream stderr, PropertyResolver options)\n            throws Exception {\n        ClassLoader cl = ThreadUtils.resolveDefaultClassLoader(SubsystemFactory.class);\n        String classList = System.getProperty(SubsystemFactory.class.getName());\n        if (GenericUtils.isNotEmpty(classList)) {\n            String[] classes = GenericUtils.split(classList, ',');\n            List<SubsystemFactory> subsystems = new ArrayList<>(classes.length);\n            for (String fqcn : classes) {\n                try {\n                    Class<?> clazz = cl.loadClass(fqcn);\n                    SubsystemFactory factory = ReflectionUtils.newInstance(clazz, SubsystemFactory.class);\n                    factory = registerSubsystemFactoryListeners(\n                            server, level, stdout, stderr, options, factory);\n                    subsystems.add(factory);\n                } catch (Exception e) {\n                    stderr.append(\"ERROR: Failed (\").append(e.getClass().getSimpleName()).append(')')\n                            .append(\" to instantiate subsystem=\").append(fqcn)\n                            .append(\": \").println(e.getMessage());\n                    stderr.flush();\n                    throw e;\n                }\n            }\n\n            return subsystems;\n        }\n\n        String nameList = (options == null) ? null : options.getString(ConfigFileReaderSupport.SUBSYSTEM_CONFIG_PROP);\n        if (PropertyResolverUtils.isNoneValue(nameList)) {\n            return Collections.emptyList();\n        }\n\n        if (SftpConstants.SFTP_SUBSYSTEM_NAME.equalsIgnoreCase(nameList)) {\n            SubsystemFactory factory = registerSubsystemFactoryListeners(\n                    server, level, stdout, stderr, options, new SftpSubsystemFactory());\n            PrintStream logStream = CliLogger.resolvePrintStream(level, stdout, stderr);\n            CliLogger.log(logStream, level, \"Using built-in SFTP subsystem\");\n            return Collections.singletonList(factory);\n        }\n\n        boolean havePreferences = GenericUtils.isNotEmpty(nameList);\n        Collection<String> preferredNames = (!havePreferences)\n                ? Collections.emptySet()\n                : Stream.of(GenericUtils.split(nameList, ','))\n                        .collect(Collectors.toCollection(() -> new TreeSet<>(String.CASE_INSENSITIVE_ORDER)));\n        ServiceLoader<SubsystemFactory> loader = ServiceLoader.load(SubsystemFactory.class, cl);\n        List<SubsystemFactory> subsystems = new ArrayList<>();\n        for (SubsystemFactory factory : loader) {\n            String name = factory.getName();\n            if (havePreferences && (!preferredNames.contains(name))) {\n                continue;\n            }\n\n            registerSubsystemFactoryListeners(server, level, stdout, stderr, options, factory);\n            subsystems.add(factory);\n        }\n\n        return subsystems;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          175,
          233
        ]
      },
      {
        "file_path": "sshd-cli/src/main/java/org/apache/sshd/cli/server/SshServerMain.java",
        "class_name": "SshServerMain",
        "method_name": "main",
        "signature": "void main(String)",
        "lines_hint_csv": [
          57,
          196
        ],
        "code": "    public static void main(String[] args) throws Exception {\n        int port = 8000;\n        boolean error = false;\n        String hostKeyType = AbstractGeneratorHostKeyProvider.DEFAULT_ALGORITHM;\n        int hostKeySize = 0;\n        Collection<String> keyFiles = null;\n        Collection<String> certFiles = null;\n        Map<String, Object> options = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n\n        int numArgs = GenericUtils.length(args);\n        for (int i = 0; i < numArgs; i++) {\n            String argName = args[i];\n            if (\"-p\".equals(argName)) {\n                i++;\n                if (i >= numArgs) {\n                    System.err.println(\"option requires an argument: \" + argName);\n                    error = true;\n                    break;\n                }\n                port = Integer.parseInt(args[i]);\n            } else if (\"-key-type\".equals(argName)) {\n                i++;\n                if (i >= numArgs) {\n                    System.err.println(\"option requires an argument: \" + argName);\n                    error = true;\n                    break;\n                }\n\n                if (keyFiles != null) {\n                    System.err.println(\"option conflicts with -key-file: \" + argName);\n                    error = true;\n                    break;\n                }\n                hostKeyType = args[i].toUpperCase();\n            } else if (\"-key-size\".equals(argName)) {\n                i++;\n                if (i >= numArgs) {\n                    System.err.println(\"option requires an argument: \" + argName);\n                    error = true;\n                    break;\n                }\n\n                if (keyFiles != null) {\n                    System.err.println(\"option conflicts with -key-file: \" + argName);\n                    error = true;\n                    break;\n                }\n\n                hostKeySize = Integer.parseInt(args[i]);\n            } else if (\"-key-file\".equals(argName)) {\n                i++;\n                if (i >= numArgs) {\n                    System.err.println(\"option requires an argument: \" + argName);\n                    error = true;\n                    break;\n                }\n\n                String keyFilePath = args[i];\n                if (keyFiles == null) {\n                    keyFiles = new LinkedList<>();\n                }\n                keyFiles.add(keyFilePath);\n            } else if (\"-o\".equals(argName)) {\n                i++;\n                if (i >= numArgs) {\n                    System.err.println(\"option requires and argument: \" + argName);\n                    error = true;\n                    break;\n                }\n\n                String opt = args[i];\n                int idx = opt.indexOf('=');\n                if (idx <= 0) {\n                    System.err.println(\"bad syntax for option: \" + opt);\n                    error = true;\n                    break;\n                }\n\n                String optName = opt.substring(0, idx);\n                String optValue = opt.substring(idx + 1);\n                if (ServerIdentity.HOST_KEY_CONFIG_PROP.equals(optName)) {\n                    if (keyFiles == null) {\n                        keyFiles = new LinkedList<>();\n                    }\n                    keyFiles.add(optValue);\n                } else if (ServerIdentity.HOST_CERT_CONFIG_PROP.equals(optName)) {\n                    if (certFiles == null) {\n                        certFiles = new LinkedList<>();\n                    }\n                    certFiles.add(optValue);\n                } else if (ConfigFileReaderSupport.PORT_CONFIG_PROP.equals(optName)) {\n                    port = Integer.parseInt(optValue);\n                } else {\n                    options.put(optName, optValue);\n                }\n            }\n        }\n\n        PropertyResolver resolver = PropertyResolverUtils.toPropertyResolver(options);\n        Level level = CliLogger.resolveLoggingVerbosity(resolver, args);\n        Logger logger = CliLogger.resolveSystemLogger(SshServerMain.class, level);\n        SshServer sshd = error\n                ? null\n                : setupIoServiceFactory(\n                        SshServer.setUpDefaultServer(), resolver,\n                        level, System.out, System.err, args);\n        if (sshd == null) {\n            error = true;\n        }\n\n        if (error) {\n            System.err.println(\n                    \"usage: sshd [-p port] [-io mina|nio2|netty] [-key-type RSA|DSA|EC] [-key-size NNNN] [-key-file <path>] [-o option=value]\");\n            System.exit(-1);\n            return; // just in case...\n        }\n\n        Map<String, Object> props = sshd.getProperties();\n        props.putAll(options);\n\n        SshServerConfigFileReader.configure(sshd, resolver, true, true);\n        KeyPairProvider hostKeyProvider = resolveServerKeys(System.err, hostKeyType, hostKeySize, keyFiles);\n        sshd.setKeyPairProvider(hostKeyProvider);\n        if (GenericUtils.isNotEmpty(certFiles)) {\n            HostKeyCertificateProvider certProvider = new FileHostKeyCertificateProvider(\n                    certFiles.stream().map(Paths::get).collect(Collectors.toList()));\n            sshd.setHostKeyCertificateProvider(certProvider);\n        }\n        // Should come AFTER key pair provider setup so auto-welcome can be generated if needed\n        setupServerBanner(sshd, resolver);\n        sshd.setPort(port);\n\n        ShellFactory shellFactory = resolveShellFactory(level, System.out, System.err, resolver);\n        if (shellFactory != null) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Using shell={}\", shellFactory.getClass().getName());\n            }\n            sshd.setShellFactory(shellFactory);\n        }\n\n        sshd.setPasswordAuthenticator((username, password, session) -> Objects.equals(username, password));\n        sshd.setPublickeyAuthenticator(AcceptAllPublickeyAuthenticator.INSTANCE);\n        setupUserAuthFactories(sshd, resolver);\n        setupServerForwarding(sshd, level, System.out, System.err, resolver);\n        setupCommandFactory(sshd, level, System.out, System.err, shellFactory);\n\n        List<SubsystemFactory> subsystems = resolveServerSubsystems(sshd, level, System.out, System.err, resolver);\n        if (GenericUtils.isNotEmpty(subsystems)) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Setup subsystems={}\", NamedResource.getNames(subsystems));\n            }\n            sshd.setSubsystemFactories(subsystems);\n        }\n\n        System.err.println(\"Starting SSHD on port \" + port);\n        sshd.start();\n        Thread.sleep(Long.MAX_VALUE);\n        System.err.println(\"Exiting after a very (very very) long time\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          65,
          223
        ]
      },
      {
        "file_path": "sshd-cli/src/test/java/org/apache/sshd/cli/server/SshFsMounter.java",
        "class_name": "SshFsMounter",
        "method_name": "main",
        "signature": "void main(String)",
        "lines_hint_csv": [
          251,
          334
        ],
        "code": "    public static void main(String[] args) throws Exception {\n        int port = SshConstants.DEFAULT_PORT;\n        boolean error = false;\n        Map<String, Object> options = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        int numArgs = GenericUtils.length(args);\n        for (int i = 0; i < numArgs; i++) {\n            String argName = args[i];\n            if (\"-p\".equals(argName)) {\n                if ((i + 1) >= numArgs) {\n                    System.err.println(\"option requires an argument: \" + argName);\n                    break;\n                }\n                port = Integer.parseInt(args[++i]);\n            } else if (\"-io\".equals(argName)) {\n                if ((i + 1) >= numArgs) {\n                    System.err.println(\"option requires an argument: \" + argName);\n                    break;\n                }\n\n                String provider = args[++i];\n                BuiltinIoServiceFactoryFactories factory\n                        = CliSupport.resolveBuiltinIoServiceFactory(System.err, argName, provider);\n                if (factory != null) {\n                    System.setProperty(IoServiceFactory.class.getName(), factory.getFactoryClassName());\n                } else {\n                    error = true;\n                    break;\n                }\n            } else if (\"-o\".equals(argName)) {\n                if ((i + 1) >= numArgs) {\n                    System.err.println(\"option requires and argument: \" + argName);\n                    error = true;\n                    break;\n                }\n\n                String opt = args[++i];\n                int idx = opt.indexOf('=');\n                if (idx <= 0) {\n                    System.err.println(\"bad syntax for option: \" + opt);\n                    error = true;\n                    break;\n                }\n                options.put(opt.substring(0, idx), opt.substring(idx + 1));\n            }\n        }\n\n        PropertyResolver resolver = PropertyResolverUtils.toPropertyResolver(options);\n        Level level = CliLogger.resolveLoggingVerbosity(resolver, args);\n        SshServer sshd = error\n                ? null : setupIoServiceFactory(\n                        CoreTestSupportUtils.setupTestServer(SshFsMounter.class), resolver,\n                        level, System.out, System.err, args);\n        if (sshd == null) {\n            error = true;\n        }\n\n        if (error) {\n            System.err.println(\"usage: sshfs [-p port] [-io mina|nio2|netty] [-o option=value]\");\n            System.exit(-1);\n        }\n\n        Map<String, Object> props = sshd.getProperties();\n        props.putAll(options);\n        Path targetFolder = Objects.requireNonNull(CommonTestSupportUtils.detectTargetFolder(MounterCommandFactory.class),\n                \"Failed to detect target folder\");\n        if (SecurityUtils.isBouncyCastleRegistered()) {\n            sshd.setKeyPairProvider(SecurityUtils.createGeneratorHostKeyProvider(targetFolder.resolve(\"key.pem\")));\n        } else {\n            sshd.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(targetFolder.resolve(\"key.ser\")));\n        }\n        // Should come AFTER key pair provider setup so auto-welcome can be generated if needed\n        setupServerBanner(sshd, resolver);\n\n        ShellFactory shellFactory = resolveShellFactory(level, System.out, System.err, resolver);\n        if (shellFactory != null) {\n            System.out.append(\"Using shell=\").println(shellFactory.getClass().getName());\n            sshd.setShellFactory(shellFactory);\n        }\n        sshd.setPasswordAuthenticator(AcceptAllPasswordAuthenticator.INSTANCE);\n        sshd.setForwardingFilter(AcceptAllForwardingFilter.INSTANCE);\n\n        ScpCommandFactory scpFactory;\n        if (shellFactory instanceof ScpCommandFactory) {\n            scpFactory = (ScpCommandFactory) shellFactory;\n            scpFactory.setDelegateCommandFactory(MounterCommandFactory.INSTANCE);\n        } else {\n            scpFactory = new ScpCommandFactory.Builder()\n                    .withDelegate(MounterCommandFactory.INSTANCE)\n                    .build();\n        }\n\n        sshd.setCommandFactory(scpFactory);\n        sshd.setSubsystemFactories(Collections.singletonList(new SftpSubsystemFactory()));\n        sshd.setPort(port);\n\n        System.err.println(\"Starting SSHD on port \" + port);\n        sshd.start();\n        Thread.sleep(Long.MAX_VALUE);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          255,
          353
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystem.java",
        "class_name": "RootedFileSystem",
        "method_name": "getFileStores",
        "signature": "Iterable getFileStores()",
        "lines_hint_csv": [
          93,
          94
        ],
        "code": "    public Iterable<FileStore> getFileStores() {\n        return rootFs.getFileStores();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          93,
          95
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "unroot",
        "signature": "Path unroot(Path)",
        "lines_hint_csv": [
          453,
          460
        ],
        "code": "    protected Path unroot(Path path) {\n        Objects.requireNonNull(path, \"No path to unroot\");\n        if (!(path instanceof RootedPath)) {\n            throw new ProviderMismatchException(\"unroot(\" + path + \") is not a \" + RootedPath.class.getSimpleName()\n                                                + \" but rather a \" + path.getClass().getSimpleName());\n        }\n\n        return resolveLocalPath((RootedPath) path);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          453,
          461
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "newDirectoryStream",
        "signature": "DirectoryStream newDirectoryStream(Path,DirectoryStream)",
        "lines_hint_csv": [
          196,
          199
        ],
        "code": "    public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {\n        Path r = unroot(dir);\n        FileSystemProvider p = provider(r);\n        return root(((RootedPath) dir).getFileSystem(), p.newDirectoryStream(r, filter));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          196,
          200
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "resolveLocalPath",
        "signature": "Path resolveLocalPath(RootedPath)",
        "lines_hint_csv": [
          468,
          502
        ],
        "code": "    protected Path resolveLocalPath(RootedPath path) {\n        RootedPath absPath = Objects.requireNonNull(path, \"No rooted path to resolve\").toAbsolutePath();\n        RootedFileSystem rfs = absPath.getFileSystem();\n        Path root = rfs.getRoot();\n        FileSystem lfs = root.getFileSystem();\n\n        String rSep = ValidateUtils.checkNotNullAndNotEmpty(rfs.getSeparator(), \"No rooted file system separator\");\n        ValidateUtils.checkTrue(rSep.length() == 1, \"Bad rooted file system separator: %s\", rSep);\n        char rootedSeparator = rSep.charAt(0);\n\n        String lSep = ValidateUtils.checkNotNullAndNotEmpty(lfs.getSeparator(), \"No local file system separator\");\n        ValidateUtils.checkTrue(lSep.length() == 1, \"Bad local file system separator: %s\", lSep);\n        char localSeparator = lSep.charAt(0);\n\n        String r = absPath.toString();\n        String subPath = r.substring(1);\n        if (rootedSeparator != localSeparator) {\n            subPath = subPath.replace(rootedSeparator, localSeparator);\n        }\n\n        Path resolved = root.resolve(subPath);\n        resolved = resolved.normalize();\n        resolved = resolved.toAbsolutePath();\n        if (log.isTraceEnabled()) {\n            log.trace(\"resolveLocalPath({}): {}\", absPath, resolved);\n        }\n\n        /*\n         * This can happen for Windows since we represent its paths as /C:/some/path, so substring(1) yields\n         * C:/some/path - which is resolved as an absolute path (which we don't want).\n         */\n        if (!resolved.startsWith(root)) {\n            throw new InvalidPathException(r, \"Not under root\");\n        }\n        return resolved;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          468,
          503
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "root",
        "signature": "DirectoryStream root(RootedFileSystem,DirectoryStream)",
        "lines_hint_csv": [
          202,
          211
        ],
        "code": "    protected DirectoryStream<Path> root(RootedFileSystem rfs, DirectoryStream<Path> ds) {\n        return new DirectoryStream<Path>() {\n            @Override\n            public Iterator<Path> iterator() {\n                return root(rfs, ds.iterator());\n            }\n\n            @Override\n            public void close() throws IOException {\n                ds.close();\n            }\n        };\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          202,
          214
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "readSymbolicLink",
        "signature": "Path readSymbolicLink(Path)",
        "lines_hint_csv": [
          292,
          300
        ],
        "code": "    public Path readSymbolicLink(Path link) throws IOException {\n        Path r = unroot(link);\n        FileSystemProvider p = provider(r);\n        Path t = p.readSymbolicLink(r);\n        Path target = root((RootedFileSystem) link.getFileSystem(), t);\n        if (log.isTraceEnabled()) {\n            log.trace(\"readSymbolicLink({})[{}]: {}[{}]\", link, r, target, t);\n        }\n        return target;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          292,
          301
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "getFileSystem",
        "signature": "RootedFileSystem getFileSystem(Path)",
        "lines_hint_csv": [
          347,
          380
        ],
        "code": "    protected RootedFileSystem getFileSystem(Path path) throws FileSystemNotFoundException {\n        Path real = unroot(path);\n        Path rootInstance = null;\n        RootedFileSystem fsInstance = null;\n        synchronized (fileSystems) {\n            // Cannot use forEach because the referenced variable are not effectively final\n            for (Map.Entry<Path, RootedFileSystem> fse : fileSystems.entrySet()) {\n                Path root = fse.getKey();\n                RootedFileSystem fs = fse.getValue();\n                if (real.equals(root)) {\n                    return fs; // we were lucky to have the root\n                }\n\n                if (!real.startsWith(root)) {\n                    continue;\n                }\n\n                // if already have a candidate prefer the longer match since both are prefixes of the real path\n                if ((rootInstance == null) || (rootInstance.getNameCount() < root.getNameCount())) {\n                    rootInstance = root;\n                    fsInstance = fs;\n                }\n            }\n        }\n\n        if (fsInstance == null) {\n            throw new FileSystemNotFoundException(path.toString());\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"getFileSystem({}): {}\", path, fsInstance);\n        }\n\n        return fsInstance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          347,
          381
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "isHidden",
        "signature": "boolean isHidden(Path)",
        "lines_hint_csv": [
          334,
          337
        ],
        "code": "    public boolean isHidden(Path path) throws IOException {\n        Path r = unroot(path);\n        FileSystemProvider p = provider(r);\n        return p.isHidden(r);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          334,
          338
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "newOutputStream",
        "signature": "OutputStream newOutputStream(Path,OpenOption)",
        "lines_hint_csv": [
          164,
          167
        ],
        "code": "    public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n        Path r = unroot(path);\n        FileSystemProvider p = provider(r);\n        return p.newOutputStream(r, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          164,
          168
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "copy",
        "signature": "void copy(Path,Path,CopyOption)",
        "lines_hint_csv": [
          304,
          311
        ],
        "code": "    public void copy(Path source, Path target, CopyOption... options) throws IOException {\n        Path s = unroot(source);\n        Path t = unroot(target);\n        if (log.isTraceEnabled()) {\n            log.trace(\"copy({})[{}]: {}[{}]\", source, s, target, t);\n        }\n        FileSystemProvider p = provider(s);\n        p.copy(s, t, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          304,
          312
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "deleteIfExists",
        "signature": "boolean deleteIfExists(Path)",
        "lines_hint_csv": [
          282,
          288
        ],
        "code": "    public boolean deleteIfExists(Path path) throws IOException {\n        Path r = unroot(path);\n        if (log.isTraceEnabled()) {\n            log.trace(\"deleteIfExists({}): {}\", path, r);\n        }\n        FileSystemProvider p = provider(r);\n        return p.deleteIfExists(r);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          282,
          289
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/util/BaseFileSystem.java",
        "class_name": "BaseFileSystem",
        "method_name": "getPath",
        "signature": "T getPath(String,String)",
        "lines_hint_csv": [
          79,
          112
        ],
        "code": "    public T getPath(String first, String... more) {\n        StringBuilder sb = new StringBuilder();\n        if (!GenericUtils.isEmpty(first)) {\n            appendDedupSep(sb, first.replace('\\\\', '/')); // in case we are running on Windows\n        }\n\n        if (GenericUtils.length(more) > 0) {\n            for (String segment : more) {\n                if ((sb.length() > 0) && (sb.charAt(sb.length() - 1) != '/')) {\n                    sb.append('/');\n                }\n                // in case we are running on Windows\n                appendDedupSep(sb, segment.replace('\\\\', '/'));\n            }\n        }\n\n        if ((sb.length() > 1) && (sb.charAt(sb.length() - 1) == '/')) {\n            sb.setLength(sb.length() - 1);\n        }\n\n        String path = sb.toString();\n        String root = null;\n        if (path.startsWith(\"/\")) {\n            root = \"/\";\n            path = path.substring(1);\n        }\n\n        String[] names = GenericUtils.split(path, '/');\n        T p = create(root, names);\n        if (log.isTraceEnabled()) {\n            log.trace(\"getPath({}, {}): {}\", first, Arrays.toString(more), p);\n        }\n\n        return p;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          79,
          113
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/util/BaseFileSystem.java",
        "class_name": "BaseFileSystem",
        "method_name": "getPathMatcher",
        "signature": "PathMatcher getPathMatcher(String)",
        "lines_hint_csv": [
          125,
          152
        ],
        "code": "    public PathMatcher getPathMatcher(String syntaxAndPattern) {\n        int colonIndex = Objects.requireNonNull(syntaxAndPattern, \"No argument\").indexOf(':');\n        if ((colonIndex <= 0) || (colonIndex == syntaxAndPattern.length() - 1)) {\n            throw new IllegalArgumentException(\n                    \"syntaxAndPattern must have form \\\"syntax:pattern\\\" but was \\\"\" + syntaxAndPattern + \"\\\"\");\n        }\n\n        String syntax = syntaxAndPattern.substring(0, colonIndex);\n        String pattern = syntaxAndPattern.substring(colonIndex + 1);\n        String expr;\n        switch (syntax) {\n            case \"glob\":\n                expr = globToRegex(pattern);\n                break;\n            case \"regex\":\n                expr = pattern;\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported path matcher syntax: \\'\" + syntax + \"\\'\");\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"getPathMatcher({}): {}\", syntaxAndPattern, expr);\n        }\n\n        Pattern regex = Pattern.compile(expr);\n        return path -> {\n            Matcher m = regex.matcher(path.toString());\n            return m.matches();\n        };\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          125,
          154
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/util/io/IoUtils.java",
        "class_name": "IoUtils",
        "method_name": "read",
        "signature": "int read(InputStream,byte,int,int)",
        "lines_hint_csv": [
          471,
          484
        ],
        "code": "    public static int read(InputStream input, byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          457,
          459
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/util/io/IoUtils.java",
        "class_name": "IoUtils",
        "method_name": "checkFileExists",
        "signature": "Boolean checkFileExists(Path,LinkOption)",
        "lines_hint_csv": [
          396,
          414
        ],
        "code": "    public static Boolean checkFileExists(Path path, LinkOption... options) {\n        boolean followLinks = true;\n        for (LinkOption opt : options) {\n            if (opt == LinkOption.NOFOLLOW_LINKS) {\n                followLinks = false;\n                break;\n            }\n        }\n        try {\n            if (followLinks) {\n                path.getFileSystem().provider().checkAccess(path);\n            } else {\n                Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n            }\n            return Boolean.TRUE;\n        } catch (NoSuchFileException e) {\n            return Boolean.FALSE;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          396,
          416
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/common/file/root/RootedFileSystemProviderTest.java",
        "class_name": "RootedFileSystemProviderTest",
        "method_name": "testRoot",
        "signature": "void testRoot()",
        "lines_hint_csv": [
          78,
          83
        ],
        "code": "    public void testRoot() {\n        Path root = fileSystem.getRoot();\n        assertTrue(\"Exists? \" + root, exists(root));\n        assertTrue(\"Dir? \" + root, isDir(root));\n        assertTrue(\"Readable? \" + root, isReadable(root));\n        assertTrue(root + \" rooted at \" + rootSandbox + \" ?\", isRootedAt(rootSandbox, root));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          78,
          84
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/common/file/root/RootedFileSystemProviderTest.java",
        "class_name": "FileHelper",
        "method_name": "readFile",
        "signature": "byte readFile(Path)",
        "lines_hint_csv": [
          304,
          309
        ],
        "code": "        public static byte[] readFile(Path source) throws IOException {\n            try (FileChannel fc = fileSystem.provider().newFileChannel(source,\n                    new TreeSet<OpenOption>(Arrays.asList(StandardOpenOption.READ)))) {\n                byte[] readBytes = new byte[(int) source.toFile().length()];\n                fc.read(ByteBuffer.wrap(readBytes));\n                return readBytes;\n            }\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          304,
          311
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/common/file/root/RootedFileSystemProviderTest.java",
        "class_name": "RootedFileSystemProviderTest",
        "method_name": "testMkdir",
        "signature": "void testMkdir()",
        "lines_hint_csv": [
          88,
          90
        ],
        "code": "    public void testMkdir() throws IOException {\n        Path created = FileHelper.createDirectory(fileSystem.getPath(getCurrentTestName()));\n        assertTrue(exists(created) && isDir(created) && isReadable(created));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          88,
          91
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/util/test/CommonTestSupportUtils.java",
        "class_name": "CommonTestSupportUtils",
        "method_name": "deleteRecursive",
        "signature": "Path deleteRecursive(Path,LinkOption)",
        "lines_hint_csv": [
          497,
          523
        ],
        "code": "    public static Path deleteRecursive(Path path, LinkOption... options) throws IOException {\n        if ((path == null) || (!Files.exists(path))) {\n            return path;\n        }\n\n        if (Files.isDirectory(path)) {\n            try (DirectoryStream<Path> ds = Files.newDirectoryStream(path)) {\n                for (Path child : ds) {\n                    deleteRecursive(child, options);\n                }\n            }\n        }\n\n        try {\n            // seems that if a file is not writable it cannot be deleted\n            if (!Files.isWritable(path)) {\n                path.toFile().setWritable(true, false);\n            }\n            Files.delete(path);\n        } catch (IOException e) {\n            // same logic as deleteRecursive(File) which does not check if deletion succeeded\n            System.err.append(\"Failed (\").append(e.getClass().getSimpleName()).append(\")\")\n                    .append(\" to delete \").append(path.toString())\n                    .append(\": \").println(e.getMessage());\n        }\n\n        return path;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          497,
          524
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/client/fs/SftpFileSystemProvider.java",
        "class_name": "SftpFileSystemProvider",
        "method_name": "move",
        "signature": "void move(Path,Path,CopyOption)",
        "lines_hint_csv": [
          700,
          758
        ],
        "code": "    public void move(Path source, Path target, CopyOption... options) throws IOException {\n        SftpPath src = toSftpPath(source);\n        SftpFileSystem fsSrc = src.getFileSystem();\n        SftpPath dst = toSftpPath(target);\n\n        if (src.getFileSystem() != dst.getFileSystem()) {\n            throw new ProviderMismatchException(\"Mismatched file system providers for \" + src + \" vs. \" + dst);\n        }\n        checkAccess(src);\n\n        boolean replaceExisting = false;\n        boolean copyAttributes = false;\n        boolean noFollowLinks = false;\n        for (CopyOption opt : options) {\n            replaceExisting |= opt == StandardCopyOption.REPLACE_EXISTING;\n            copyAttributes |= opt == StandardCopyOption.COPY_ATTRIBUTES;\n            noFollowLinks |= opt == LinkOption.NOFOLLOW_LINKS;\n        }\n        LinkOption[] linkOptions = IoUtils.getLinkOptions(noFollowLinks);\n\n        // attributes of source file\n        BasicFileAttributes attrs = readAttributes(source, BasicFileAttributes.class, linkOptions);\n        if (attrs.isSymbolicLink()) {\n            throw new IOException(\"Moving of source symbolic link (\" + source + \") to \" + target + \" not supported\");\n        }\n\n        // delete target if it exists and REPLACE_EXISTING is specified\n        Boolean status = IoUtils.checkFileExists(target, linkOptions);\n        if (status == null) {\n            throw new AccessDeniedException(\"Existence cannot be determined for move target \" + target);\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"move({})[{}] {} => {}\", src.getFileSystem(), Arrays.asList(options), src, dst);\n        }\n\n        if (replaceExisting) {\n            deleteIfExists(target);\n        } else if (status) {\n            throw new FileAlreadyExistsException(target.toString());\n        }\n\n        try (SftpClient sftp = fsSrc.getClient()) {\n            sftp.rename(src.toString(), dst.toString());\n        }\n\n        // copy basic attributes to target\n        if (copyAttributes) {\n            BasicFileAttributeView view = getFileAttributeView(target, BasicFileAttributeView.class, linkOptions);\n            try {\n                view.setTimes(attrs.lastModifiedTime(), attrs.lastAccessTime(), attrs.creationTime());\n            } catch (Throwable x) {\n                // rollback\n                try {\n                    delete(target);\n                } catch (Throwable suppressed) {\n                    x.addSuppressed(suppressed);\n                }\n                throw x;\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          674,
          735
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/client/fs/SftpFileSystemProvider.java",
        "class_name": "SftpFileSystemProvider",
        "method_name": "copy",
        "signature": "void copy(Path,Path,CopyOption)",
        "lines_hint_csv": [
          623,
          694
        ],
        "code": "    public void copy(Path source, Path target, CopyOption... options) throws IOException {\n        SftpPath src = toSftpPath(source);\n        SftpPath dst = toSftpPath(target);\n        if (src.getFileSystem() != dst.getFileSystem()) {\n            throw new ProviderMismatchException(\"Mismatched file system providers for \" + src + \" vs. \" + dst);\n        }\n        checkAccess(src);\n\n        boolean replaceExisting = false;\n        boolean copyAttributes = false;\n        boolean noFollowLinks = false;\n        for (CopyOption opt : options) {\n            replaceExisting |= opt == StandardCopyOption.REPLACE_EXISTING;\n            copyAttributes |= opt == StandardCopyOption.COPY_ATTRIBUTES;\n            noFollowLinks |= opt == LinkOption.NOFOLLOW_LINKS;\n        }\n        LinkOption[] linkOptions = IoUtils.getLinkOptions(!noFollowLinks);\n\n        // attributes of source file\n        BasicFileAttributes attrs = readAttributes(source, BasicFileAttributes.class, linkOptions);\n        if (attrs.isSymbolicLink()) {\n            throw new IOException(\"Copying of symbolic links not supported\");\n        }\n\n        // delete target if it exists and REPLACE_EXISTING is specified\n        Boolean status = IoUtils.checkFileExists(target, linkOptions);\n        if (status == null) {\n            throw new AccessDeniedException(\"Existence cannot be determined for copy target: \" + target);\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"copy({})[{}] {} => {}\", src.getFileSystem(), Arrays.asList(options), src, dst);\n        }\n\n        if (replaceExisting) {\n            deleteIfExists(target);\n        } else {\n            if (status) {\n                throw new FileAlreadyExistsException(target.toString());\n            }\n        }\n\n        // create directory or copy file\n        if (attrs.isDirectory()) {\n            createDirectory(target);\n        } else {\n            CopyFileExtension copyFile = src.getFileSystem().getClient().getExtension(CopyFileExtension.class);\n            if (copyFile.isSupported()) {\n                copyFile.copyFile(source.toString(), target.toString(), false);\n            } else {\n                try (InputStream in = newInputStream(source);\n                     OutputStream os = newOutputStream(target)) {\n                    IoUtils.copy(in, os);\n                }\n            }\n        }\n\n        // copy basic attributes to target\n        if (copyAttributes) {\n            BasicFileAttributeView view = getFileAttributeView(target, BasicFileAttributeView.class, linkOptions);\n            try {\n                view.setTimes(attrs.lastModifiedTime(), attrs.lastAccessTime(), attrs.creationTime());\n            } catch (Throwable x) {\n                // rollback\n                try {\n                    delete(target);\n                } catch (Throwable suppressed) {\n                    x.addSuppressed(suppressed);\n                }\n                throw x;\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          599,
          671
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "writeDirEntry",
        "signature": "void writeDirEntry(int,DirectoryHandle,Map,Buffer,int,Path,String,LinkOption)",
        "lines_hint_csv": [
          2292,
          2318
        ],
        "code": "    protected void writeDirEntry(\n            int id, DirectoryHandle dir, Map<String, Path> entries, Buffer buffer,\n            int index, Path f, String shortName, LinkOption... options)\n            throws IOException {\n        Map<String, ?> attrs = resolveFileAttributes(\n                f, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n        entries.put(shortName, f);\n\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        ServerSession session = getServerSession();\n        accessor.putRemoteFileName(this, f, buffer, shortName, true);\n\n        int version = getVersion();\n        if (version == SftpConstants.SFTP_V3) {\n            String longName = getLongName(f, shortName, options);\n            accessor.putRemoteFileName(this, f, buffer, longName, false);\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"writeDirEntry({} id={})[{}] - {} [{}]: {}\", session, id, index, shortName, longName, attrs);\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"writeDirEntry({} id={})[{}] - {}: {}\", session, id, index, shortName, attrs);\n            }\n        }\n\n        writeAttrs(buffer, attrs);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2292,
          2319
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "handleUnknownStatusFileAttributes",
        "signature": "NavigableMap handleUnknownStatusFileAttributes(Path,int,LinkOption)",
        "lines_hint_csv": [
          2418,
          2435
        ],
        "code": "    protected NavigableMap<String, Object> handleUnknownStatusFileAttributes(\n            Path file, int flags, LinkOption... options)\n            throws IOException {\n        UnsupportedAttributePolicy policy = getUnsupportedAttributePolicy();\n        switch (policy) {\n            case Ignore:\n                break;\n            case ThrowException:\n                throw new AccessDeniedException(file.toString(), file.toString(),\n                        \"Cannot determine existence for attributes of target\");\n            case Warn:\n                log.warn(\"handleUnknownStatusFileAttributes({})[{}] cannot determine existence\", getServerSession(), file);\n                break;\n            default:\n                log.warn(\"handleUnknownStatusFileAttributes({})[{}] unknown policy: {}\", getServerSession(), file, policy);\n        }\n\n        return getAttributes(file, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2418,
          2436
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemoveDirectory",
        "signature": "void doRemoveDirectory(int,String,boolean)",
        "lines_hint_csv": [
          1577,
          1590
        ],
        "code": "    protected void doRemoveDirectory(int id, String path, boolean followLinks) throws IOException {\n        Path p = resolveFile(path);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doRemoveDirectory({})[id={}] SSH_FXP_RMDIR (path={})[{}]\", getServerSession(), id, path, p);\n        }\n\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, p, SftpConstants.SSH_FXP_RMDIR, \"\", followLinks);\n        if (Files.isDirectory(p, options)) {\n            doRemove(id, p, true);\n        } else {\n            throw signalRemovalPreConditionFailure(\n                    id, path, p, new NotDirectoryException(p.toString()), true);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1577,
          1592
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "setFileAttributes",
        "signature": "void setFileAttributes(Path,Map,LinkOption)",
        "lines_hint_csv": [
          2643,
          2706
        ],
        "code": "    protected void setFileAttributes(\n            Path file, Map<String, ?> attributes, LinkOption... options)\n            throws IOException {\n        Set<String> unsupported = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n        // Cannot use forEach because of the potential IOException being thrown\n        for (Map.Entry<String, ?> ae : attributes.entrySet()) {\n            String attribute = ae.getKey();\n            Object value = ae.getValue();\n            String view = null;\n            switch (attribute) {\n                case IoUtils.SIZE_VIEW_ATTR: {\n                    long newSize = ((Number) value).longValue();\n                    SftpFileSystemAccessor accessor = getFileSystemAccessor();\n                    Set<StandardOpenOption> openOptions = EnumSet.of(StandardOpenOption.WRITE);\n                    try (SeekableByteChannel channel = accessor.openFile(this, null, file, null, openOptions)) {\n                        channel.truncate(newSize);\n                        accessor.closeFile(this, null, file, null, channel, openOptions);\n                    }\n                    continue;\n                }\n                case IoUtils.USERID_VIEW_ATTR:\n                    view = \"unix\";\n                    break;\n                case IoUtils.GROUPID_VIEW_ATTR:\n                    view = \"unix\";\n                    break;\n                case IoUtils.OWNER_VIEW_ATTR:\n                    view = \"posix\";\n                    value = toUser(file, (UserPrincipal) value);\n                    break;\n                case IoUtils.GROUP_VIEW_ATTR:\n                    view = \"posix\";\n                    value = toGroup(file, (GroupPrincipal) value);\n                    break;\n                case IoUtils.PERMISSIONS_VIEW_ATTR:\n                    view = \"posix\";\n                    break;\n                case IoUtils.ACL_VIEW_ATTR:\n                    view = \"acl\";\n                    break;\n                case IoUtils.CREATE_TIME_VIEW_ATTR:\n                    view = \"basic\";\n                    break;\n                case IoUtils.LASTMOD_TIME_VIEW_ATTR:\n                    view = \"basic\";\n                    break;\n                case IoUtils.LASTACC_TIME_VIEW_ATTR:\n                    view = \"basic\";\n                    break;\n                case IoUtils.EXTENDED_VIEW_ATTR:\n                    view = \"extended\";\n                    break;\n                default: // ignored\n            }\n            if ((GenericUtils.length(view) > 0) && (value != null)) {\n                try {\n                    setFileAttribute(file, view, attribute, value, options);\n                } catch (Exception e) {\n                    handleSetFileAttributeFailure(file, view, attribute, value, unsupported, e);\n                }\n            }\n        }\n\n        handleUnsupportedAttributes(unsupported);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2643,
          2707
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doStat",
        "signature": "Map doStat(int,String,int)",
        "lines_hint_csv": [
          1399,
          1413
        ],
        "code": "    protected Map<String, Object> doStat(int id, String path, int flags) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"doStat({})[id={}] SSH_FXP_STAT (path={}, flags=0x{})\",\n                    getServerSession(), id, path, Integer.toHexString(flags));\n        }\n\n        /*\n         * SSH_FXP_STAT and SSH_FXP_LSTAT only differ in that SSH_FXP_STAT follows symbolic links on the server, whereas\n         * SSH_FXP_LSTAT does not.\n         */\n        Path p = resolveFile(path);\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, p, SftpConstants.SSH_FXP_STAT, \"\", true);\n        return resolveFileAttributes(p, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1399,
          1414
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "getAttributes",
        "signature": "NavigableMap getAttributes(Path,LinkOption)",
        "lines_hint_csv": [
          2413,
          2415
        ],
        "code": "    protected NavigableMap<String, Object> getAttributes(Path file, LinkOption... options)\n            throws IOException {\n        return getAttributes(file, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2413,
          2416
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doFStat",
        "signature": "void doFStat(Buffer,int)",
        "lines_hint_csv": [
          683,
          699
        ],
        "code": "    protected void doFStat(Buffer buffer, int id) throws IOException {\n        String handle = buffer.getString();\n        int flags = SftpConstants.SSH_FILEXFER_ATTR_ALL;\n        int version = getVersion();\n        if (version >= SftpConstants.SFTP_V4) {\n            flags = buffer.getInt();\n        }\n\n        Map<String, ?> attrs;\n        try {\n            attrs = doFStat(id, handle, flags);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_FSTAT, handle, flags);\n            return;\n        }\n\n        sendAttrs(prepareReply(buffer), id, attrs);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          683,
          700
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doLStat",
        "signature": "Map doLStat(int,String,int)",
        "lines_hint_csv": [
          636,
          650
        ],
        "code": "    protected Map<String, Object> doLStat(int id, String path, int flags) throws IOException {\n        Path p = resolveFile(path);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doLStat({})[id={}] SSH_FXP_LSTAT (path={}[{}], flags=0x{})\",\n                    getServerSession(), id, path, p, Integer.toHexString(flags));\n        }\n\n        /*\n         * SSH_FXP_STAT and SSH_FXP_LSTAT only differ in that SSH_FXP_STAT follows symbolic links on the server, whereas\n         * SSH_FXP_LSTAT does not.\n         */\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, p, SftpConstants.SSH_FXP_LSTAT, \"\", false);\n        return resolveFileAttributes(p, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          636,
          651
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRealPath",
        "signature": "void doRealPath(Buffer,int)",
        "lines_hint_csv": [
          1416,
          1512
        ],
        "code": "    protected void doRealPath(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        boolean debugEnabled = log.isDebugEnabled();\n        ServerSession session = getServerSession();\n        if (debugEnabled) {\n            log.debug(\"doRealPath({})[id={}] SSH_FXP_REALPATH (path={})\", session, id, path);\n        }\n        path = GenericUtils.trimToEmpty(path);\n        if (GenericUtils.isEmpty(path)) {\n            path = \".\";\n        }\n\n        Map<String, ?> attrs = Collections.emptyMap();\n        Map.Entry<Path, Boolean> result;\n        try {\n            int version = getVersion();\n            if (version < SftpConstants.SFTP_V6) {\n                /*\n                 * See http://www.openssh.com/txt/draft-ietf-secsh-filexfer-02.txt:\n                 *\n                 * The SSH_FXP_REALPATH request can be used to have the server canonicalize any given path name to an\n                 * absolute path.\n                 *\n                 * See also SSHD-294\n                 */\n                Path p = resolveFile(path);\n                LinkOption[] options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_REALPATH, \"\", p);\n                result = doRealPathV345(id, path, p, options);\n            } else {\n                /*\n                 * See https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.9\n                 *\n                 * This field is optional, and if it is not present in the packet, it is assumed to be\n                 * SSH_FXP_REALPATH_NO_CHECK.\n                 */\n                int control = SftpConstants.SSH_FXP_REALPATH_NO_CHECK;\n                if (buffer.available() > 0) {\n                    control = buffer.getUByte();\n                    if (debugEnabled) {\n                        log.debug(\"doRealPath({}) - control=0x{} for path={}\",\n                                session, Integer.toHexString(control), path);\n                    }\n                }\n\n                Collection<String> extraPaths = new LinkedList<>();\n                while (buffer.available() > 0) {\n                    extraPaths.add(buffer.getString());\n                }\n\n                Path p = resolveFile(path);\n                LinkOption[] options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_REALPATH, \"\", p);\n                result = doRealPathV6(id, path, extraPaths, p, options);\n\n                p = result.getKey();\n                options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_REALPATH, \"\", p);\n                Boolean status = result.getValue();\n                switch (control) {\n                    case SftpConstants.SSH_FXP_REALPATH_STAT_IF:\n                        if (status == null) {\n                            attrs = handleUnknownStatusFileAttributes(\n                                    p, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n                        } else if (status) {\n                            try {\n                                attrs = getAttributes(p, options);\n                            } catch (IOException e) {\n                                debug(\"doRealPath({}) - failed ({}) to retrieve attributes of {}: {}\",\n                                        session, e.getClass().getSimpleName(), p, e.getMessage(), e);\n                            }\n                        } else {\n                            if (debugEnabled) {\n                                log.debug(\"doRealPath({}) - dummy attributes for non-existing file: {}\", session, p);\n                            }\n                        }\n                        break;\n                    case SftpConstants.SSH_FXP_REALPATH_STAT_ALWAYS:\n                        if (status == null) {\n                            attrs = handleUnknownStatusFileAttributes(\n                                    p, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n                        } else if (status) {\n                            attrs = getAttributes(p, options);\n                        } else {\n                            throw new NoSuchFileException(p.toString(), p.toString(), \"Real path N/A for target\");\n                        }\n                        break;\n                    case SftpConstants.SSH_FXP_REALPATH_NO_CHECK:\n                        break;\n                    default:\n                        log.warn(\"doRealPath({}) unknown control value 0x{} for path={}\",\n                                session, Integer.toHexString(control), p);\n                }\n            }\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_REALPATH, path);\n            return;\n        }\n\n        sendPath(prepareReply(buffer), id, result.getKey(), attrs);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1416,
          1513
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "resolveReportedFileAttributes",
        "signature": "NavigableMap resolveReportedFileAttributes(Path,int,LinkOption)",
        "lines_hint_csv": [
          2454,
          2480
        ],
        "code": "    protected NavigableMap<String, Object> resolveReportedFileAttributes(Path file, int flags, LinkOption... options)\n            throws IOException {\n        FileSystem fs = file.getFileSystem();\n        Collection<String> supportedViews = fs.supportedFileAttributeViews();\n        NavigableMap<String, Object> attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        Collection<String> views;\n\n        if (GenericUtils.isEmpty(supportedViews)) {\n            views = Collections.emptyList();\n        } else if (supportedViews.contains(\"unix\")) {\n            views = SftpFileSystemAccessor.DEFAULT_UNIX_VIEW;\n        } else {\n            views = GenericUtils.map(supportedViews, v -> v + \":*\");\n        }\n\n        for (String v : views) {\n            Map<String, ?> ta = readFileAttributes(file, v, options);\n            if (MapEntryUtils.isNotEmpty(ta)) {\n                attrs.putAll(ta);\n            }\n        }\n\n        Map<String, ?> completions = resolveMissingFileAttributes(file, flags, attrs, options);\n        if (MapEntryUtils.isNotEmpty(completions)) {\n            attrs.putAll(completions);\n        }\n        return attrs;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2454,
          2481
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doSetStat",
        "signature": "void doSetStat(int,String,int,String,Map,Boolean)",
        "lines_hint_csv": [
          668,
          680
        ],
        "code": "    protected void doSetStat(\n            int id, String path, int cmd, String extension, Map<String, ?> attrs, Boolean followLinks)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"doSetStat({})[id={}, cmd={}, extension={}]  (path={}, attrs={}, followLinks={})\",\n                    getServerSession(), id, cmd, extension, path, attrs, followLinks);\n        }\n\n        Path p = resolveFile(path);\n        if (followLinks == null) {\n            followLinks = resolvePathResolutionFollowLinks(cmd, extension, p);\n        }\n        doSetAttributes(cmd, extension, p, attrs, followLinks);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          668,
          681
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doMakeDirectory",
        "signature": "void doMakeDirectory(int,String,Map,boolean)",
        "lines_hint_csv": [
          1631,
          1670
        ],
        "code": "    protected void doMakeDirectory(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        Map<String, ?> attrs = readAttrs(buffer);\n        try {\n            doMakeDirectory(id, path, attrs, false);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e,\n                    SftpConstants.SSH_FXP_MKDIR, path, attrs);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1617,
          1629
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doSetStat",
        "signature": "void doSetStat(Buffer,int,String,int,Boolean)",
        "lines_hint_csv": [
          653,
          665
        ],
        "code": "    protected void doSetStat(\n            Buffer buffer, int id, String extension, int cmd, Boolean followLinks /* null = auto-resolve */)\n            throws IOException {\n        String path = buffer.getString();\n        Map<String, Object> attrs = readAttrs(buffer);\n        try {\n            doSetStat(id, path, cmd, extension, attrs, followLinks);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_SETSTAT, path);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          653,
          666
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemove",
        "signature": "void doRemove(Buffer,int)",
        "lines_hint_csv": [
          1673,
          1685
        ],
        "code": "    protected void doRemove(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        try {\n            /*\n             * If 'filename' is a symbolic link, the link is removed, not the file it points to.\n             */\n            doRemoveFile(id, path, false);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_REMOVE, path);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1673,
          1686
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemoveDirectory",
        "signature": "void doRemoveDirectory(Buffer,int)",
        "lines_hint_csv": [
          1564,
          1574
        ],
        "code": "    protected void doRemoveDirectory(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        try {\n            doRemoveDirectory(id, path, false);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e,\n                    SftpConstants.SSH_FXP_RMDIR, path);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1564,
          1575
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "signalRemovalPreConditionFailure",
        "signature": "E signalRemovalPreConditionFailure(int,String,Path,E,boolean)",
        "lines_hint_csv": [
          1716,
          1728
        ],
        "code": "    protected <E extends IOException> E signalRemovalPreConditionFailure(\n            int id, String pathValue, Path path, E thrown, boolean isRemoveDirectory)\n            throws IOException {\n        SftpEventListener listener = getSftpEventListenerProxy();\n        ServerSession session = getServerSession();\n        if (log.isDebugEnabled()) {\n            log.debug(\"signalRemovalPreConditionFailure(id={})[{}] signal {} for (directory={}) {}: {}\",\n                    id, pathValue, thrown.getClass().getSimpleName(), isRemoveDirectory, path, thrown.getMessage());\n        }\n\n        listener.removing(session, path, isRemoveDirectory);\n        listener.removed(session, path, isRemoveDirectory, thrown);\n        return thrown;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1716,
          1729
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "getLongName",
        "signature": "String getLongName(Path,String,LinkOption)",
        "lines_hint_csv": [
          2321,
          2324
        ],
        "code": "    protected String getLongName(Path f, String shortName, SftpClient.Attributes attributes) throws IOException {\n        return getLongName(f, shortName,\n                MapBuilder.<String, Object> builder()\n                        .put(IoUtils.OWNER_VIEW_ATTR, attributes.getOwner())\n                        .put(IoUtils.GROUP_VIEW_ATTR, attributes.getGroup())\n                        .put(IoUtils.SIZE_VIEW_ATTR, attributes.getSize())\n                        .put(IoUtils.DIRECTORY_VIEW_ATTR, attributes.isDirectory())\n                        .put(IoUtils.SYMLINK_VIEW_ATTR, attributes.isSymbolicLink())\n                        .put(IoUtils.PERMISSIONS_VIEW_ATTR, SftpHelper.permissionsToAttributes(attributes.getPermissions()))\n                        .put(IoUtils.LASTMOD_TIME_VIEW_ATTR, attributes.getModifyTime())\n                        .build());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2345,
          2356
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "validateRealPath",
        "signature": "SimpleImmutableEntry validateRealPath(int,String,Path,LinkOption)",
        "lines_hint_csv": [
          1556,
          1561
        ],
        "code": "    protected SimpleImmutableEntry<Path, Boolean> validateRealPath(\n            int id, String path, Path f, LinkOption... options)\n            throws IOException {\n        Path p = normalize(f);\n        Boolean status = IoUtils.checkFileExists(p, options);\n        return new SimpleImmutableEntry<>(p, status);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1556,
          1562
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemoveFile",
        "signature": "void doRemoveFile(int,String,boolean)",
        "lines_hint_csv": [
          1688,
          1713
        ],
        "code": "    protected void doRemoveFile(int id, String path, boolean followLinks) throws IOException {\n        Path resolvedPath = resolveFile(path);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doRemoveFile({})[id={}] SSH_FXP_REMOVE (path={}[{}])\", getServerSession(), id, path, resolvedPath);\n        }\n\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, resolvedPath, SftpConstants.SSH_FXP_REMOVE, \"\", followLinks);\n        SftpPathImpl.withAttributeCache(resolvedPath, p -> {\n            Boolean status = IoUtils.checkFileExists(p, options);\n            if (status == null) {\n                throw signalRemovalPreConditionFailure(id, path, p,\n                        new AccessDeniedException(p.toString(), p.toString(), \"Cannot determine existence of remove candidate\"),\n                        false);\n            } else if (!status) {\n                throw signalRemovalPreConditionFailure(id, path, p,\n                        new NoSuchFileException(p.toString(), p.toString(), \"Removal candidate not found\"), false);\n            } else if (Files.isDirectory(p, options)) {\n                throw signalRemovalPreConditionFailure(id, path, p,\n                        new SftpException(SftpConstants.SSH_FX_FILE_IS_A_DIRECTORY, p.toString() + \" is a folder\"), false);\n            }\n            return null;\n        });\n        // File exists and is not a directory\n        doRemove(id, resolvedPath, false);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1688,
          1714
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doReadDir",
        "signature": "void doReadDir(Buffer,int)",
        "lines_hint_csv": [
          656,
          745
        ],
        "code": "    protected void doReadDir(Buffer buffer, int id) throws IOException {\n        String handle = buffer.getString();\n        Handle h = handles.get(handle);\n        ServerSession session = getServerSession();\n        boolean debugEnabled = log.isDebugEnabled();\n        if (debugEnabled) {\n            log.debug(\"doReadDir({})[id={}] SSH_FXP_READDIR (handle={}[{}])\", session, id, handle, h);\n        }\n\n        Buffer reply = null;\n        try {\n            DirectoryHandle dh = validateHandle(handle, h, DirectoryHandle.class);\n            if (dh.isDone()) {\n                sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_EOF, \"Directory reading is done\");\n                return;\n            }\n\n            Path file = dh.getFile();\n            // If it's an SftpPath, don't re-check accessibily or existence. The underlying DirectoryHandle iterator\n            // contacts the upstream server, which should check. This repeated check here is questionable anyway.\n            // We did check in doOpenDir(). If access to the directory has changed in the meantime; it's undefined\n            // anyway what happens. If the directory is local, it depends on what the Java library would do with\n            // the DirectoryStream in that case if it reads the directory lazily. And if it is remote, it may well\n            // be that the upstream server has read the whole list from the local file system and buffered it, so\n            // it could serve the listing even if some other concurrent operation had removed the directory in the\n            // meantime, or had changed its access. It is entirely unspecified what shall happen if files inside\n            // the directory are changed while the directory is listed, and likewise it's entirely unspecified what\n            // shall happen if the directory itself is deleted while being listed.\n            //\n            // As long as the file system is local, this check here is local operations only, but if the directory\n            // is remote; this incurs several (up to three) remote LSTAT calls. We really can skip this here and let\n            // the upstream server decide.\n            if (!(file instanceof SftpPath)) {\n                LinkOption[] options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_READDIR, \"\", file);\n                Boolean status = IoUtils.checkFileExists(file, options);\n                if (status == null) {\n                    throw new AccessDeniedException(file.toString(), file.toString(), \"Cannot determine existence of read-dir\");\n                }\n\n                if (!status) {\n                    throw new NoSuchFileException(file.toString(), file.toString(), \"Non-existent directory\");\n                } else if (!Files.isDirectory(file, options)) {\n                    throw new NotDirectoryException(file.toString());\n                } else if (!Files.isReadable(file)) {\n                    throw new AccessDeniedException(file.toString(), file.toString(), \"Not readable\");\n                }\n            }\n\n            SftpEventListener listener = getSftpEventListenerProxy();\n            listener.readingEntries(session, handle, dh);\n\n            if (dh.isSendDot() || dh.isSendDotDot() || dh.hasNext()) {\n                // There is at least one file in the directory or we need to send the \"..\".\n                // Send only a few files at a time to not create packets of a too\n                // large size or have a timeout to occur.\n\n                reply = prepareReply(buffer);\n                reply.putByte((byte) SftpConstants.SSH_FXP_NAME);\n                reply.putInt(id);\n\n                int lenPos = reply.wpos();\n                reply.putUInt(0L);  // save room for actual length\n\n                int maxDataSize = SftpModuleProperties.MAX_READDIR_DATA_SIZE.getRequired(session);\n                int count = doReadDir(id, handle, dh, reply, maxDataSize, false);\n                BufferUtils.updateLengthPlaceholder(reply, lenPos, count);\n                if ((!dh.isSendDot()) && (!dh.isSendDotDot()) && (!dh.hasNext())) {\n                    dh.markDone();\n                }\n\n                int sftpVersion = getVersion();\n                Boolean indicator = SftpHelper.indicateEndOfNamesList(reply, sftpVersion, session, dh.isDone());\n                if (debugEnabled) {\n                    log.debug(\"doReadDir({})({})[{}] - sending {} entries - eol={} (SFTP version {})\", session, handle, h,\n                            count, indicator, sftpVersion);\n                }\n            } else {\n                // empty directory\n                dh.markDone();\n                sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_EOF, \"Empty directory\");\n                return;\n            }\n\n            Objects.requireNonNull(reply, \"No reply buffer created\");\n        } catch (IOException | RuntimeException | Error e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_READDIR, handle);\n            return;\n        }\n\n        send(reply);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          655,
          745
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doWrite",
        "signature": "void doWrite(int,String,long,int,byte,int,int)",
        "lines_hint_csv": [
          815,
          852
        ],
        "code": "    protected void doWrite(\n            int id, String handle, long offset, int length, byte[] data, int doff, int remaining)\n            throws IOException {\n        Handle h = handles.get(handle);\n        ServerSession session = getServerSession();\n        int maxAllowed = SftpModuleProperties.MAX_WRITEDATA_PACKET_LENGTH.getRequired(session);\n        if (log.isTraceEnabled()) {\n            log.trace(\"doWrite({})[id={}] SSH_FXP_WRITE (handle={}[{}], offset={}, length={}, maxAllowed={})\",\n                    session, id, handle, h, offset, length, maxAllowed);\n        }\n\n        FileHandle fh = validateHandle(handle, h, FileHandle.class);\n        if (length < 0) {\n            throw new IllegalStateException(\"Bad length (\" + length + \") for writing to \" + fh);\n        }\n\n        if (remaining < length) {\n            throw new IllegalStateException(\"Not enough buffer data for writing to \" + fh\n                                            + \": required=\" + length + \", available=\" + remaining);\n        }\n\n        if (length > maxAllowed) {\n            throw new IOException(\"Reuested write size (\" + length + \") exceeds max. allowed (\" + maxAllowed + \")\");\n        }\n\n        SftpEventListener listener = getSftpEventListenerProxy();\n        listener.writing(session, handle, fh, offset, data, doff, length);\n        try {\n            if (fh.isOpenAppend()) {\n                fh.append(data, doff, length);\n            } else {\n                fh.write(data, doff, length, offset);\n            }\n        } catch (IOException | RuntimeException | Error e) {\n            listener.written(session, handle, fh, offset, data, doff, length, e);\n            throw e;\n        }\n        listener.written(session, handle, fh, offset, data, doff, length, null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          814,
          852
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doFStat",
        "signature": "Map doFStat(int,String,int)",
        "lines_hint_csv": [
          799,
          811
        ],
        "code": "    protected Map<String, Object> doFStat(int id, String handle, int flags) throws IOException {\n        Handle h = handles.get(handle);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doFStat({})[id={}] SSH_FXP_FSTAT (handle={}[{}], flags=0x{})\",\n                    getServerSession(), id, handle, h, Integer.toHexString(flags));\n        }\n\n        Handle fileHandle = validateHandle(handle, h, Handle.class);\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        Path file = fileHandle.getFile();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, file, SftpConstants.SSH_FXP_FSTAT, \"\", true);\n        return resolveFileAttributes(file, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          798,
          811
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doOpenDir",
        "signature": "String doOpenDir(int,String,Path,LinkOption)",
        "lines_hint_csv": [
          749,
          780
        ],
        "code": "    protected String doOpenDir(int id, String path, Path dir, LinkOption... options) throws IOException {\n        SftpPathImpl.withAttributeCache(dir, p -> {\n            Boolean status = IoUtils.checkFileExists(p, options);\n            if (status == null) {\n                throw signalOpenFailure(id, path, p, true,\n                        new AccessDeniedException(p.toString(), p.toString(), \"Cannot determine open-dir existence\"));\n            }\n\n            if (!status) {\n                throw signalOpenFailure(id, path, p, true,\n                        new NoSuchFileException(path, path, \"Referenced target directory N/A\"));\n            } else if (!Files.isDirectory(p, options)) {\n                throw signalOpenFailure(id, path, p, true, new NotDirectoryException(path));\n            } else if (!Files.isReadable(p)) {\n                throw signalOpenFailure(id, path, p, true,\n                        new AccessDeniedException(p.toString(), p.toString(), \"Not readable\"));\n            }\n            return null;\n        });\n        // Directory exists and is readable\n        String handle;\n        try {\n            synchronized (handles) {\n                handle = generateFileHandle(dir);\n                DirectoryHandle dirHandle = new DirectoryHandle(this, dir, handle);\n                handles.put(handle, dirHandle);\n            }\n        } catch (IOException e) {\n            throw signalOpenFailure(id, path, dir, true, e);\n        }\n\n        return handle;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          748,
          780
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpTest.java",
        "class_name": "SftpTest",
        "method_name": "testSftpFileSystemAccessor",
        "signature": "void testSftpFileSystemAccessor(SftpSubsystemProxy,FileHandle,Path,String,Set,FileAttribute,SftpSubsystemProxy,DirectoryHandle,Path,String)",
        "lines_hint_csv": [
          689,
          771
        ],
        "code": "    public void testSftpFileSystemAccessor() throws Exception {\n        List<? extends SubsystemFactory> factories = sshd.getSubsystemFactories();\n        assertEquals(\"Mismatched subsystem factories count\", 1, GenericUtils.size(factories));\n\n        SubsystemFactory f = factories.get(0);\n        assertObjectInstanceOf(\"Not an SFTP subsystem factory\", SftpSubsystemFactory.class, f);\n\n        SftpSubsystemFactory factory = (SftpSubsystemFactory) f;\n        SftpFileSystemAccessor accessor = factory.getFileSystemAccessor();\n        try {\n            AtomicReference<Path> fileHolder = new AtomicReference<>();\n            AtomicReference<Path> dirHolder = new AtomicReference<>();\n            factory.setFileSystemAccessor(new SftpFileSystemAccessor() {\n                @Override\n                public SeekableByteChannel openFile(\n                        SftpSubsystemProxy subsystem, FileHandle fileHandle, Path file,\n                        String handle, Set<? extends OpenOption> options, FileAttribute<?>... attrs)\n                        throws IOException {\n                    fileHolder.set(file);\n                    return SftpFileSystemAccessor.super.openFile(\n                            subsystem, fileHandle, file, handle, options, attrs);\n                }\n\n                @Override\n                public DirectoryStream<Path> openDirectory(\n                        SftpSubsystemProxy subsystem, DirectoryHandle dirHandle, Path dir, String handle)\n                        throws IOException {\n                    dirHolder.set(dir);\n                    return SftpFileSystemAccessor.super.openDirectory(subsystem, dirHandle, dir, handle);\n                }\n\n                @Override\n                public String toString() {\n                    return SftpFileSystemAccessor.class.getSimpleName() + \"[\" + getCurrentTestName() + \"]\";\n                }\n            });\n\n            Path targetPath = detectTargetFolder();\n            Path parentPath = targetPath.getParent();\n            Path localFile = CommonTestSupportUtils.resolve(\n                    targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName(), getCurrentTestName());\n            Files.createDirectories(localFile.getParent());\n            byte[] expected = (getClass().getName() + \"#\" + getCurrentTestName() + \"[\" + localFile + \"]\")\n                    .getBytes(StandardCharsets.UTF_8);\n            Files.write(localFile, expected, StandardOpenOption.CREATE);\n            try (SftpClient sftp = createSingleSessionClient()) {\n                byte[] actual = new byte[expected.length];\n                try (InputStream stream = sftp.read(\n                        CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, localFile), OpenMode.Read)) {\n                    IoUtils.readFully(stream, actual);\n                }\n\n                Path remoteFile = fileHolder.getAndSet(null);\n                assertNotNull(\"No remote file holder value\", remoteFile);\n                assertEquals(\"Mismatched opened local files\", localFile.toFile(), remoteFile.toFile());\n                assertArrayEquals(\"Mismatched retrieved file contents\", expected, actual);\n\n                Path localParent = localFile.getParent();\n                String localName = Objects.toString(localFile.getFileName(), null);\n                try (CloseableHandle handle = sftp.openDir(\n                        CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, localParent))) {\n                    List<DirEntry> entries = sftp.readDir(handle);\n                    Path remoteParent = dirHolder.getAndSet(null);\n                    assertNotNull(\"No remote folder holder value\", remoteParent);\n                    assertEquals(\"Mismatched opened folder\", localParent.toFile(), remoteParent.toFile());\n                    assertFalse(\"No dir entries\", GenericUtils.isEmpty(entries));\n\n                    for (DirEntry de : entries) {\n                        Attributes attrs = de.getAttributes();\n                        if (!attrs.isRegularFile()) {\n                            continue;\n                        }\n\n                        if (localName.equals(de.getFilename())) {\n                            return;\n                        }\n                    }\n\n                    fail(\"Cannot find listing of \" + localName);\n                }\n            }\n        } finally {\n            factory.setFileSystemAccessor(accessor); // restore original\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          689,
          773
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpTest.java",
        "class_name": "SftpTest",
        "method_name": "testCannotEscapeRoot",
        "signature": "void testCannotEscapeRoot(boolean)",
        "lines_hint_csv": [
          363,
          391
        ],
        "code": "    private void testCannotEscapeRoot(boolean useAbsolutePath) throws Exception {\n        Path targetPath = detectTargetFolder();\n        Path lclSftp = CommonTestSupportUtils.resolve(\n                targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName(), getCurrentTestName());\n        lclSftp = assertHierarchyTargetFolderExists(lclSftp);\n        sshd.setFileSystemFactory(new VirtualFileSystemFactory(lclSftp));\n\n        String escapePath;\n        if (useAbsolutePath) {\n            escapePath = targetPath.toString();\n            if (OsUtils.isWin32()) {\n                escapePath = \"/\" + escapePath.replace(File.separatorChar, '/');\n            }\n        } else {\n            Path parent = lclSftp.getParent();\n            Path forbidden = Files.createDirectories(parent.resolve(\"forbidden\"));\n            escapePath = \"../\" + forbidden.getFileName();\n        }\n\n        try (SftpClient sftp = createSingleSessionClient()) {\n            SftpClient.Attributes attrs = sftp.stat(escapePath);\n            fail(\"Unexpected escape success for path=\" + escapePath + \": \" + attrs);\n        } catch (SftpException e) {\n            int expected = OsUtils.isWin32() || (!useAbsolutePath)\n                    ? SftpConstants.SSH_FX_INVALID_FILENAME\n                    : SftpConstants.SSH_FX_NO_SUCH_FILE;\n            assertEquals(\"Mismatched status for \" + escapePath,\n                    SftpConstants.getStatusName(expected),\n                    SftpConstants.getStatusName(e.getStatus()));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          363,
          393
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpVersionsTest.java",
        "class_name": "SftpVersionsTest",
        "method_name": "testSftpExtensionsEncodeDecode",
        "signature": "void testSftpExtensionsEncodeDecode(ChannelSession,Path,int,LinkOption,Path,Map,LinkOption,ServerSession,Path,Map,ServerSession,Path,Map,Throwable)",
        "lines_hint_csv": [
          401,
          511
        ],
        "code": "    public void testSftpExtensionsEncodeDecode() throws Exception {\n        Class<?> anchor = getClass();\n        Map<String, String> expExtensions = NavigableMapBuilder.<String, String> builder(String.CASE_INSENSITIVE_ORDER)\n                .put(\"class\", anchor.getSimpleName())\n                .put(\"package\", anchor.getPackage().getName())\n                .put(\"method\", getCurrentTestName())\n                .build();\n\n        final AtomicInteger numInvocations = new AtomicInteger(0);\n        SftpSubsystemFactory factory = new SftpSubsystemFactory() {\n            @Override\n            public Command createSubsystem(ChannelSession channel) throws IOException {\n                SftpSubsystem subsystem = new SftpSubsystem(channel, this) {\n                    @Override\n                    protected NavigableMap<String, Object> resolveFileAttributes(Path file, int flags, LinkOption... options)\n                            throws IOException {\n                        NavigableMap<String, Object> attrs = super.resolveFileAttributes(file, flags, options);\n                        if (MapEntryUtils.isEmpty(attrs)) {\n                            attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n                        }\n\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, String> actExtensions\n                                = (Map<String, String>) attrs.put(IoUtils.EXTENDED_VIEW_ATTR, expExtensions);\n                        if (actExtensions != null) {\n                            log.info(\"resolveFileAttributes(\" + file + \") replaced extensions: \" + actExtensions);\n                        }\n                        return attrs;\n                    }\n\n                    @Override\n                    protected void setFileExtensions(Path file, Map<String, byte[]> extensions, LinkOption... options)\n                            throws IOException {\n                        assertExtensionsMapEquals(\"setFileExtensions(\" + file + \")\", expExtensions, extensions);\n                        numInvocations.incrementAndGet();\n\n                        int currentVersion = getTestedVersion();\n                        try {\n                            super.setFileExtensions(file, extensions, options);\n                            assertFalse(\"Expected exception not generated for version=\" + currentVersion,\n                                    currentVersion >= SftpConstants.SFTP_V6);\n                        } catch (UnsupportedOperationException e) {\n                            assertTrue(\"Unexpected exception for version=\" + currentVersion,\n                                    currentVersion >= SftpConstants.SFTP_V6);\n                        }\n                    }\n                };\n                Collection<? extends SftpEventListener> listeners = getRegisteredListeners();\n                if (GenericUtils.size(listeners) > 0) {\n                    for (SftpEventListener l : listeners) {\n                        subsystem.addSftpEventListener(l);\n                    }\n                }\n\n                return subsystem;\n            }\n        };\n\n        factory.addSftpEventListener(new AbstractSftpEventListenerAdapter() {\n            @Override\n            public void modifyingAttributes(ServerSession session, Path path, Map<String, ?> attrs) {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, byte[]> actExtensions\n                        = MapEntryUtils.isEmpty(attrs) ? null : (Map<String, byte[]>) attrs.get(IoUtils.EXTENDED_VIEW_ATTR);\n                assertExtensionsMapEquals(\"modifying(\" + path + \")\", expExtensions, actExtensions);\n            }\n\n            @Override\n            public void modifiedAttributes(ServerSession session, Path path, Map<String, ?> attrs, Throwable thrown) {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, byte[]> actExtensions\n                        = MapEntryUtils.isEmpty(attrs) ? null : (Map<String, byte[]>) attrs.get(IoUtils.EXTENDED_VIEW_ATTR);\n                assertExtensionsMapEquals(\"modified(\" + path + \")\", expExtensions, actExtensions);\n            }\n        });\n\n        Path targetPath = detectTargetFolder();\n        Path lclSftp\n                = CommonTestSupportUtils.resolve(targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName());\n        Files.createDirectories(lclSftp.resolve(\"sub-folder\"));\n        Path lclFile\n                = assertHierarchyTargetFolderExists(lclSftp).resolve(getCurrentTestName() + \"-\" + getTestedVersion() + \".txt\");\n        Files.write(lclFile, getClass().getName().getBytes(StandardCharsets.UTF_8));\n\n        Path parentPath = targetPath.getParent();\n        String remotePath = CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, lclSftp);\n        int numInvoked = 0;\n\n        List<? extends SubsystemFactory> factories = sshd.getSubsystemFactories();\n        sshd.setSubsystemFactories(Collections.singletonList(factory));\n        try (ClientSession session = createAuthenticatedClientSession();\n             SftpClient sftp = createSftpClient(session, getTestedVersion())) {\n            for (DirEntry entry : sftp.readDir(remotePath)) {\n                String fileName = entry.getFilename();\n                if (\".\".equals(fileName) || \"..\".equals(fileName)) {\n                    continue;\n                }\n\n                Attributes attrs = validateSftpFileTypeAndPermissions(fileName, getTestedVersion(), entry.getAttributes());\n                Map<String, byte[]> actExtensions = attrs.getExtensions();\n                assertExtensionsMapEquals(\"dirEntry=\" + fileName, expExtensions, actExtensions);\n                attrs.getFlags().clear();\n                attrs.setStringExtensions(expExtensions);\n                sftp.setStat(remotePath + \"/\" + fileName, attrs);\n                numInvoked++;\n            }\n        } finally {\n            sshd.setSubsystemFactories(factories);\n        }\n\n        assertEquals(\"Mismatched invocations count\", numInvoked, numInvocations.get());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          401,
          512
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpVersionsTest.java",
        "class_name": "SftpVersionsTest",
        "method_name": "testSftpACLEncodeDecode",
        "signature": "void testSftpACLEncodeDecode(ChannelSession,Path,int,LinkOption,Path,List,LinkOption,ServerSession,Path,Map,ServerSession,Path,Map,Throwable)",
        "lines_hint_csv": [
          276,
          397
        ],
        "code": "    public void testSftpACLEncodeDecode() throws Exception {\n        AclEntryType[] types = AclEntryType.values();\n        final List<AclEntry> aclExpected = new ArrayList<>(types.length);\n        for (AclEntryType t : types) {\n            aclExpected.add(AclEntry.newBuilder()\n                    .setType(t)\n                    .setFlags(EnumSet.allOf(AclEntryFlag.class))\n                    .setPermissions(EnumSet.allOf(AclEntryPermission.class))\n                    .setPrincipal(new DefaultGroupPrincipal(getCurrentTestName() + \"@\" + getClass().getPackage().getName()))\n                    .build());\n        }\n\n        AtomicInteger numInvocations = new AtomicInteger(0);\n        SftpSubsystemFactory factory = new SftpSubsystemFactory() {\n            @Override\n            public Command createSubsystem(ChannelSession channel) throws IOException {\n                SftpSubsystem subsystem = new SftpSubsystem(channel, this) {\n                    @Override\n                    protected NavigableMap<String, Object> resolveFileAttributes(Path file, int flags, LinkOption... options)\n                            throws IOException {\n                        NavigableMap<String, Object> attrs = super.resolveFileAttributes(file, flags, options);\n                        if (MapEntryUtils.isEmpty(attrs)) {\n                            attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n                        }\n\n                        @SuppressWarnings(\"unchecked\")\n                        List<AclEntry> aclActual = (List<AclEntry>) attrs.put(IoUtils.ACL_VIEW_ATTR, aclExpected);\n                        if (aclActual != null) {\n                            log.info(\"resolveFileAttributes(\" + file + \") replaced ACL: \" + aclActual);\n                        }\n                        return attrs;\n                    }\n\n                    @Override\n                    protected void setFileAccessControl(Path file, List<AclEntry> aclActual, LinkOption... options)\n                            throws IOException {\n                        if (aclActual != null) {\n                            assertListEquals(\"Mismatched ACL set for file=\" + file, aclExpected, aclActual);\n                            numInvocations.incrementAndGet();\n                        }\n                    }\n                };\n                Collection<? extends SftpEventListener> listeners = getRegisteredListeners();\n                if (GenericUtils.size(listeners) > 0) {\n                    for (SftpEventListener l : listeners) {\n                        subsystem.addSftpEventListener(l);\n                    }\n                }\n\n                return subsystem;\n            }\n        };\n\n        factory.addSftpEventListener(new AbstractSftpEventListenerAdapter() {\n            @Override\n            public void modifyingAttributes(ServerSession session, Path path, Map<String, ?> attrs) {\n                @SuppressWarnings(\"unchecked\")\n                List<AclEntry> aclActual\n                        = MapEntryUtils.isEmpty(attrs) ? null : (List<AclEntry>) attrs.get(IoUtils.ACL_VIEW_ATTR);\n                if (getTestedVersion() > SftpConstants.SFTP_V3) {\n                    assertListEquals(\"Mismatched modifying ACL for file=\" + path, aclExpected, aclActual);\n                } else {\n                    assertNull(\"Unexpected modifying ACL for file=\" + path, aclActual);\n                }\n            }\n\n            @Override\n            public void modifiedAttributes(\n                    ServerSession session, Path path, Map<String, ?> attrs, Throwable thrown) {\n                @SuppressWarnings(\"unchecked\")\n                List<AclEntry> aclActual\n                        = MapEntryUtils.isEmpty(attrs) ? null : (List<AclEntry>) attrs.get(IoUtils.ACL_VIEW_ATTR);\n                if (getTestedVersion() > SftpConstants.SFTP_V3) {\n                    assertListEquals(\"Mismatched modified ACL for file=\" + path, aclExpected, aclActual);\n                } else {\n                    assertNull(\"Unexpected modified ACL for file=\" + path, aclActual);\n                }\n            }\n        });\n\n        Path targetPath = detectTargetFolder();\n        Path lclSftp = CommonTestSupportUtils.resolve(\n                targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName());\n        Files.createDirectories(lclSftp.resolve(\"sub-folder\"));\n        Path lclFile = assertHierarchyTargetFolderExists(lclSftp)\n                .resolve(getCurrentTestName() + \"-\" + getTestedVersion() + \".txt\");\n        Files.write(lclFile, getClass().getName().getBytes(StandardCharsets.UTF_8));\n\n        Path parentPath = targetPath.getParent();\n        String remotePath = CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, lclSftp);\n        int numInvoked = 0;\n\n        List<? extends SubsystemFactory> factories = sshd.getSubsystemFactories();\n        sshd.setSubsystemFactories(Collections.singletonList(factory));\n        try (ClientSession session = createAuthenticatedClientSession();\n             SftpClient sftp = createSftpClient(session, getTestedVersion())) {\n            for (DirEntry entry : sftp.readDir(remotePath)) {\n                String fileName = entry.getFilename();\n                if (\".\".equals(fileName) || \"..\".equals(fileName)) {\n                    continue;\n                }\n\n                Attributes attrs = validateSftpFileTypeAndPermissions(fileName, getTestedVersion(), entry.getAttributes());\n                List<AclEntry> aclActual = attrs.getAcl();\n                if (getTestedVersion() == SftpConstants.SFTP_V3) {\n                    assertNull(\"Unexpected ACL for entry=\" + fileName, aclActual);\n                } else {\n                    assertListEquals(\"Mismatched ACL for entry=\" + fileName, aclExpected, aclActual);\n                }\n\n                attrs.getFlags().clear();\n                attrs.setAcl(aclExpected);\n                sftp.setStat(remotePath + \"/\" + fileName, attrs);\n                if (getTestedVersion() > SftpConstants.SFTP_V3) {\n                    numInvoked++;\n                }\n            }\n        } finally {\n            sshd.setSubsystemFactories(factories);\n        }\n\n        assertEquals(\"Mismatched invocations count\", numInvoked, numInvocations.get());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          276,
          398
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystem.java",
        "class_name": "RootedFileSystem",
        "method_name": "getFileStores",
        "signature": "Iterable getFileStores()",
        "lines_hint_csv": [
          93,
          94
        ],
        "code": "    public Iterable<FileStore> getFileStores() {\n        return rootFs.getFileStores();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          93,
          95
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "isHidden",
        "signature": "boolean isHidden(Path)",
        "lines_hint_csv": [
          334,
          337
        ],
        "code": "    public boolean isHidden(Path path) throws IOException {\n        Path r = unroot(path);\n        FileSystemProvider p = provider(r);\n        return p.isHidden(r);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          334,
          338
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "resolveLocalPath",
        "signature": "Path resolveLocalPath(RootedPath)",
        "lines_hint_csv": [
          468,
          502
        ],
        "code": "    protected Path resolveLocalPath(RootedPath path) {\n        RootedPath absPath = Objects.requireNonNull(path, \"No rooted path to resolve\").toAbsolutePath();\n        RootedFileSystem rfs = absPath.getFileSystem();\n        Path root = rfs.getRoot();\n        FileSystem lfs = root.getFileSystem();\n\n        String rSep = ValidateUtils.checkNotNullAndNotEmpty(rfs.getSeparator(), \"No rooted file system separator\");\n        ValidateUtils.checkTrue(rSep.length() == 1, \"Bad rooted file system separator: %s\", rSep);\n        char rootedSeparator = rSep.charAt(0);\n\n        String lSep = ValidateUtils.checkNotNullAndNotEmpty(lfs.getSeparator(), \"No local file system separator\");\n        ValidateUtils.checkTrue(lSep.length() == 1, \"Bad local file system separator: %s\", lSep);\n        char localSeparator = lSep.charAt(0);\n\n        String r = absPath.toString();\n        String subPath = r.substring(1);\n        if (rootedSeparator != localSeparator) {\n            subPath = subPath.replace(rootedSeparator, localSeparator);\n        }\n\n        Path resolved = root.resolve(subPath);\n        resolved = resolved.normalize();\n        resolved = resolved.toAbsolutePath();\n        if (log.isTraceEnabled()) {\n            log.trace(\"resolveLocalPath({}): {}\", absPath, resolved);\n        }\n\n        /*\n         * This can happen for Windows since we represent its paths as /C:/some/path, so substring(1) yields\n         * C:/some/path - which is resolved as an absolute path (which we don't want).\n         */\n        if (!resolved.startsWith(root)) {\n            throw new InvalidPathException(r, \"Not under root\");\n        }\n        return resolved;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          468,
          503
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "newDirectoryStream",
        "signature": "DirectoryStream newDirectoryStream(Path,DirectoryStream)",
        "lines_hint_csv": [
          196,
          199
        ],
        "code": "    public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {\n        Path r = unroot(dir);\n        FileSystemProvider p = provider(r);\n        return root(((RootedPath) dir).getFileSystem(), p.newDirectoryStream(r, filter));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          196,
          200
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "getFileSystem",
        "signature": "RootedFileSystem getFileSystem(Path)",
        "lines_hint_csv": [
          347,
          380
        ],
        "code": "    protected RootedFileSystem getFileSystem(Path path) throws FileSystemNotFoundException {\n        Path real = unroot(path);\n        Path rootInstance = null;\n        RootedFileSystem fsInstance = null;\n        synchronized (fileSystems) {\n            // Cannot use forEach because the referenced variable are not effectively final\n            for (Map.Entry<Path, RootedFileSystem> fse : fileSystems.entrySet()) {\n                Path root = fse.getKey();\n                RootedFileSystem fs = fse.getValue();\n                if (real.equals(root)) {\n                    return fs; // we were lucky to have the root\n                }\n\n                if (!real.startsWith(root)) {\n                    continue;\n                }\n\n                // if already have a candidate prefer the longer match since both are prefixes of the real path\n                if ((rootInstance == null) || (rootInstance.getNameCount() < root.getNameCount())) {\n                    rootInstance = root;\n                    fsInstance = fs;\n                }\n            }\n        }\n\n        if (fsInstance == null) {\n            throw new FileSystemNotFoundException(path.toString());\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"getFileSystem({}): {}\", path, fsInstance);\n        }\n\n        return fsInstance;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          347,
          381
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "root",
        "signature": "DirectoryStream root(RootedFileSystem,DirectoryStream)",
        "lines_hint_csv": [
          202,
          211
        ],
        "code": "    protected DirectoryStream<Path> root(RootedFileSystem rfs, DirectoryStream<Path> ds) {\n        return new DirectoryStream<Path>() {\n            @Override\n            public Iterator<Path> iterator() {\n                return root(rfs, ds.iterator());\n            }\n\n            @Override\n            public void close() throws IOException {\n                ds.close();\n            }\n        };\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          202,
          214
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "copy",
        "signature": "void copy(Path,Path,CopyOption)",
        "lines_hint_csv": [
          304,
          311
        ],
        "code": "    public void copy(Path source, Path target, CopyOption... options) throws IOException {\n        Path s = unroot(source);\n        Path t = unroot(target);\n        if (log.isTraceEnabled()) {\n            log.trace(\"copy({})[{}]: {}[{}]\", source, s, target, t);\n        }\n        FileSystemProvider p = provider(s);\n        p.copy(s, t, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          304,
          312
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "newOutputStream",
        "signature": "OutputStream newOutputStream(Path,OpenOption)",
        "lines_hint_csv": [
          164,
          167
        ],
        "code": "    public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n        Path r = unroot(path);\n        FileSystemProvider p = provider(r);\n        return p.newOutputStream(r, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          164,
          168
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "readSymbolicLink",
        "signature": "Path readSymbolicLink(Path)",
        "lines_hint_csv": [
          292,
          300
        ],
        "code": "    public Path readSymbolicLink(Path link) throws IOException {\n        Path r = unroot(link);\n        FileSystemProvider p = provider(r);\n        Path t = p.readSymbolicLink(r);\n        Path target = root((RootedFileSystem) link.getFileSystem(), t);\n        if (log.isTraceEnabled()) {\n            log.trace(\"readSymbolicLink({})[{}]: {}[{}]\", link, r, target, t);\n        }\n        return target;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          292,
          301
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "deleteIfExists",
        "signature": "boolean deleteIfExists(Path)",
        "lines_hint_csv": [
          282,
          288
        ],
        "code": "    public boolean deleteIfExists(Path path) throws IOException {\n        Path r = unroot(path);\n        if (log.isTraceEnabled()) {\n            log.trace(\"deleteIfExists({}): {}\", path, r);\n        }\n        FileSystemProvider p = provider(r);\n        return p.deleteIfExists(r);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          282,
          289
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java",
        "class_name": "RootedFileSystemProvider",
        "method_name": "unroot",
        "signature": "Path unroot(Path)",
        "lines_hint_csv": [
          453,
          460
        ],
        "code": "    protected Path unroot(Path path) {\n        Objects.requireNonNull(path, \"No path to unroot\");\n        if (!(path instanceof RootedPath)) {\n            throw new ProviderMismatchException(\"unroot(\" + path + \") is not a \" + RootedPath.class.getSimpleName()\n                                                + \" but rather a \" + path.getClass().getSimpleName());\n        }\n\n        return resolveLocalPath((RootedPath) path);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          453,
          461
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/util/BaseFileSystem.java",
        "class_name": "BaseFileSystem",
        "method_name": "getPathMatcher",
        "signature": "PathMatcher getPathMatcher(String)",
        "lines_hint_csv": [
          125,
          152
        ],
        "code": "    public PathMatcher getPathMatcher(String syntaxAndPattern) {\n        int colonIndex = Objects.requireNonNull(syntaxAndPattern, \"No argument\").indexOf(':');\n        if ((colonIndex <= 0) || (colonIndex == syntaxAndPattern.length() - 1)) {\n            throw new IllegalArgumentException(\n                    \"syntaxAndPattern must have form \\\"syntax:pattern\\\" but was \\\"\" + syntaxAndPattern + \"\\\"\");\n        }\n\n        String syntax = syntaxAndPattern.substring(0, colonIndex);\n        String pattern = syntaxAndPattern.substring(colonIndex + 1);\n        String expr;\n        switch (syntax) {\n            case \"glob\":\n                expr = globToRegex(pattern);\n                break;\n            case \"regex\":\n                expr = pattern;\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported path matcher syntax: \\'\" + syntax + \"\\'\");\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"getPathMatcher({}): {}\", syntaxAndPattern, expr);\n        }\n\n        Pattern regex = Pattern.compile(expr);\n        return path -> {\n            Matcher m = regex.matcher(path.toString());\n            return m.matches();\n        };\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          125,
          154
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/file/util/BaseFileSystem.java",
        "class_name": "BaseFileSystem",
        "method_name": "getPath",
        "signature": "T getPath(String,String)",
        "lines_hint_csv": [
          79,
          112
        ],
        "code": "    public T getPath(String first, String... more) {\n        StringBuilder sb = new StringBuilder();\n        if (!GenericUtils.isEmpty(first)) {\n            appendDedupSep(sb, first.replace('\\\\', '/')); // in case we are running on Windows\n        }\n\n        if (GenericUtils.length(more) > 0) {\n            for (String segment : more) {\n                if ((sb.length() > 0) && (sb.charAt(sb.length() - 1) != '/')) {\n                    sb.append('/');\n                }\n                // in case we are running on Windows\n                appendDedupSep(sb, segment.replace('\\\\', '/'));\n            }\n        }\n\n        if ((sb.length() > 1) && (sb.charAt(sb.length() - 1) == '/')) {\n            sb.setLength(sb.length() - 1);\n        }\n\n        String path = sb.toString();\n        String root = null;\n        if (path.startsWith(\"/\")) {\n            root = \"/\";\n            path = path.substring(1);\n        }\n\n        String[] names = GenericUtils.split(path, '/');\n        T p = create(root, names);\n        if (log.isTraceEnabled()) {\n            log.trace(\"getPath({}, {}): {}\", first, Arrays.toString(more), p);\n        }\n\n        return p;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          79,
          113
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/util/io/IoUtils.java",
        "class_name": "IoUtils",
        "method_name": "read",
        "signature": "int read(InputStream,byte,int,int)",
        "lines_hint_csv": [
          471,
          484
        ],
        "code": "    public static int read(InputStream input, byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          457,
          459
        ]
      },
      {
        "file_path": "sshd-common/src/main/java/org/apache/sshd/common/util/io/IoUtils.java",
        "class_name": "IoUtils",
        "method_name": "checkFileExists",
        "signature": "Boolean checkFileExists(Path,LinkOption)",
        "lines_hint_csv": [
          396,
          414
        ],
        "code": "    public static Boolean checkFileExists(Path path, LinkOption... options) {\n        boolean followLinks = true;\n        for (LinkOption opt : options) {\n            if (opt == LinkOption.NOFOLLOW_LINKS) {\n                followLinks = false;\n                break;\n            }\n        }\n        try {\n            if (followLinks) {\n                path.getFileSystem().provider().checkAccess(path);\n            } else {\n                Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n            }\n            return Boolean.TRUE;\n        } catch (NoSuchFileException e) {\n            return Boolean.FALSE;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          396,
          416
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/common/file/root/RootedFileSystemProviderTest.java",
        "class_name": "FileHelper",
        "method_name": "readFile",
        "signature": "byte readFile(Path)",
        "lines_hint_csv": [
          304,
          309
        ],
        "code": "        public static byte[] readFile(Path source) throws IOException {\n            try (FileChannel fc = fileSystem.provider().newFileChannel(source,\n                    new TreeSet<OpenOption>(Arrays.asList(StandardOpenOption.READ)))) {\n                byte[] readBytes = new byte[(int) source.toFile().length()];\n                fc.read(ByteBuffer.wrap(readBytes));\n                return readBytes;\n            }\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          304,
          311
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/common/file/root/RootedFileSystemProviderTest.java",
        "class_name": "RootedFileSystemProviderTest",
        "method_name": "testRoot",
        "signature": "void testRoot()",
        "lines_hint_csv": [
          78,
          83
        ],
        "code": "    public void testRoot() {\n        Path root = fileSystem.getRoot();\n        assertTrue(\"Exists? \" + root, exists(root));\n        assertTrue(\"Dir? \" + root, isDir(root));\n        assertTrue(\"Readable? \" + root, isReadable(root));\n        assertTrue(root + \" rooted at \" + rootSandbox + \" ?\", isRootedAt(rootSandbox, root));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          78,
          84
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/common/file/root/RootedFileSystemProviderTest.java",
        "class_name": "RootedFileSystemProviderTest",
        "method_name": "testMkdir",
        "signature": "void testMkdir()",
        "lines_hint_csv": [
          88,
          90
        ],
        "code": "    public void testMkdir() throws IOException {\n        Path created = FileHelper.createDirectory(fileSystem.getPath(getCurrentTestName()));\n        assertTrue(exists(created) && isDir(created) && isReadable(created));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          88,
          91
        ]
      },
      {
        "file_path": "sshd-common/src/test/java/org/apache/sshd/util/test/CommonTestSupportUtils.java",
        "class_name": "CommonTestSupportUtils",
        "method_name": "deleteRecursive",
        "signature": "Path deleteRecursive(Path,LinkOption)",
        "lines_hint_csv": [
          497,
          523
        ],
        "code": "    public static Path deleteRecursive(Path path, LinkOption... options) throws IOException {\n        if ((path == null) || (!Files.exists(path))) {\n            return path;\n        }\n\n        if (Files.isDirectory(path)) {\n            try (DirectoryStream<Path> ds = Files.newDirectoryStream(path)) {\n                for (Path child : ds) {\n                    deleteRecursive(child, options);\n                }\n            }\n        }\n\n        try {\n            // seems that if a file is not writable it cannot be deleted\n            if (!Files.isWritable(path)) {\n                path.toFile().setWritable(true, false);\n            }\n            Files.delete(path);\n        } catch (IOException e) {\n            // same logic as deleteRecursive(File) which does not check if deletion succeeded\n            System.err.append(\"Failed (\").append(e.getClass().getSimpleName()).append(\")\")\n                    .append(\" to delete \").append(path.toString())\n                    .append(\": \").println(e.getMessage());\n        }\n\n        return path;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          497,
          524
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/client/fs/SftpFileSystemProvider.java",
        "class_name": "SftpFileSystemProvider",
        "method_name": "copy",
        "signature": "void copy(Path,Path,CopyOption)",
        "lines_hint_csv": [
          599,
          668
        ],
        "code": "    public void copy(Path source, Path target, CopyOption... options) throws IOException {\n        SftpPath src = toSftpPath(source);\n        SftpPath dst = toSftpPath(target);\n        if (src.getFileSystem() != dst.getFileSystem()) {\n            throw new ProviderMismatchException(\"Mismatched file system providers for \" + src + \" vs. \" + dst);\n        }\n        checkAccess(src);\n\n        boolean replaceExisting = false;\n        boolean copyAttributes = false;\n        boolean noFollowLinks = false;\n        for (CopyOption opt : options) {\n            replaceExisting |= opt == StandardCopyOption.REPLACE_EXISTING;\n            copyAttributes |= opt == StandardCopyOption.COPY_ATTRIBUTES;\n            noFollowLinks |= opt == LinkOption.NOFOLLOW_LINKS;\n        }\n        LinkOption[] linkOptions = IoUtils.getLinkOptions(!noFollowLinks);\n\n        // attributes of source file\n        BasicFileAttributes attrs = readAttributes(source, BasicFileAttributes.class, linkOptions);\n        if (attrs.isSymbolicLink()) {\n            throw new IOException(\"Copying of symbolic links not supported\");\n        }\n\n        // delete target if it exists and REPLACE_EXISTING is specified\n        Boolean status = IoUtils.checkFileExists(target, linkOptions);\n        if (status == null) {\n            throw new AccessDeniedException(\"Existence cannot be determined for copy target: \" + target);\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"copy({})[{}] {} => {}\", src.getFileSystem(), Arrays.asList(options), src, dst);\n        }\n\n        if (replaceExisting) {\n            deleteIfExists(target);\n        } else {\n            if (status) {\n                throw new FileAlreadyExistsException(target.toString());\n            }\n        }\n\n        // create directory or copy file\n        if (attrs.isDirectory()) {\n            createDirectory(target);\n        } else {\n            CopyFileExtension copyFile = src.getFileSystem().getClient().getExtension(CopyFileExtension.class);\n            if (copyFile.isSupported()) {\n                copyFile.copyFile(source.toString(), target.toString(), false);\n            } else {\n                try (InputStream in = newInputStream(source);\n                     OutputStream os = newOutputStream(target)) {\n                    IoUtils.copy(in, os);\n                }\n            }\n        }\n\n        // copy basic attributes to target\n        if (copyAttributes) {\n            BasicFileAttributeView view = getFileAttributeView(target, BasicFileAttributeView.class, linkOptions);\n            try {\n                view.setTimes(attrs.lastModifiedTime(), attrs.lastAccessTime(), attrs.creationTime());\n            } catch (Throwable x) {\n                // rollback\n                try {\n                    delete(target);\n                } catch (Throwable suppressed) {\n                    x.addSuppressed(suppressed);\n                }\n                throw x;\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          599,
          671
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/client/fs/SftpFileSystemProvider.java",
        "class_name": "SftpFileSystemProvider",
        "method_name": "move",
        "signature": "void move(Path,Path,CopyOption)",
        "lines_hint_csv": [
          674,
          732
        ],
        "code": "    public void move(Path source, Path target, CopyOption... options) throws IOException {\n        SftpPath src = toSftpPath(source);\n        SftpFileSystem fsSrc = src.getFileSystem();\n        SftpPath dst = toSftpPath(target);\n\n        if (src.getFileSystem() != dst.getFileSystem()) {\n            throw new ProviderMismatchException(\"Mismatched file system providers for \" + src + \" vs. \" + dst);\n        }\n        checkAccess(src);\n\n        boolean replaceExisting = false;\n        boolean copyAttributes = false;\n        boolean noFollowLinks = false;\n        for (CopyOption opt : options) {\n            replaceExisting |= opt == StandardCopyOption.REPLACE_EXISTING;\n            copyAttributes |= opt == StandardCopyOption.COPY_ATTRIBUTES;\n            noFollowLinks |= opt == LinkOption.NOFOLLOW_LINKS;\n        }\n        LinkOption[] linkOptions = IoUtils.getLinkOptions(noFollowLinks);\n\n        // attributes of source file\n        BasicFileAttributes attrs = readAttributes(source, BasicFileAttributes.class, linkOptions);\n        if (attrs.isSymbolicLink()) {\n            throw new IOException(\"Moving of source symbolic link (\" + source + \") to \" + target + \" not supported\");\n        }\n\n        // delete target if it exists and REPLACE_EXISTING is specified\n        Boolean status = IoUtils.checkFileExists(target, linkOptions);\n        if (status == null) {\n            throw new AccessDeniedException(\"Existence cannot be determined for move target \" + target);\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"move({})[{}] {} => {}\", src.getFileSystem(), Arrays.asList(options), src, dst);\n        }\n\n        if (replaceExisting) {\n            deleteIfExists(target);\n        } else if (status) {\n            throw new FileAlreadyExistsException(target.toString());\n        }\n\n        try (SftpClient sftp = fsSrc.getClient()) {\n            sftp.rename(src.toString(), dst.toString());\n        }\n\n        // copy basic attributes to target\n        if (copyAttributes) {\n            BasicFileAttributeView view = getFileAttributeView(target, BasicFileAttributeView.class, linkOptions);\n            try {\n                view.setTimes(attrs.lastModifiedTime(), attrs.lastAccessTime(), attrs.creationTime());\n            } catch (Throwable x) {\n                // rollback\n                try {\n                    delete(target);\n                } catch (Throwable suppressed) {\n                    x.addSuppressed(suppressed);\n                }\n                throw x;\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          674,
          735
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "signalRemovalPreConditionFailure",
        "signature": "E signalRemovalPreConditionFailure(int,String,Path,E,boolean)",
        "lines_hint_csv": [
          1716,
          1728
        ],
        "code": "    protected <E extends IOException> E signalRemovalPreConditionFailure(\n            int id, String pathValue, Path path, E thrown, boolean isRemoveDirectory)\n            throws IOException {\n        SftpEventListener listener = getSftpEventListenerProxy();\n        ServerSession session = getServerSession();\n        if (log.isDebugEnabled()) {\n            log.debug(\"signalRemovalPreConditionFailure(id={})[{}] signal {} for (directory={}) {}: {}\",\n                    id, pathValue, thrown.getClass().getSimpleName(), isRemoveDirectory, path, thrown.getMessage());\n        }\n\n        listener.removing(session, path, isRemoveDirectory);\n        listener.removed(session, path, isRemoveDirectory, thrown);\n        return thrown;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1716,
          1729
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doSetStat",
        "signature": "void doSetStat(int,String,int,String,Map,Boolean)",
        "lines_hint_csv": [
          668,
          680
        ],
        "code": "    protected void doSetStat(\n            int id, String path, int cmd, String extension, Map<String, ?> attrs, Boolean followLinks)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"doSetStat({})[id={}, cmd={}, extension={}]  (path={}, attrs={}, followLinks={})\",\n                    getServerSession(), id, cmd, extension, path, attrs, followLinks);\n        }\n\n        Path p = resolveFile(path);\n        if (followLinks == null) {\n            followLinks = resolvePathResolutionFollowLinks(cmd, extension, p);\n        }\n        doSetAttributes(cmd, extension, p, attrs, followLinks);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          668,
          681
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "getLongName",
        "signature": "String getLongName(Path,String,LinkOption)",
        "lines_hint_csv": [
          2321,
          2324
        ],
        "code": "    protected String getLongName(Path f, String shortName, SftpClient.Attributes attributes) throws IOException {\n        return getLongName(f, shortName,\n                MapBuilder.<String, Object> builder()\n                        .put(IoUtils.OWNER_VIEW_ATTR, attributes.getOwner())\n                        .put(IoUtils.GROUP_VIEW_ATTR, attributes.getGroup())\n                        .put(IoUtils.SIZE_VIEW_ATTR, attributes.getSize())\n                        .put(IoUtils.DIRECTORY_VIEW_ATTR, attributes.isDirectory())\n                        .put(IoUtils.SYMLINK_VIEW_ATTR, attributes.isSymbolicLink())\n                        .put(IoUtils.PERMISSIONS_VIEW_ATTR, SftpHelper.permissionsToAttributes(attributes.getPermissions()))\n                        .put(IoUtils.LASTMOD_TIME_VIEW_ATTR, attributes.getModifyTime())\n                        .build());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2345,
          2356
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRealPath",
        "signature": "void doRealPath(Buffer,int)",
        "lines_hint_csv": [
          1416,
          1512
        ],
        "code": "    protected void doRealPath(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        boolean debugEnabled = log.isDebugEnabled();\n        ServerSession session = getServerSession();\n        if (debugEnabled) {\n            log.debug(\"doRealPath({})[id={}] SSH_FXP_REALPATH (path={})\", session, id, path);\n        }\n        path = GenericUtils.trimToEmpty(path);\n        if (GenericUtils.isEmpty(path)) {\n            path = \".\";\n        }\n\n        Map<String, ?> attrs = Collections.emptyMap();\n        Map.Entry<Path, Boolean> result;\n        try {\n            int version = getVersion();\n            if (version < SftpConstants.SFTP_V6) {\n                /*\n                 * See http://www.openssh.com/txt/draft-ietf-secsh-filexfer-02.txt:\n                 *\n                 * The SSH_FXP_REALPATH request can be used to have the server canonicalize any given path name to an\n                 * absolute path.\n                 *\n                 * See also SSHD-294\n                 */\n                Path p = resolveFile(path);\n                LinkOption[] options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_REALPATH, \"\", p);\n                result = doRealPathV345(id, path, p, options);\n            } else {\n                /*\n                 * See https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13#section-8.9\n                 *\n                 * This field is optional, and if it is not present in the packet, it is assumed to be\n                 * SSH_FXP_REALPATH_NO_CHECK.\n                 */\n                int control = SftpConstants.SSH_FXP_REALPATH_NO_CHECK;\n                if (buffer.available() > 0) {\n                    control = buffer.getUByte();\n                    if (debugEnabled) {\n                        log.debug(\"doRealPath({}) - control=0x{} for path={}\",\n                                session, Integer.toHexString(control), path);\n                    }\n                }\n\n                Collection<String> extraPaths = new LinkedList<>();\n                while (buffer.available() > 0) {\n                    extraPaths.add(buffer.getString());\n                }\n\n                Path p = resolveFile(path);\n                LinkOption[] options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_REALPATH, \"\", p);\n                result = doRealPathV6(id, path, extraPaths, p, options);\n\n                p = result.getKey();\n                options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_REALPATH, \"\", p);\n                Boolean status = result.getValue();\n                switch (control) {\n                    case SftpConstants.SSH_FXP_REALPATH_STAT_IF:\n                        if (status == null) {\n                            attrs = handleUnknownStatusFileAttributes(\n                                    p, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n                        } else if (status) {\n                            try {\n                                attrs = getAttributes(p, options);\n                            } catch (IOException e) {\n                                debug(\"doRealPath({}) - failed ({}) to retrieve attributes of {}: {}\",\n                                        session, e.getClass().getSimpleName(), p, e.getMessage(), e);\n                            }\n                        } else {\n                            if (debugEnabled) {\n                                log.debug(\"doRealPath({}) - dummy attributes for non-existing file: {}\", session, p);\n                            }\n                        }\n                        break;\n                    case SftpConstants.SSH_FXP_REALPATH_STAT_ALWAYS:\n                        if (status == null) {\n                            attrs = handleUnknownStatusFileAttributes(\n                                    p, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n                        } else if (status) {\n                            attrs = getAttributes(p, options);\n                        } else {\n                            throw new NoSuchFileException(p.toString(), p.toString(), \"Real path N/A for target\");\n                        }\n                        break;\n                    case SftpConstants.SSH_FXP_REALPATH_NO_CHECK:\n                        break;\n                    default:\n                        log.warn(\"doRealPath({}) unknown control value 0x{} for path={}\",\n                                session, Integer.toHexString(control), p);\n                }\n            }\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_REALPATH, path);\n            return;\n        }\n\n        sendPath(prepareReply(buffer), id, result.getKey(), attrs);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1416,
          1513
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemoveFile",
        "signature": "void doRemoveFile(int,String,boolean)",
        "lines_hint_csv": [
          1688,
          1713
        ],
        "code": "    protected void doRemoveFile(int id, String path, boolean followLinks) throws IOException {\n        Path resolvedPath = resolveFile(path);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doRemoveFile({})[id={}] SSH_FXP_REMOVE (path={}[{}])\", getServerSession(), id, path, resolvedPath);\n        }\n\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, resolvedPath, SftpConstants.SSH_FXP_REMOVE, \"\", followLinks);\n        SftpPathImpl.withAttributeCache(resolvedPath, p -> {\n            Boolean status = IoUtils.checkFileExists(p, options);\n            if (status == null) {\n                throw signalRemovalPreConditionFailure(id, path, p,\n                        new AccessDeniedException(p.toString(), p.toString(), \"Cannot determine existence of remove candidate\"),\n                        false);\n            } else if (!status) {\n                throw signalRemovalPreConditionFailure(id, path, p,\n                        new NoSuchFileException(p.toString(), p.toString(), \"Removal candidate not found\"), false);\n            } else if (Files.isDirectory(p, options)) {\n                throw signalRemovalPreConditionFailure(id, path, p,\n                        new SftpException(SftpConstants.SSH_FX_FILE_IS_A_DIRECTORY, p.toString() + \" is a folder\"), false);\n            }\n            return null;\n        });\n        // File exists and is not a directory\n        doRemove(id, resolvedPath, false);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1688,
          1714
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doFStat",
        "signature": "void doFStat(Buffer,int)",
        "lines_hint_csv": [
          683,
          699
        ],
        "code": "    protected void doFStat(Buffer buffer, int id) throws IOException {\n        String handle = buffer.getString();\n        int flags = SftpConstants.SSH_FILEXFER_ATTR_ALL;\n        int version = getVersion();\n        if (version >= SftpConstants.SFTP_V4) {\n            flags = buffer.getInt();\n        }\n\n        Map<String, ?> attrs;\n        try {\n            attrs = doFStat(id, handle, flags);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_FSTAT, handle, flags);\n            return;\n        }\n\n        sendAttrs(prepareReply(buffer), id, attrs);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          683,
          700
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "getAttributes",
        "signature": "NavigableMap getAttributes(Path,LinkOption)",
        "lines_hint_csv": [
          2413,
          2415
        ],
        "code": "    protected NavigableMap<String, Object> getAttributes(Path file, LinkOption... options)\n            throws IOException {\n        return getAttributes(file, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2413,
          2416
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemoveDirectory",
        "signature": "void doRemoveDirectory(int,String,boolean)",
        "lines_hint_csv": [
          1577,
          1590
        ],
        "code": "    protected void doRemoveDirectory(int id, String path, boolean followLinks) throws IOException {\n        Path p = resolveFile(path);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doRemoveDirectory({})[id={}] SSH_FXP_RMDIR (path={})[{}]\", getServerSession(), id, path, p);\n        }\n\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, p, SftpConstants.SSH_FXP_RMDIR, \"\", followLinks);\n        if (Files.isDirectory(p, options)) {\n            doRemove(id, p, true);\n        } else {\n            throw signalRemovalPreConditionFailure(\n                    id, path, p, new NotDirectoryException(p.toString()), true);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1577,
          1592
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemoveDirectory",
        "signature": "void doRemoveDirectory(Buffer,int)",
        "lines_hint_csv": [
          1564,
          1574
        ],
        "code": "    protected void doRemoveDirectory(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        try {\n            doRemoveDirectory(id, path, false);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e,\n                    SftpConstants.SSH_FXP_RMDIR, path);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1564,
          1575
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doSetStat",
        "signature": "void doSetStat(Buffer,int,String,int,Boolean)",
        "lines_hint_csv": [
          653,
          665
        ],
        "code": "    protected void doSetStat(\n            Buffer buffer, int id, String extension, int cmd, Boolean followLinks /* null = auto-resolve */)\n            throws IOException {\n        String path = buffer.getString();\n        Map<String, Object> attrs = readAttrs(buffer);\n        try {\n            doSetStat(id, path, cmd, extension, attrs, followLinks);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_SETSTAT, path);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          653,
          666
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doRemove",
        "signature": "void doRemove(Buffer,int)",
        "lines_hint_csv": [
          1673,
          1685
        ],
        "code": "    protected void doRemove(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        try {\n            /*\n             * If 'filename' is a symbolic link, the link is removed, not the file it points to.\n             */\n            doRemoveFile(id, path, false);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_REMOVE, path);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1673,
          1686
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "validateRealPath",
        "signature": "SimpleImmutableEntry validateRealPath(int,String,Path,LinkOption)",
        "lines_hint_csv": [
          1556,
          1561
        ],
        "code": "    protected SimpleImmutableEntry<Path, Boolean> validateRealPath(\n            int id, String path, Path f, LinkOption... options)\n            throws IOException {\n        Path p = normalize(f);\n        Boolean status = IoUtils.checkFileExists(p, options);\n        return new SimpleImmutableEntry<>(p, status);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1556,
          1562
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "writeDirEntry",
        "signature": "void writeDirEntry(int,DirectoryHandle,Map,Buffer,int,Path,String,LinkOption)",
        "lines_hint_csv": [
          2292,
          2318
        ],
        "code": "    protected void writeDirEntry(\n            int id, DirectoryHandle dir, Map<String, Path> entries, Buffer buffer,\n            int index, Path f, String shortName, LinkOption... options)\n            throws IOException {\n        Map<String, ?> attrs = resolveFileAttributes(\n                f, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);\n        entries.put(shortName, f);\n\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        ServerSession session = getServerSession();\n        accessor.putRemoteFileName(this, f, buffer, shortName, true);\n\n        int version = getVersion();\n        if (version == SftpConstants.SFTP_V3) {\n            String longName = getLongName(f, shortName, options);\n            accessor.putRemoteFileName(this, f, buffer, longName, false);\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"writeDirEntry({} id={})[{}] - {} [{}]: {}\", session, id, index, shortName, longName, attrs);\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"writeDirEntry({} id={})[{}] - {}: {}\", session, id, index, shortName, attrs);\n            }\n        }\n\n        writeAttrs(buffer, attrs);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2292,
          2319
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "resolveReportedFileAttributes",
        "signature": "NavigableMap resolveReportedFileAttributes(Path,int,LinkOption)",
        "lines_hint_csv": [
          2454,
          2480
        ],
        "code": "    protected NavigableMap<String, Object> resolveReportedFileAttributes(Path file, int flags, LinkOption... options)\n            throws IOException {\n        FileSystem fs = file.getFileSystem();\n        Collection<String> supportedViews = fs.supportedFileAttributeViews();\n        NavigableMap<String, Object> attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        Collection<String> views;\n\n        if (GenericUtils.isEmpty(supportedViews)) {\n            views = Collections.emptyList();\n        } else if (supportedViews.contains(\"unix\")) {\n            views = SftpFileSystemAccessor.DEFAULT_UNIX_VIEW;\n        } else {\n            views = GenericUtils.map(supportedViews, v -> v + \":*\");\n        }\n\n        for (String v : views) {\n            Map<String, ?> ta = readFileAttributes(file, v, options);\n            if (MapEntryUtils.isNotEmpty(ta)) {\n                attrs.putAll(ta);\n            }\n        }\n\n        Map<String, ?> completions = resolveMissingFileAttributes(file, flags, attrs, options);\n        if (MapEntryUtils.isNotEmpty(completions)) {\n            attrs.putAll(completions);\n        }\n        return attrs;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2454,
          2481
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doStat",
        "signature": "Map doStat(int,String,int)",
        "lines_hint_csv": [
          1399,
          1413
        ],
        "code": "    protected Map<String, Object> doStat(int id, String path, int flags) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"doStat({})[id={}] SSH_FXP_STAT (path={}, flags=0x{})\",\n                    getServerSession(), id, path, Integer.toHexString(flags));\n        }\n\n        /*\n         * SSH_FXP_STAT and SSH_FXP_LSTAT only differ in that SSH_FXP_STAT follows symbolic links on the server, whereas\n         * SSH_FXP_LSTAT does not.\n         */\n        Path p = resolveFile(path);\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, p, SftpConstants.SSH_FXP_STAT, \"\", true);\n        return resolveFileAttributes(p, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1399,
          1414
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "handleUnknownStatusFileAttributes",
        "signature": "NavigableMap handleUnknownStatusFileAttributes(Path,int,LinkOption)",
        "lines_hint_csv": [
          2418,
          2435
        ],
        "code": "    protected NavigableMap<String, Object> handleUnknownStatusFileAttributes(\n            Path file, int flags, LinkOption... options)\n            throws IOException {\n        UnsupportedAttributePolicy policy = getUnsupportedAttributePolicy();\n        switch (policy) {\n            case Ignore:\n                break;\n            case ThrowException:\n                throw new AccessDeniedException(file.toString(), file.toString(),\n                        \"Cannot determine existence for attributes of target\");\n            case Warn:\n                log.warn(\"handleUnknownStatusFileAttributes({})[{}] cannot determine existence\", getServerSession(), file);\n                break;\n            default:\n                log.warn(\"handleUnknownStatusFileAttributes({})[{}] unknown policy: {}\", getServerSession(), file, policy);\n        }\n\n        return getAttributes(file, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2418,
          2436
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doMakeDirectory",
        "signature": "void doMakeDirectory(int,String,Map,boolean)",
        "lines_hint_csv": [
          1631,
          1670
        ],
        "code": "    protected void doMakeDirectory(Buffer buffer, int id) throws IOException {\n        String path = buffer.getString();\n        Map<String, ?> attrs = readAttrs(buffer);\n        try {\n            doMakeDirectory(id, path, attrs, false);\n        } catch (IOException | RuntimeException e) {\n            sendStatus(prepareReply(buffer), id, e,\n                    SftpConstants.SSH_FXP_MKDIR, path, attrs);\n            return;\n        }\n\n        sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, \"\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1617,
          1629
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "doLStat",
        "signature": "Map doLStat(int,String,int)",
        "lines_hint_csv": [
          636,
          650
        ],
        "code": "    protected Map<String, Object> doLStat(int id, String path, int flags) throws IOException {\n        Path p = resolveFile(path);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doLStat({})[id={}] SSH_FXP_LSTAT (path={}[{}], flags=0x{})\",\n                    getServerSession(), id, path, p, Integer.toHexString(flags));\n        }\n\n        /*\n         * SSH_FXP_STAT and SSH_FXP_LSTAT only differ in that SSH_FXP_STAT follows symbolic links on the server, whereas\n         * SSH_FXP_LSTAT does not.\n         */\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, p, SftpConstants.SSH_FXP_LSTAT, \"\", false);\n        return resolveFileAttributes(p, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          636,
          651
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java",
        "class_name": "AbstractSftpSubsystemHelper",
        "method_name": "setFileAttributes",
        "signature": "void setFileAttributes(Path,Map,LinkOption)",
        "lines_hint_csv": [
          2643,
          2706
        ],
        "code": "    protected void setFileAttributes(\n            Path file, Map<String, ?> attributes, LinkOption... options)\n            throws IOException {\n        Set<String> unsupported = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n        // Cannot use forEach because of the potential IOException being thrown\n        for (Map.Entry<String, ?> ae : attributes.entrySet()) {\n            String attribute = ae.getKey();\n            Object value = ae.getValue();\n            String view = null;\n            switch (attribute) {\n                case IoUtils.SIZE_VIEW_ATTR: {\n                    long newSize = ((Number) value).longValue();\n                    SftpFileSystemAccessor accessor = getFileSystemAccessor();\n                    Set<StandardOpenOption> openOptions = EnumSet.of(StandardOpenOption.WRITE);\n                    try (SeekableByteChannel channel = accessor.openFile(this, null, file, null, openOptions)) {\n                        channel.truncate(newSize);\n                        accessor.closeFile(this, null, file, null, channel, openOptions);\n                    }\n                    continue;\n                }\n                case IoUtils.USERID_VIEW_ATTR:\n                    view = \"unix\";\n                    break;\n                case IoUtils.GROUPID_VIEW_ATTR:\n                    view = \"unix\";\n                    break;\n                case IoUtils.OWNER_VIEW_ATTR:\n                    view = \"posix\";\n                    value = toUser(file, (UserPrincipal) value);\n                    break;\n                case IoUtils.GROUP_VIEW_ATTR:\n                    view = \"posix\";\n                    value = toGroup(file, (GroupPrincipal) value);\n                    break;\n                case IoUtils.PERMISSIONS_VIEW_ATTR:\n                    view = \"posix\";\n                    break;\n                case IoUtils.ACL_VIEW_ATTR:\n                    view = \"acl\";\n                    break;\n                case IoUtils.CREATE_TIME_VIEW_ATTR:\n                    view = \"basic\";\n                    break;\n                case IoUtils.LASTMOD_TIME_VIEW_ATTR:\n                    view = \"basic\";\n                    break;\n                case IoUtils.LASTACC_TIME_VIEW_ATTR:\n                    view = \"basic\";\n                    break;\n                case IoUtils.EXTENDED_VIEW_ATTR:\n                    view = \"extended\";\n                    break;\n                default: // ignored\n            }\n            if ((GenericUtils.length(view) > 0) && (value != null)) {\n                try {\n                    setFileAttribute(file, view, attribute, value, options);\n                } catch (Exception e) {\n                    handleSetFileAttributeFailure(file, view, attribute, value, unsupported, e);\n                }\n            }\n        }\n\n        handleUnsupportedAttributes(unsupported);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2643,
          2707
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doReadDir",
        "signature": "void doReadDir(Buffer,int)",
        "lines_hint_csv": [
          655,
          744
        ],
        "code": "    protected void doReadDir(Buffer buffer, int id) throws IOException {\n        String handle = buffer.getString();\n        Handle h = handles.get(handle);\n        ServerSession session = getServerSession();\n        boolean debugEnabled = log.isDebugEnabled();\n        if (debugEnabled) {\n            log.debug(\"doReadDir({})[id={}] SSH_FXP_READDIR (handle={}[{}])\", session, id, handle, h);\n        }\n\n        Buffer reply = null;\n        try {\n            DirectoryHandle dh = validateHandle(handle, h, DirectoryHandle.class);\n            if (dh.isDone()) {\n                sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_EOF, \"Directory reading is done\");\n                return;\n            }\n\n            Path file = dh.getFile();\n            // If it's an SftpPath, don't re-check accessibily or existence. The underlying DirectoryHandle iterator\n            // contacts the upstream server, which should check. This repeated check here is questionable anyway.\n            // We did check in doOpenDir(). If access to the directory has changed in the meantime; it's undefined\n            // anyway what happens. If the directory is local, it depends on what the Java library would do with\n            // the DirectoryStream in that case if it reads the directory lazily. And if it is remote, it may well\n            // be that the upstream server has read the whole list from the local file system and buffered it, so\n            // it could serve the listing even if some other concurrent operation had removed the directory in the\n            // meantime, or had changed its access. It is entirely unspecified what shall happen if files inside\n            // the directory are changed while the directory is listed, and likewise it's entirely unspecified what\n            // shall happen if the directory itself is deleted while being listed.\n            //\n            // As long as the file system is local, this check here is local operations only, but if the directory\n            // is remote; this incurs several (up to three) remote LSTAT calls. We really can skip this here and let\n            // the upstream server decide.\n            if (!(file instanceof SftpPath)) {\n                LinkOption[] options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_READDIR, \"\", file);\n                Boolean status = IoUtils.checkFileExists(file, options);\n                if (status == null) {\n                    throw new AccessDeniedException(file.toString(), file.toString(), \"Cannot determine existence of read-dir\");\n                }\n\n                if (!status) {\n                    throw new NoSuchFileException(file.toString(), file.toString(), \"Non-existent directory\");\n                } else if (!Files.isDirectory(file, options)) {\n                    throw new NotDirectoryException(file.toString());\n                } else if (!Files.isReadable(file)) {\n                    throw new AccessDeniedException(file.toString(), file.toString(), \"Not readable\");\n                }\n            }\n\n            SftpEventListener listener = getSftpEventListenerProxy();\n            listener.readingEntries(session, handle, dh);\n\n            if (dh.isSendDot() || dh.isSendDotDot() || dh.hasNext()) {\n                // There is at least one file in the directory or we need to send the \"..\".\n                // Send only a few files at a time to not create packets of a too\n                // large size or have a timeout to occur.\n\n                reply = prepareReply(buffer);\n                reply.putByte((byte) SftpConstants.SSH_FXP_NAME);\n                reply.putInt(id);\n\n                int lenPos = reply.wpos();\n                reply.putUInt(0L);  // save room for actual length\n\n                int maxDataSize = SftpModuleProperties.MAX_READDIR_DATA_SIZE.getRequired(session);\n                int count = doReadDir(id, handle, dh, reply, maxDataSize, false);\n                BufferUtils.updateLengthPlaceholder(reply, lenPos, count);\n                if ((!dh.isSendDot()) && (!dh.isSendDotDot()) && (!dh.hasNext())) {\n                    dh.markDone();\n                }\n\n                int sftpVersion = getVersion();\n                Boolean indicator = SftpHelper.indicateEndOfNamesList(reply, sftpVersion, session, dh.isDone());\n                if (debugEnabled) {\n                    log.debug(\"doReadDir({})({})[{}] - sending {} entries - eol={} (SFTP version {})\", session, handle, h,\n                            count, indicator, sftpVersion);\n                }\n            } else {\n                // empty directory\n                dh.markDone();\n                sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_EOF, \"Empty directory\");\n                return;\n            }\n\n            Objects.requireNonNull(reply, \"No reply buffer created\");\n        } catch (IOException | RuntimeException | Error e) {\n            sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_READDIR, handle);\n            return;\n        }\n\n        send(reply);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          655,
          745
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doWrite",
        "signature": "void doWrite(int,String,long,int,byte,int,int)",
        "lines_hint_csv": [
          814,
          851
        ],
        "code": "    protected void doWrite(\n            int id, String handle, long offset, int length, byte[] data, int doff, int remaining)\n            throws IOException {\n        Handle h = handles.get(handle);\n        ServerSession session = getServerSession();\n        int maxAllowed = SftpModuleProperties.MAX_WRITEDATA_PACKET_LENGTH.getRequired(session);\n        if (log.isTraceEnabled()) {\n            log.trace(\"doWrite({})[id={}] SSH_FXP_WRITE (handle={}[{}], offset={}, length={}, maxAllowed={})\",\n                    session, id, handle, h, offset, length, maxAllowed);\n        }\n\n        FileHandle fh = validateHandle(handle, h, FileHandle.class);\n        if (length < 0) {\n            throw new IllegalStateException(\"Bad length (\" + length + \") for writing to \" + fh);\n        }\n\n        if (remaining < length) {\n            throw new IllegalStateException(\"Not enough buffer data for writing to \" + fh\n                                            + \": required=\" + length + \", available=\" + remaining);\n        }\n\n        if (length > maxAllowed) {\n            throw new IOException(\"Reuested write size (\" + length + \") exceeds max. allowed (\" + maxAllowed + \")\");\n        }\n\n        SftpEventListener listener = getSftpEventListenerProxy();\n        listener.writing(session, handle, fh, offset, data, doff, length);\n        try {\n            if (fh.isOpenAppend()) {\n                fh.append(data, doff, length);\n            } else {\n                fh.write(data, doff, length, offset);\n            }\n        } catch (IOException | RuntimeException | Error e) {\n            listener.written(session, handle, fh, offset, data, doff, length, e);\n            throw e;\n        }\n        listener.written(session, handle, fh, offset, data, doff, length, null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          814,
          852
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doFStat",
        "signature": "Map doFStat(int,String,int)",
        "lines_hint_csv": [
          798,
          810
        ],
        "code": "    protected Map<String, Object> doFStat(int id, String handle, int flags) throws IOException {\n        Handle h = handles.get(handle);\n        if (log.isDebugEnabled()) {\n            log.debug(\"doFStat({})[id={}] SSH_FXP_FSTAT (handle={}[{}], flags=0x{})\",\n                    getServerSession(), id, handle, h, Integer.toHexString(flags));\n        }\n\n        Handle fileHandle = validateHandle(handle, h, Handle.class);\n        SftpFileSystemAccessor accessor = getFileSystemAccessor();\n        Path file = fileHandle.getFile();\n        LinkOption[] options = accessor.resolveFileAccessLinkOptions(\n                this, file, SftpConstants.SSH_FXP_FSTAT, \"\", true);\n        return resolveFileAttributes(file, flags, options);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          798,
          811
        ]
      },
      {
        "file_path": "sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java",
        "class_name": "SftpSubsystem",
        "method_name": "doOpenDir",
        "signature": "String doOpenDir(int,String,Path,LinkOption)",
        "lines_hint_csv": [
          748,
          779
        ],
        "code": "    protected String doOpenDir(int id, String path, Path dir, LinkOption... options) throws IOException {\n        SftpPathImpl.withAttributeCache(dir, p -> {\n            Boolean status = IoUtils.checkFileExists(p, options);\n            if (status == null) {\n                throw signalOpenFailure(id, path, p, true,\n                        new AccessDeniedException(p.toString(), p.toString(), \"Cannot determine open-dir existence\"));\n            }\n\n            if (!status) {\n                throw signalOpenFailure(id, path, p, true,\n                        new NoSuchFileException(path, path, \"Referenced target directory N/A\"));\n            } else if (!Files.isDirectory(p, options)) {\n                throw signalOpenFailure(id, path, p, true, new NotDirectoryException(path));\n            } else if (!Files.isReadable(p)) {\n                throw signalOpenFailure(id, path, p, true,\n                        new AccessDeniedException(p.toString(), p.toString(), \"Not readable\"));\n            }\n            return null;\n        });\n        // Directory exists and is readable\n        String handle;\n        try {\n            synchronized (handles) {\n                handle = generateFileHandle(dir);\n                DirectoryHandle dirHandle = new DirectoryHandle(this, dir, handle);\n                handles.put(handle, dirHandle);\n            }\n        } catch (IOException e) {\n            throw signalOpenFailure(id, path, dir, true, e);\n        }\n\n        return handle;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          748,
          780
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpTest.java",
        "class_name": "SftpTest",
        "method_name": "testSftpFileSystemAccessor",
        "signature": "void testSftpFileSystemAccessor(SftpSubsystemProxy,FileHandle,Path,String,Set,FileAttribute,SftpSubsystemProxy,DirectoryHandle,Path,String)",
        "lines_hint_csv": [
          689,
          771
        ],
        "code": "    public void testSftpFileSystemAccessor() throws Exception {\n        List<? extends SubsystemFactory> factories = sshd.getSubsystemFactories();\n        assertEquals(\"Mismatched subsystem factories count\", 1, GenericUtils.size(factories));\n\n        SubsystemFactory f = factories.get(0);\n        assertObjectInstanceOf(\"Not an SFTP subsystem factory\", SftpSubsystemFactory.class, f);\n\n        SftpSubsystemFactory factory = (SftpSubsystemFactory) f;\n        SftpFileSystemAccessor accessor = factory.getFileSystemAccessor();\n        try {\n            AtomicReference<Path> fileHolder = new AtomicReference<>();\n            AtomicReference<Path> dirHolder = new AtomicReference<>();\n            factory.setFileSystemAccessor(new SftpFileSystemAccessor() {\n                @Override\n                public SeekableByteChannel openFile(\n                        SftpSubsystemProxy subsystem, FileHandle fileHandle, Path file,\n                        String handle, Set<? extends OpenOption> options, FileAttribute<?>... attrs)\n                        throws IOException {\n                    fileHolder.set(file);\n                    return SftpFileSystemAccessor.super.openFile(\n                            subsystem, fileHandle, file, handle, options, attrs);\n                }\n\n                @Override\n                public DirectoryStream<Path> openDirectory(\n                        SftpSubsystemProxy subsystem, DirectoryHandle dirHandle, Path dir, String handle)\n                        throws IOException {\n                    dirHolder.set(dir);\n                    return SftpFileSystemAccessor.super.openDirectory(subsystem, dirHandle, dir, handle);\n                }\n\n                @Override\n                public String toString() {\n                    return SftpFileSystemAccessor.class.getSimpleName() + \"[\" + getCurrentTestName() + \"]\";\n                }\n            });\n\n            Path targetPath = detectTargetFolder();\n            Path parentPath = targetPath.getParent();\n            Path localFile = CommonTestSupportUtils.resolve(\n                    targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName(), getCurrentTestName());\n            Files.createDirectories(localFile.getParent());\n            byte[] expected = (getClass().getName() + \"#\" + getCurrentTestName() + \"[\" + localFile + \"]\")\n                    .getBytes(StandardCharsets.UTF_8);\n            Files.write(localFile, expected, StandardOpenOption.CREATE);\n            try (SftpClient sftp = createSingleSessionClient()) {\n                byte[] actual = new byte[expected.length];\n                try (InputStream stream = sftp.read(\n                        CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, localFile), OpenMode.Read)) {\n                    IoUtils.readFully(stream, actual);\n                }\n\n                Path remoteFile = fileHolder.getAndSet(null);\n                assertNotNull(\"No remote file holder value\", remoteFile);\n                assertEquals(\"Mismatched opened local files\", localFile.toFile(), remoteFile.toFile());\n                assertArrayEquals(\"Mismatched retrieved file contents\", expected, actual);\n\n                Path localParent = localFile.getParent();\n                String localName = Objects.toString(localFile.getFileName(), null);\n                try (CloseableHandle handle = sftp.openDir(\n                        CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, localParent))) {\n                    List<DirEntry> entries = sftp.readDir(handle);\n                    Path remoteParent = dirHolder.getAndSet(null);\n                    assertNotNull(\"No remote folder holder value\", remoteParent);\n                    assertEquals(\"Mismatched opened folder\", localParent.toFile(), remoteParent.toFile());\n                    assertFalse(\"No dir entries\", GenericUtils.isEmpty(entries));\n\n                    for (DirEntry de : entries) {\n                        Attributes attrs = de.getAttributes();\n                        if (!attrs.isRegularFile()) {\n                            continue;\n                        }\n\n                        if (localName.equals(de.getFilename())) {\n                            return;\n                        }\n                    }\n\n                    fail(\"Cannot find listing of \" + localName);\n                }\n            }\n        } finally {\n            factory.setFileSystemAccessor(accessor); // restore original\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          689,
          773
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpTest.java",
        "class_name": "SftpTest",
        "method_name": "testCannotEscapeRoot",
        "signature": "void testCannotEscapeRoot(boolean)",
        "lines_hint_csv": [
          363,
          391
        ],
        "code": "    private void testCannotEscapeRoot(boolean useAbsolutePath) throws Exception {\n        Path targetPath = detectTargetFolder();\n        Path lclSftp = CommonTestSupportUtils.resolve(\n                targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName(), getCurrentTestName());\n        lclSftp = assertHierarchyTargetFolderExists(lclSftp);\n        sshd.setFileSystemFactory(new VirtualFileSystemFactory(lclSftp));\n\n        String escapePath;\n        if (useAbsolutePath) {\n            escapePath = targetPath.toString();\n            if (OsUtils.isWin32()) {\n                escapePath = \"/\" + escapePath.replace(File.separatorChar, '/');\n            }\n        } else {\n            Path parent = lclSftp.getParent();\n            Path forbidden = Files.createDirectories(parent.resolve(\"forbidden\"));\n            escapePath = \"../\" + forbidden.getFileName();\n        }\n\n        try (SftpClient sftp = createSingleSessionClient()) {\n            SftpClient.Attributes attrs = sftp.stat(escapePath);\n            fail(\"Unexpected escape success for path=\" + escapePath + \": \" + attrs);\n        } catch (SftpException e) {\n            int expected = OsUtils.isWin32() || (!useAbsolutePath)\n                    ? SftpConstants.SSH_FX_INVALID_FILENAME\n                    : SftpConstants.SSH_FX_NO_SUCH_FILE;\n            assertEquals(\"Mismatched status for \" + escapePath,\n                    SftpConstants.getStatusName(expected),\n                    SftpConstants.getStatusName(e.getStatus()));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          363,
          393
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpVersionsTest.java",
        "class_name": "SftpVersionsTest",
        "method_name": "testSftpACLEncodeDecode",
        "signature": "void testSftpACLEncodeDecode(ChannelSession,Path,int,LinkOption,Path,List,LinkOption,ServerSession,Path,Map,ServerSession,Path,Map,Throwable)",
        "lines_hint_csv": [
          276,
          397
        ],
        "code": "    public void testSftpACLEncodeDecode() throws Exception {\n        AclEntryType[] types = AclEntryType.values();\n        final List<AclEntry> aclExpected = new ArrayList<>(types.length);\n        for (AclEntryType t : types) {\n            aclExpected.add(AclEntry.newBuilder()\n                    .setType(t)\n                    .setFlags(EnumSet.allOf(AclEntryFlag.class))\n                    .setPermissions(EnumSet.allOf(AclEntryPermission.class))\n                    .setPrincipal(new DefaultGroupPrincipal(getCurrentTestName() + \"@\" + getClass().getPackage().getName()))\n                    .build());\n        }\n\n        AtomicInteger numInvocations = new AtomicInteger(0);\n        SftpSubsystemFactory factory = new SftpSubsystemFactory() {\n            @Override\n            public Command createSubsystem(ChannelSession channel) throws IOException {\n                SftpSubsystem subsystem = new SftpSubsystem(channel, this) {\n                    @Override\n                    protected NavigableMap<String, Object> resolveFileAttributes(Path file, int flags, LinkOption... options)\n                            throws IOException {\n                        NavigableMap<String, Object> attrs = super.resolveFileAttributes(file, flags, options);\n                        if (MapEntryUtils.isEmpty(attrs)) {\n                            attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n                        }\n\n                        @SuppressWarnings(\"unchecked\")\n                        List<AclEntry> aclActual = (List<AclEntry>) attrs.put(IoUtils.ACL_VIEW_ATTR, aclExpected);\n                        if (aclActual != null) {\n                            log.info(\"resolveFileAttributes(\" + file + \") replaced ACL: \" + aclActual);\n                        }\n                        return attrs;\n                    }\n\n                    @Override\n                    protected void setFileAccessControl(Path file, List<AclEntry> aclActual, LinkOption... options)\n                            throws IOException {\n                        if (aclActual != null) {\n                            assertListEquals(\"Mismatched ACL set for file=\" + file, aclExpected, aclActual);\n                            numInvocations.incrementAndGet();\n                        }\n                    }\n                };\n                Collection<? extends SftpEventListener> listeners = getRegisteredListeners();\n                if (GenericUtils.size(listeners) > 0) {\n                    for (SftpEventListener l : listeners) {\n                        subsystem.addSftpEventListener(l);\n                    }\n                }\n\n                return subsystem;\n            }\n        };\n\n        factory.addSftpEventListener(new AbstractSftpEventListenerAdapter() {\n            @Override\n            public void modifyingAttributes(ServerSession session, Path path, Map<String, ?> attrs) {\n                @SuppressWarnings(\"unchecked\")\n                List<AclEntry> aclActual\n                        = MapEntryUtils.isEmpty(attrs) ? null : (List<AclEntry>) attrs.get(IoUtils.ACL_VIEW_ATTR);\n                if (getTestedVersion() > SftpConstants.SFTP_V3) {\n                    assertListEquals(\"Mismatched modifying ACL for file=\" + path, aclExpected, aclActual);\n                } else {\n                    assertNull(\"Unexpected modifying ACL for file=\" + path, aclActual);\n                }\n            }\n\n            @Override\n            public void modifiedAttributes(\n                    ServerSession session, Path path, Map<String, ?> attrs, Throwable thrown) {\n                @SuppressWarnings(\"unchecked\")\n                List<AclEntry> aclActual\n                        = MapEntryUtils.isEmpty(attrs) ? null : (List<AclEntry>) attrs.get(IoUtils.ACL_VIEW_ATTR);\n                if (getTestedVersion() > SftpConstants.SFTP_V3) {\n                    assertListEquals(\"Mismatched modified ACL for file=\" + path, aclExpected, aclActual);\n                } else {\n                    assertNull(\"Unexpected modified ACL for file=\" + path, aclActual);\n                }\n            }\n        });\n\n        Path targetPath = detectTargetFolder();\n        Path lclSftp = CommonTestSupportUtils.resolve(\n                targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName());\n        Files.createDirectories(lclSftp.resolve(\"sub-folder\"));\n        Path lclFile = assertHierarchyTargetFolderExists(lclSftp)\n                .resolve(getCurrentTestName() + \"-\" + getTestedVersion() + \".txt\");\n        Files.write(lclFile, getClass().getName().getBytes(StandardCharsets.UTF_8));\n\n        Path parentPath = targetPath.getParent();\n        String remotePath = CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, lclSftp);\n        int numInvoked = 0;\n\n        List<? extends SubsystemFactory> factories = sshd.getSubsystemFactories();\n        sshd.setSubsystemFactories(Collections.singletonList(factory));\n        try (ClientSession session = createAuthenticatedClientSession();\n             SftpClient sftp = createSftpClient(session, getTestedVersion())) {\n            for (DirEntry entry : sftp.readDir(remotePath)) {\n                String fileName = entry.getFilename();\n                if (\".\".equals(fileName) || \"..\".equals(fileName)) {\n                    continue;\n                }\n\n                Attributes attrs = validateSftpFileTypeAndPermissions(fileName, getTestedVersion(), entry.getAttributes());\n                List<AclEntry> aclActual = attrs.getAcl();\n                if (getTestedVersion() == SftpConstants.SFTP_V3) {\n                    assertNull(\"Unexpected ACL for entry=\" + fileName, aclActual);\n                } else {\n                    assertListEquals(\"Mismatched ACL for entry=\" + fileName, aclExpected, aclActual);\n                }\n\n                attrs.getFlags().clear();\n                attrs.setAcl(aclExpected);\n                sftp.setStat(remotePath + \"/\" + fileName, attrs);\n                if (getTestedVersion() > SftpConstants.SFTP_V3) {\n                    numInvoked++;\n                }\n            }\n        } finally {\n            sshd.setSubsystemFactories(factories);\n        }\n\n        assertEquals(\"Mismatched invocations count\", numInvoked, numInvocations.get());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          276,
          398
        ]
      },
      {
        "file_path": "sshd-sftp/src/test/java/org/apache/sshd/sftp/client/SftpVersionsTest.java",
        "class_name": "SftpVersionsTest",
        "method_name": "testSftpExtensionsEncodeDecode",
        "signature": "void testSftpExtensionsEncodeDecode(ChannelSession,Path,int,LinkOption,Path,Map,LinkOption,ServerSession,Path,Map,ServerSession,Path,Map,Throwable)",
        "lines_hint_csv": [
          401,
          511
        ],
        "code": "    public void testSftpExtensionsEncodeDecode() throws Exception {\n        Class<?> anchor = getClass();\n        Map<String, String> expExtensions = NavigableMapBuilder.<String, String> builder(String.CASE_INSENSITIVE_ORDER)\n                .put(\"class\", anchor.getSimpleName())\n                .put(\"package\", anchor.getPackage().getName())\n                .put(\"method\", getCurrentTestName())\n                .build();\n\n        final AtomicInteger numInvocations = new AtomicInteger(0);\n        SftpSubsystemFactory factory = new SftpSubsystemFactory() {\n            @Override\n            public Command createSubsystem(ChannelSession channel) throws IOException {\n                SftpSubsystem subsystem = new SftpSubsystem(channel, this) {\n                    @Override\n                    protected NavigableMap<String, Object> resolveFileAttributes(Path file, int flags, LinkOption... options)\n                            throws IOException {\n                        NavigableMap<String, Object> attrs = super.resolveFileAttributes(file, flags, options);\n                        if (MapEntryUtils.isEmpty(attrs)) {\n                            attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n                        }\n\n                        @SuppressWarnings(\"unchecked\")\n                        Map<String, String> actExtensions\n                                = (Map<String, String>) attrs.put(IoUtils.EXTENDED_VIEW_ATTR, expExtensions);\n                        if (actExtensions != null) {\n                            log.info(\"resolveFileAttributes(\" + file + \") replaced extensions: \" + actExtensions);\n                        }\n                        return attrs;\n                    }\n\n                    @Override\n                    protected void setFileExtensions(Path file, Map<String, byte[]> extensions, LinkOption... options)\n                            throws IOException {\n                        assertExtensionsMapEquals(\"setFileExtensions(\" + file + \")\", expExtensions, extensions);\n                        numInvocations.incrementAndGet();\n\n                        int currentVersion = getTestedVersion();\n                        try {\n                            super.setFileExtensions(file, extensions, options);\n                            assertFalse(\"Expected exception not generated for version=\" + currentVersion,\n                                    currentVersion >= SftpConstants.SFTP_V6);\n                        } catch (UnsupportedOperationException e) {\n                            assertTrue(\"Unexpected exception for version=\" + currentVersion,\n                                    currentVersion >= SftpConstants.SFTP_V6);\n                        }\n                    }\n                };\n                Collection<? extends SftpEventListener> listeners = getRegisteredListeners();\n                if (GenericUtils.size(listeners) > 0) {\n                    for (SftpEventListener l : listeners) {\n                        subsystem.addSftpEventListener(l);\n                    }\n                }\n\n                return subsystem;\n            }\n        };\n\n        factory.addSftpEventListener(new AbstractSftpEventListenerAdapter() {\n            @Override\n            public void modifyingAttributes(ServerSession session, Path path, Map<String, ?> attrs) {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, byte[]> actExtensions\n                        = MapEntryUtils.isEmpty(attrs) ? null : (Map<String, byte[]>) attrs.get(IoUtils.EXTENDED_VIEW_ATTR);\n                assertExtensionsMapEquals(\"modifying(\" + path + \")\", expExtensions, actExtensions);\n            }\n\n            @Override\n            public void modifiedAttributes(ServerSession session, Path path, Map<String, ?> attrs, Throwable thrown) {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, byte[]> actExtensions\n                        = MapEntryUtils.isEmpty(attrs) ? null : (Map<String, byte[]>) attrs.get(IoUtils.EXTENDED_VIEW_ATTR);\n                assertExtensionsMapEquals(\"modified(\" + path + \")\", expExtensions, actExtensions);\n            }\n        });\n\n        Path targetPath = detectTargetFolder();\n        Path lclSftp\n                = CommonTestSupportUtils.resolve(targetPath, SftpConstants.SFTP_SUBSYSTEM_NAME, getClass().getSimpleName());\n        Files.createDirectories(lclSftp.resolve(\"sub-folder\"));\n        Path lclFile\n                = assertHierarchyTargetFolderExists(lclSftp).resolve(getCurrentTestName() + \"-\" + getTestedVersion() + \".txt\");\n        Files.write(lclFile, getClass().getName().getBytes(StandardCharsets.UTF_8));\n\n        Path parentPath = targetPath.getParent();\n        String remotePath = CommonTestSupportUtils.resolveRelativeRemotePath(parentPath, lclSftp);\n        int numInvoked = 0;\n\n        List<? extends SubsystemFactory> factories = sshd.getSubsystemFactories();\n        sshd.setSubsystemFactories(Collections.singletonList(factory));\n        try (ClientSession session = createAuthenticatedClientSession();\n             SftpClient sftp = createSftpClient(session, getTestedVersion())) {\n            for (DirEntry entry : sftp.readDir(remotePath)) {\n                String fileName = entry.getFilename();\n                if (\".\".equals(fileName) || \"..\".equals(fileName)) {\n                    continue;\n                }\n\n                Attributes attrs = validateSftpFileTypeAndPermissions(fileName, getTestedVersion(), entry.getAttributes());\n                Map<String, byte[]> actExtensions = attrs.getExtensions();\n                assertExtensionsMapEquals(\"dirEntry=\" + fileName, expExtensions, actExtensions);\n                attrs.getFlags().clear();\n                attrs.setStringExtensions(expExtensions);\n                sftp.setStat(remotePath + \"/\" + fileName, attrs);\n                numInvoked++;\n            }\n        } finally {\n            sshd.setSubsystemFactories(factories);\n        }\n\n        assertEquals(\"Mismatched invocations count\", numInvoked, numInvocations.get());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          401,
          512
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-34478",
    "project_slug": "apache__shiro_CVE-2023-34478_1.11.0",
    "buggy_commit_id": "adb56c885210eeca710b2df17f6b3aeda85e4f35",
    "github_url": "https://github.com/apache/shiro",
    "nvd_metadata": {
      "description": "Apache Shiro, before 1.12.0 or 2.0.0-alpha-3, may be susceptible to a path traversal attack that results in an authentication bypass when used together with APIs or other web frameworks that route requests based on non-normalized requests.\n\nMitigation:Update to Apache Shiro 1.12.0+ or 2.0.0-alpha-3+",
      "published_date": "2023-07-24T19:15:10.630",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "setBlockSemicolon",
        "signature": "void setBlockSemicolon(boolean)",
        "lines_hint_csv": [
          115,
          116
        ],
        "code": "    public void setBlockSemicolon(boolean blockSemicolon) {\n        this.blockSemicolon = blockSemicolon;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          115,
          117
        ]
      },
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "containsSemicolon",
        "signature": "boolean containsSemicolon(String)",
        "lines_hint_csv": [
          79,
          83
        ],
        "code": "    private boolean containsSemicolon(String uri) {\n        if (isBlockSemicolon()) {\n            return SEMICOLON.stream().anyMatch(uri::contains);\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          79,
          84
        ]
      },
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "onAccessDenied",
        "signature": "boolean onAccessDenied(ServletRequest,ServletResponse)",
        "lines_hint_csv": [
          74,
          76
        ],
        "code": "    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {\n        WebUtils.toHttp(response).sendError(400, \"Invalid request\");\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          74,
          77
        ]
      },
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "isValid",
        "signature": "boolean isValid(String)",
        "lines_hint_csv": [
          66,
          70
        ],
        "code": "    private boolean isValid(String uri) {\n        return !StringUtils.hasText(uri)\n               || ( !containsSemicolon(uri)\n                 && !containsBackslash(uri)\n                 && !containsNonAsciiCharacters(uri));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          66,
          71
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-37460",
    "project_slug": "codehaus-plexus__plexus-archiver_CVE-2023-37460_4.7.1",
    "buggy_commit_id": "e7cbadba1b5c78192677da95b355dd790f3a4535",
    "github_url": "https://github.com/codehaus-plexus/plexus-archiver",
    "nvd_metadata": {
      "description": "Plexis Archiver is a collection of Plexus components to create archives or extract archives to a directory with a unified `Archiver`/`UnArchiver` API. Prior to version 4.8.0, using AbstractUnArchiver for extracting an archive might lead to an arbitrary file creation and possibly remote code execution. When extracting an archive with an entry that already exists in the destination directory as a symbolic link whose target does not exist - the `resolveFile()` function will return the symlink's source instead of its target, which will pass the verification that ensures the file will not be extracted outside of the destination directory. Later `Files.newOutputStream()`, that follows symlinks by default,  will actually write the entry's content to the symlink's target. Whoever uses plexus archiver to extract an untrusted archive is vulnerable to an arbitrary file creation and possibly remote code execution. Version 4.8.0 contains a patch for this issue.",
      "published_date": "2023-07-25T20:15:13.703",
      "cvss_v3_score": 8.1,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
        "class_name": "AbstractUnArchiver",
        "method_name": "extractFile",
        "signature": "void extractFile(File,File,InputStream,String,Date,boolean,Integer,String,FileMapper)",
        "lines_hint_csv": [
          274,
          331
        ],
        "code": "    protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                                String entryName, final Date entryDate, final boolean isDirectory,\n                                final Integer mode, String symlinkDestination, final FileMapper[] fileMappers )\n        throws IOException, ArchiverException\n    {\n        if ( fileMappers != null )\n        {\n            for ( final FileMapper fileMapper : fileMappers )\n            {\n                entryName = fileMapper.getMappedFileName( entryName );\n            }\n        }\n\n        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...\n        final File targetFileName = FileUtils.resolveFile( dir, entryName );\n\n        // Make sure that the resolved path of the extracted file doesn't escape the destination directory\n        // getCanonicalFile().toPath() is used instead of getCanonicalPath() (returns String),\n        // because \"/opt/directory\".startsWith(\"/opt/dir\") would return false negative.\n        Path canonicalDirPath = dir.getCanonicalFile().toPath();\n        Path canonicalDestPath = targetFileName.getCanonicalFile().toPath();\n\n        if ( !canonicalDestPath.startsWith( canonicalDirPath ) )\n        {\n            throw new ArchiverException( \"Entry is outside of the target directory (\" + entryName + \")\" );\n        }\n\n        try\n        {\n            if ( !shouldExtractEntry( dir, targetFileName, entryName, entryDate ) )\n            {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            final File dirF = targetFileName.getParentFile();\n            if ( dirF != null )\n            {\n                dirF.mkdirs();\n            }\n\n            if ( !StringUtils.isEmpty( symlinkDestination ) )\n            {\n                SymlinkUtils.createSymbolicLink( targetFileName, new File( symlinkDestination ) );\n            }\n            else if ( isDirectory )\n            {\n                targetFileName.mkdirs();\n            }\n            else\n            {\n                try ( OutputStream out = Files.newOutputStream( targetFileName.toPath() ) )\n                {\n                    IOUtil.copy( compressedInputStream, out );\n                }\n            }\n\n            targetFileName.setLastModified( entryDate.getTime() );\n\n            if ( !isIgnorePermissions() && mode != null && !isDirectory )\n            {\n                ArchiveEntryUtils.chmod( targetFileName, mode );\n            }\n        }\n        catch ( final FileNotFoundException ex )\n        {\n            getLogger().warn( \"Unable to expand to file \" + targetFileName.getPath() );\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          328,
          396
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/archiver/SymlinkTest.java",
        "class_name": "SymlinkTest",
        "method_name": "testSymlinkTar",
        "signature": "void testSymlinkTar()",
        "lines_hint_csv": [
          50,
          64
        ],
        "code": "    public void testSymlinkTar()\n        throws Exception\n    {\n        TarArchiver archiver = (TarArchiver) lookup( Archiver.class, \"tar\" );\n        archiver.setLongfile( TarLongFileMode.posix );\n\n        File dummyContent = getTestFile( \"src/test/resources/symlinks/src\" );\n        archiver.addDirectory( dummyContent );\n        final File archiveFile = new File( \"target/output/symlinks.tar\" );\n        archiver.setDestFile( archiveFile );\n        archiver.createArchive();\n        File output = getTestFile( \"target/output/untaredSymlinks\" );\n        output.mkdirs();\n        TarUnArchiver unarchiver = (TarUnArchiver) lookup( UnArchiver.class, \"tar\" );\n        unarchiver.setSourceFile( archiveFile );\n        unarchiver.setDestFile( output );\n        unarchiver.extract();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          56,
          73
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/archiver/SymlinkTest.java",
        "class_name": "SymlinkTest",
        "method_name": "testSymlinkDirArchiver",
        "signature": "void testSymlinkDirArchiver()",
        "lines_hint_csv": [
          88,
          104
        ],
        "code": "    public void testSymlinkDirArchiver()\n        throws Exception\n    {\n        DirectoryArchiver archiver = (DirectoryArchiver) lookup( Archiver.class, \"dir\" );\n\n        File dummyContent = getTestFile( \"src/test/resources/symlinks/src\" );\n        archiver.addDirectory( dummyContent );\n        final File archiveFile = new File( \"target/output/dirarchiver-symlink\" );\n        archiveFile.mkdirs();\n        archiver.setDestFile( archiveFile );\n        archiver.addSymlink( \"target/output/dirarchiver-symlink/aNewDir/symlink\", \".\" );\n\n        archiver.createArchive();\n\n        File symbolicLink = new File( \"target/output/dirarchiver-symlink/symR\" );\n        assertTrue( Files.isSymbolicLink( symbolicLink.toPath() ) );\n\n        symbolicLink = new File( \"target/output/dirarchiver-symlink/aDirWithALink/backOutsideToFileX\" );\n        assertTrue( Files.isSymbolicLink( symbolicLink.toPath() ) );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          98,
          117
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/archiver/SymlinkTest.java",
        "class_name": "SymlinkTest",
        "method_name": "testSymlinkZip",
        "signature": "void testSymlinkZip()",
        "lines_hint_csv": [
          68,
          83
        ],
        "code": "    public void testSymlinkZip()\n        throws Exception\n    {\n        ZipArchiver archiver = (ZipArchiver) lookup( Archiver.class, \"zip\" );\n\n        File dummyContent = getTestFile( \"src/test/resources/symlinks/src\" );\n        archiver.addDirectory( dummyContent );\n        final File archiveFile = new File( \"target/output/symlinks.zip\" );\n        archiveFile.delete();\n        archiver.setDestFile( archiveFile );\n        archiver.createArchive();\n\n        File output = getTestFile( \"target/output/unzippedSymlinks\" );\n        output.mkdirs();\n        ZipUnArchiver unarchiver = (ZipUnArchiver) lookup( UnArchiver.class, \"zip\" );\n        unarchiver.setSourceFile( archiveFile );\n        unarchiver.setDestFile( output );\n        unarchiver.extract();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          76,
          94
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/archiver/zip/ZipArchiverTest.java",
        "class_name": "ZipArchiverTest",
        "method_name": "toLocalTimeZone",
        "signature": "long toLocalTimeZone(long)",
        "lines_hint_csv": [
          825,
          837
        ],
        "code": "    private long toLocalTimeZone( long timestamp )\n    {\n        String dateFormat = \"dd-MM-yyyy hh:mm:ss a\";\n        DateFormat formatterWithTimeZone = new SimpleDateFormat( dateFormat );\n        formatterWithTimeZone.setTimeZone( TimeZone.getTimeZone( \"GMT\" ) );\n        String sDate = formatterWithTimeZone.format( new Date( timestamp ) );\n\n        DateFormat formatter = new SimpleDateFormat( dateFormat );\n        try\n        {\n            Date dateWithTimeZone = formatter.parse( sDate );\n            return dateWithTimeZone.getTime();\n        }\n        catch ( ParseException e )\n        {\n            fail( \"Date '\" + sDate + \"' can not be parsed!\" );\n            return 0L;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          936,
          954
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-4244",
    "project_slug": "codehaus-plexus__plexus-utils_CVE-2022-4244_3.0.23",
    "buggy_commit_id": "6176f91bb843eecddac857591ed20bda38e01470",
    "github_url": "https://github.com/codehaus-plexus/plexus-utils",
    "nvd_metadata": {
      "description": "A flaw was found in codeplex-codehaus. A directory traversal attack (also known as path traversal) aims to access files and directories stored outside the intended folder. By manipulating files with \"dot-dot-slash (../)\" sequences and their variations or by using absolute file paths, it may be possible to access arbitrary files and directories stored on the file system, including application source code, configuration, and other critical system files.",
      "published_date": "2023-09-25T20:15:10.220",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/Expand.java",
        "class_name": "Expand",
        "method_name": "extractFile",
        "signature": "void extractFile(File,File,InputStream,String,Date,boolean)",
        "lines_hint_csv": [
          134,
          179
        ],
        "code": "    protected void extractFile( File srcF,\n                                File dir,\n                                InputStream compressedInputStream,\n                                String entryName,\n                                Date entryDate,\n                                boolean isDirectory )\n        throws Exception\n    {\n        File f = FileUtils.resolveFile( dir, entryName );\n        try\n        {\n            if ( !overwrite && f.exists()\n                &&\n                f.lastModified() >= entryDate.getTime() )\n            {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            File dirF = f.getParentFile();\n            dirF.mkdirs();\n\n            if ( isDirectory )\n            {\n                f.mkdirs();\n            }\n            else\n            {\n                byte[] buffer = new byte[1024];\n                int length = 0;\n                FileOutputStream fos = null;\n                try\n                {\n                    fos = new FileOutputStream( f );\n\n                    while ( ( length =\n                        compressedInputStream.read( buffer ) ) >= 0 )\n                    {\n                        fos.write( buffer, 0, length );\n                    }\n\n                    fos.close();\n                    fos = null;\n                }\n                finally\n                {\n                    if ( fos != null )\n                    {\n                        try\n                        {\n                            fos.close();\n                        }\n                        catch ( IOException e )\n                        {\n                        }\n                    }\n                }\n            }\n\n            f.setLastModified( entryDate.getTime() );\n        }\n        catch ( FileNotFoundException ex )\n        {\n            throw new Exception( \"Can't extract file \" + srcF.getPath(), ex );\n        }\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          145,
          211
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-45278",
    "project_slug": "yamcs__yamcs_CVE-2023-45278_5.8.6",
    "buggy_commit_id": "9443a67d2aeda20fb73f68c5d571b515d68c05e4",
    "github_url": "https://github.com/yamcs/yamcs",
    "nvd_metadata": {
      "description": "Directory Traversal vulnerability in the storage functionality of the API in Yamcs 5.8.6 allows attackers to delete arbitrary files via crafted HTTP DELETE request.",
      "published_date": "2023-10-19T17:15:10.200",
      "cvss_v3_score": 9.1,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "putObject",
        "signature": "void putObject(String,String,Map<String, String>,byte[])",
        "lines_hint_csv": [
          141,
          187
        ],
        "code": "    public void putObject(String objectName, String contentType, Map<String, String> metadata, byte[] objectData)\n            throws IOException {\n        // TODO: do something with metadata\n\n        // Prevent directory traversal\n        Path path = root.resolve(objectName);\n        if (!path.toFile().getCanonicalPath().startsWith(root.toFile().getCanonicalPath())) {\n            throw new IOException(\"Directory traversal attempted: \" + path);\n        }\n\n        if (objectName.endsWith(\"/\")) {\n            if (!Files.exists(path)) {\n                Files.createDirectories(path);\n            } else if (!Files.isDirectory(path)) {\n                throw new IOException(\"Object path is already in use\");\n            }\n        } else {\n            // Current implementation ignores specified contentType, instead deriving\n            // MIME type from the filename extension.\n            boolean fileExists = Files.isRegularFile(path);\n\n            // Verify limits\n            AtomicLong size = new AtomicLong(fileExists ? -Files.size(path) : 0);\n            AtomicInteger count = new AtomicInteger(fileExists ? -1 : 0);\n            Set<FileVisitOption> opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);\n            Files.walkFileTree(root, opts, Integer.MAX_VALUE, new SimpleFileVisitor<Path>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                    size.addAndGet(attrs.size());\n                    count.incrementAndGet();\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n\n            long newSize = size.get() + objectData.length;\n            if (newSize > maxSize) {\n                throw new IOException(\"Maximum bucket size \" + maxSize + \" exceeded\");\n            }\n\n            int newCount = count.get() + 1;\n            if (newCount > maxObjects) {\n                throw new IOException(\n                        \"Maximum number of objects in the bucket \" + newCount + \" exceeded\");\n            }\n\n            if (!Files.exists(path.getParent())) { // Check to avoid error when the parent is a symlink\n                Files.createDirectories(path.getParent());\n            }\n            Files.write(path, objectData);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          141,
          191
        ]
      },
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "getObject",
        "signature": "byte getObject(String)",
        "lines_hint_csv": [
          190,
          197
        ],
        "code": "    public byte[] getObject(String objectName) throws IOException {\n        Path path = root.resolve(objectName);\n        if (Files.exists(path)) {\n            return Files.readAllBytes(path);\n        } else {\n            return null;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          194,
          201
        ]
      },
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "deleteObject",
        "signature": "void deleteObject(String)",
        "lines_hint_csv": [
          200,
          203
        ],
        "code": "    public void deleteObject(String objectName) throws IOException {\n        Path path = root.resolve(objectName);\n        Files.delete(path);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          204,
          207
        ]
      },
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "findObject",
        "signature": "ObjectProperties findObject(String)",
        "lines_hint_csv": [
          206,
          214
        ],
        "code": "    public ObjectProperties findObject(String objectName) throws IOException {\n        Path path = root.resolve(objectName);\n        if (Files.exists(path)) {\n            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n            return toObjectProperties(objectName, path, attrs);\n        } else {\n            return null;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          210,
          218
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-45277",
    "project_slug": "yamcs__yamcs_CVE-2023-45277_5.8.6",
    "buggy_commit_id": "9443a67d2aeda20fb73f68c5d571b515d68c05e4",
    "github_url": "https://github.com/yamcs/yamcs",
    "nvd_metadata": {
      "description": "Yamcs 5.8.6 is vulnerable to directory traversal (issue 1 of 2). The vulnerability is in the storage functionality of the API and allows one to escape the base directory of the buckets, freely navigate system directories, and read arbitrary files.",
      "published_date": "2023-10-19T17:15:10.150",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "putObject",
        "signature": "void putObject(String,String,Map<String, String>,byte[])",
        "lines_hint_csv": [
          141,
          187
        ],
        "code": "    public void putObject(String objectName, String contentType, Map<String, String> metadata, byte[] objectData)\n            throws IOException {\n        // TODO: do something with metadata\n\n        // Prevent directory traversal\n        Path path = root.resolve(objectName);\n        if (!path.toFile().getCanonicalPath().startsWith(root.toFile().getCanonicalPath())) {\n            throw new IOException(\"Directory traversal attempted: \" + path);\n        }\n\n        if (objectName.endsWith(\"/\")) {\n            if (!Files.exists(path)) {\n                Files.createDirectories(path);\n            } else if (!Files.isDirectory(path)) {\n                throw new IOException(\"Object path is already in use\");\n            }\n        } else {\n            // Current implementation ignores specified contentType, instead deriving\n            // MIME type from the filename extension.\n            boolean fileExists = Files.isRegularFile(path);\n\n            // Verify limits\n            AtomicLong size = new AtomicLong(fileExists ? -Files.size(path) : 0);\n            AtomicInteger count = new AtomicInteger(fileExists ? -1 : 0);\n            Set<FileVisitOption> opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);\n            Files.walkFileTree(root, opts, Integer.MAX_VALUE, new SimpleFileVisitor<Path>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                    size.addAndGet(attrs.size());\n                    count.incrementAndGet();\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n\n            long newSize = size.get() + objectData.length;\n            if (newSize > maxSize) {\n                throw new IOException(\"Maximum bucket size \" + maxSize + \" exceeded\");\n            }\n\n            int newCount = count.get() + 1;\n            if (newCount > maxObjects) {\n                throw new IOException(\n                        \"Maximum number of objects in the bucket \" + newCount + \" exceeded\");\n            }\n\n            if (!Files.exists(path.getParent())) { // Check to avoid error when the parent is a symlink\n                Files.createDirectories(path.getParent());\n            }\n            Files.write(path, objectData);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          141,
          191
        ]
      },
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "getObject",
        "signature": "byte getObject(String)",
        "lines_hint_csv": [
          190,
          197
        ],
        "code": "    public byte[] getObject(String objectName) throws IOException {\n        Path path = root.resolve(objectName);\n        if (Files.exists(path)) {\n            return Files.readAllBytes(path);\n        } else {\n            return null;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          194,
          201
        ]
      },
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "deleteObject",
        "signature": "void deleteObject(String)",
        "lines_hint_csv": [
          200,
          203
        ],
        "code": "    public void deleteObject(String objectName) throws IOException {\n        Path path = root.resolve(objectName);\n        Files.delete(path);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          204,
          207
        ]
      },
      {
        "file_path": "yamcs-core/src/main/java/org/yamcs/yarch/FileSystemBucket.java",
        "class_name": "FileSystemBucket",
        "method_name": "findObject",
        "signature": "ObjectProperties findObject(String)",
        "lines_hint_csv": [
          206,
          214
        ],
        "code": "    public ObjectProperties findObject(String objectName) throws IOException {\n        Path path = root.resolve(objectName);\n        if (Files.exists(path)) {\n            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n            return toObjectProperties(objectName, path, attrs);\n        } else {\n            return null;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          210,
          218
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-46749",
    "project_slug": "apache__shiro_CVE-2023-46749_1.12.0",
    "buggy_commit_id": "c8a294ab32b29a6e9d4b03bbaa6bae11c42daea1",
    "github_url": "https://github.com/apache/shiro",
    "nvd_metadata": {
      "description": "Apache Shiro before 1.13.0 or 2.0.0-alpha-4, may be susceptible to a path traversal attack that results in an authentication bypass when used together with path rewriting \n\nMitigation: Update to Apache Shiro 1.13.0+ or 2.0.0-alpha-4+, or ensure `blockSemicolon` is enabled (this is the default).\n\n",
      "published_date": "2024-01-15T10:15:26.380",
      "cvss_v3_score": 6.5,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "isNormalized",
        "signature": "boolean isNormalized(String)",
        "lines_hint_csv": [
          142,
          158
        ],
        "code": "    private boolean isNormalized(String path) {\n        if (path == null) {\n            return true;\n        }\n        for (int i = path.length(); i > 0;) {\n            int slashIndex = path.lastIndexOf('/', i - 1);\n            int gap = i - slashIndex;\n            if (gap == 2 && path.charAt(slashIndex + 1) == '.') {\n                return false; // \".\", \"/./\" or \"/.\"\n            }\n            if (gap == 3 && path.charAt(slashIndex + 1) == '.' && path.charAt(slashIndex + 2) == '.') {\n                return false;\n            }\n            i = slashIndex;\n        }\n        return true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          134,
          150
        ]
      },
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "isAccessAllowed",
        "signature": "boolean isAccessAllowed(ServletRequest,ServletResponse,Object)",
        "lines_hint_csv": [
          69,
          77
        ],
        "code": "    protected boolean isAccessAllowed(ServletRequest req, ServletResponse response, Object mappedValue) throws Exception {\n        HttpServletRequest request = WebUtils.toHttp(req);\n        // check the original and decoded values\n        return isValid(request.getRequestURI())      // user request string (not decoded)\n                && isValid(request.getServletPath()) // decoded servlet part\n                && isValid(request.getPathInfo());   // decoded path info (may be null)\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          65,
          71
        ]
      },
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "isValid",
        "signature": "boolean isValid(String)",
        "lines_hint_csv": [
          80,
          85
        ],
        "code": "    private boolean isValid(String uri) {\n        return !StringUtils.hasText(uri)\n               || ( !containsSemicolon(uri)\n                 && !containsBackslash(uri)\n                 && !containsNonAsciiCharacters(uri))\n                 && !containsTraversal(uri);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          73,
          79
        ]
      },
      {
        "file_path": "web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java",
        "class_name": "InvalidRequestFilter",
        "method_name": "containsSemicolon",
        "signature": "boolean containsSemicolon(String)",
        "lines_hint_csv": [
          94,
          98
        ],
        "code": "    private boolean containsSemicolon(String uri) {\n        if (isBlockSemicolon()) {\n            return SEMICOLON.stream().anyMatch(uri::contains);\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          87,
          92
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2024-23673",
    "project_slug": "apache__sling-org-apache-sling-servlets-resolver_CVE-2024-23673_2.10.0",
    "buggy_commit_id": "cb80c5e80144fcd9f6ac283ffb564f3b863cfbb2",
    "github_url": "https://github.com/apache/sling-org-apache-sling-servlets-resolver",
    "nvd_metadata": {
      "description": "Malicious code execution via path traversal in Apache Software Foundation Apache Sling Servlets Resolver.This issue affects all version of Apache Sling Servlets Resolver before 2.11.0. However, whether a system is vulnerable to this attack depends on the exact configuration of the system.\nIf the system is vulnerable, a user with write access to the repository might be able to trick the Sling Servlet Resolver to load a previously uploaded script.\n\nUsers are recommended to upgrade to version 2.11.0, which fixes this issue. It is recommended to upgrade, regardless of whether your system configuration currently allows this attack or not.",
      "published_date": "2024-02-06T10:15:08.833",
      "cvss_v3_score": 8.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/apache/sling/servlets/resolver/internal/SlingScriptResolverImpl.java",
        "class_name": "SlingScriptResolverImpl",
        "method_name": "findScript",
        "signature": "SlingScript findScript(ResourceResolver,String)",
        "lines_hint_csv": [
          64,
          102
        ],
        "code": "    public SlingScript findScript(final ResourceResolver resourceResolver, final String name)\n    throws SlingException {\n\n        // is the path absolute\n        SlingScript script = null;\n        if (name.startsWith(\"/\")) {\n\n            final String path = ResourceUtil.normalize(name);\n            if ( SlingServletResolver.isPathAllowed(path, this.executionPaths) ) {\n                final Resource resource = resourceResolver.getResource(path);\n                if ( resource != null ) {\n                    script = resource.adaptTo(SlingScript.class);\n                }\n            }\n        } else {\n\n            // relative script resolution against search path\n            final String[] path = resourceResolver.getSearchPath();\n            for (int i = 0; script == null && i < path.length; i++) {\n                final String scriptPath = ResourceUtil.normalize(path[i] + name);\n                if ( SlingServletResolver.isPathAllowed(scriptPath, this.executionPaths) ) {\n                    final Resource resource = resourceResolver.getResource(scriptPath);\n                    if (resource != null) {\n                        script = resource.adaptTo(SlingScript.class);\n                    }\n                }\n            }\n\n        }\n\n        // log result\n        if (script != null) {\n            SlingServletResolver.LOGGER.debug(\"findScript: Using script {} for {}\", script.getScriptResource().getPath(), name);\n        } else {\n            SlingServletResolver.LOGGER.info(\"findScript: No script {} found in path\", name);\n        }\n\n        // and finally return the script (or null)\n        return script;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          64,
          103
        ]
      },
      {
        "file_path": "src/main/java/org/apache/sling/servlets/resolver/internal/SlingServletResolver.java",
        "class_name": "SlingServletResolver",
        "method_name": "isPathAllowed",
        "signature": "boolean isPathAllowed(String,String)",
        "lines_hint_csv": [
          745,
          777
        ],
        "code": "    public static boolean isPathAllowed(final String path, final String[] executionPaths) {\n        if (executionPaths == null || executionPaths.length == 0) {\n            LOGGER.debug(\"Accepting servlet at '{}' as there are no configured execution paths.\",\n                path);\n            return true;\n        }\n\n        if (path == null || path.length() == 0) {\n            LOGGER.debug(\"Ignoring servlet with empty path.\");\n            return false;\n        }\n\n        for (final String config : executionPaths) {\n            if (config.endsWith(\"/\")) {\n                if (path.startsWith(config)) {\n                    LOGGER.debug(\n                        \"Accepting servlet at '{}' as the path is prefixed with configured execution path '{}'.\", path,\n                        config);\n                    return true;\n                }\n            } else if (path.equals(config)) {\n                LOGGER.debug(\n                    \"Accepting servlet at '{}' as the path equals configured execution path '{}'.\", path, config);\n                return true;\n            }\n        }\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\n                \"Ignoring servlet at '{}' as the path is not in the configured execution paths.\", path);\n        }\n\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          745,
          778
        ]
      },
      {
        "file_path": "src/main/java/org/apache/sling/servlets/resolver/internal/SlingServletResolver.java",
        "class_name": "SlingServletResolver",
        "method_name": "resolveServletInternal",
        "signature": "Servlet resolveServletInternal(SlingHttpServletRequest,Resource,String,ResourceResolver)",
        "lines_hint_csv": [
          449,
          495
        ],
        "code": "    private Servlet resolveServletInternal(final SlingHttpServletRequest request,\n            final Resource resource,\n            final String scriptNameOrResourceType,\n            final ResourceResolver resolver) {\n        Servlet servlet = null;\n\n        // first check whether the type of a resource is the absolute\n        // path of a servlet (or script)\n        if (scriptNameOrResourceType.charAt(0) == '/') {\n            final String scriptPath = ResourceUtil.normalize(scriptNameOrResourceType);\n            if (scriptPath != null &&  isPathAllowed(scriptPath, this.executionPaths.get()) ) {\n                final Resource res = AbstractResourceCollector.getResourceOrNull(resolver,scriptPath,useResourceCaching);\n                servlet = this.getServlet(res);\n                if (servlet != null && !pathBasedServletAcceptor.accept(request, servlet)) {\n                    if(LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Servlet {} rejected by {} returning FORBIDDEN status\", RequestUtil.getServletName(servlet),\n                        pathBasedServletAcceptor.getClass().getSimpleName());\n                    }\n                    servlet = forbiddenPathServlet;\n                } else if (servlet != null && LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(\"Servlet {} found using absolute resource type {}\", RequestUtil.getServletName(servlet),\n                                    scriptNameOrResourceType);\n                }\n            } else {\n                if ( request != null ) {\n                    request.getRequestProgressTracker().log(\n                            \"Will not look for a servlet at {0} as it is not in the list of allowed paths\",\n                            scriptNameOrResourceType\n                            );\n                }\n            }\n        }\n        if ( servlet == null ) {\n            // the resource type is not absolute, so lets go for the deep search\n            final AbstractResourceCollector locationUtil;\n            if ( request != null ) {\n                locationUtil = ResourceCollector.create(request, this.executionPaths.get(), this.defaultExtensions.get(), this.useResourceCaching);\n            } else {\n                locationUtil = NamedScriptResourceCollector.create(scriptNameOrResourceType, resource, this.executionPaths.get(), this.useResourceCaching);\n            }\n            servlet = getServletInternal(locationUtil, request, resolver);\n\n            if (servlet != null && LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"getServletInternal returns servlet {}\", RequestUtil.getServletName(servlet));\n            }\n        }\n        return servlet;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          449,
          496
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2013-7285",
    "project_slug": "x-stream__xstream_CVE-2013-7285_1.4.6",
    "buggy_commit_id": "768c6e417a75e7732fc591bee844e5e81af56a7d",
    "github_url": "https://github.com/x-stream/xstream",
    "nvd_metadata": {
      "description": "Xstream API versions up to 1.4.6 and version 1.4.10, if the security framework has not been initialized, may allow a remote attacker to run arbitrary shell commands by manipulating the processed input stream when unmarshaling XML or any supported format. e.g. JSON.",
      "published_date": "2019-05-15T17:29:00.297",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "setupAliases",
        "signature": "void setupAliases()",
        "lines_hint_csv": [
          648,
          732
        ],
        "code": "    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n        \n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            // Instantiating these two classes starts the AWT system, which is undesirable.\n            // Calling loadClass ensures a reference to the class is found but they are not\n            // instantiated.\n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.is14()) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.is15()) {\n            aliasDynamically(\"duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          642,
          728
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "buildMapper",
        "signature": "Mapper buildMapper()",
        "lines_hint_csv": [
          568,
          600
        ],
        "code": "    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.is15()) {\n            mapper = buildMapperDynamically(\n                \"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.is15()) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class,\n                ClassLoaderReference.class, ReflectionProvider.class}, new Object[]{\n                mapper, converterLookup, converterLookup, classLoaderReference,\n                reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          562,
          595
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "buildMapperDynamically",
        "signature": "Mapper buildMapperDynamically(String,Class,Object)",
        "lines_hint_csv": [
          603,
          611
        ],
        "code": "    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n        Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          597,
          607
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/mapper/CachingMapper.java",
        "class_name": "CachingMapper",
        "method_name": "realClass",
        "signature": "Class realClass(String)",
        "lines_hint_csv": [
          35,
          50
        ],
        "code": "    public Class realClass(String elementName) {\n        Object cached = realClassCache.get(elementName);\n        if (cached != null) {\n            if (cached instanceof Class) {\n                return (Class)cached;\n            }\n            throw (CannotResolveClassException)cached;\n        }\n\n        try {\n            Class result = super.realClass(elementName);\n            realClassCache.put(elementName, result);\n            return result;\n        } catch (CannotResolveClassException e) {\n            realClassCache.put(elementName, e);\n            throw e;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          35,
          52
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/mapper/CachingMapper.java",
        "class_name": "CachingMapper",
        "method_name": "flushCache",
        "signature": "void flushCache()",
        "lines_hint_csv": [
          54,
          55
        ],
        "code": "    public void flushCache() {\n        realClassCache.clear();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          54,
          56
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/converters/extended/FileConverter.java",
        "class_name": "FileConverter",
        "method_name": "fromString",
        "signature": "Object fromString(String str)",
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "    public Object fromString(String str) {\n        return new File(str);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          30,
          32
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-26217",
    "project_slug": "x-stream__xstream_CVE-2020-26217_1.4.14-java7",
    "buggy_commit_id": "d03f6987b793fac71ab89a31d7aa633c366c5289",
    "github_url": "https://github.com/x-stream/xstream",
    "nvd_metadata": {
      "description": "XStream before version 1.4.14 is vulnerable to Remote Code Execution.The vulnerability may allow a remote attacker to run arbitrary shell commands only by manipulating the processed input stream. Only users who rely on blocklists are affected. Anyone using XStream's Security Framework allowlist is not affected. The linked advisory provides code workarounds for users who cannot upgrade. The issue is fixed in version 1.4.14.",
      "published_date": "2020-11-16T21:15:12.893",
      "cvss_v3_score": 8.0,
      "severity": "HIGH"
    },
    "code_snippets": []
  },
  {
    "cve_id": "CVE-2021-21345",
    "project_slug": "x-stream__xstream_CVE-2021-21345_1.4.15",
    "buggy_commit_id": "f04bbec461f2c2a6f1e2cf41770f42c64aae24a4",
    "github_url": "https://github.com/x-stream/xstream",
    "nvd_metadata": {
      "description": "XStream is a Java library to serialize objects to XML and back again. In XStream before version 1.4.16, there is a vulnerability which may allow a remote attacker who has sufficient rights to execute commands of the host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. If you rely on XStream's default blacklist of the Security Framework, you will have to use at least version 1.4.16.",
      "published_date": "2021-03-23T00:15:12.787",
      "cvss_v3_score": 5.8,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "setupSecurity",
        "signature": "void setupSecurity()",
        "lines_hint_csv": [
          640,
          653
        ],
        "code": "    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n\n        addPermission(AnyTypePermission.ANY);\n        denyTypes(new String[]{\n            \"java.beans.EventHandler\", //\n            \"java.lang.ProcessBuilder\", //\n            \"javax.imageio.ImageIO$ContainsFilter\", //\n            \"jdk.nashorn.internal.objects.NativeString\" });\n        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO, JAXWS_FILE_STREAM});\n        allowTypeHierarchy(Exception.class);\n        securityInitialized = false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          640,
          654
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "alias",
        "signature": "void alias(String,Class)",
        "lines_hint_csv": [
          1426,
          1432
        ],
        "code": "    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1426,
          1433
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "setupMappers",
        "signature": "void setupMappers()",
        "lines_hint_csv": [
          619,
          637
        ],
        "code": "    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper.lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper.lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper.lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper.lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper.lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper.lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper.lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper.lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          619,
          638
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "setupDefaultSecurity",
        "signature": "void setupDefaultSecurity(XStream)",
        "lines_hint_csv": [
          667,
          750
        ],
        "code": "    public static void setupDefaultSecurity(final XStream xstream) {\n        if (!xstream.securityInitialized) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          667,
          752
        ]
      },
      {
        "file_path": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
        "class_name": "XStream",
        "method_name": "unmarshal",
        "signature": "Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder)",
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (!securityInitialized && !securityWarningGiven) {\n                securityWarningGiven = true;\n                System.err\n                    .println(\n                        \"Security framework of XStream not explicitly initialized, using predefined black list on your own risk.\");\n            }\n            return marshallingStrategy.unmarshal(root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1401,
          1417
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-20617",
    "project_slug": "jenkinsci__docker-commons-plugin_CVE-2022-20617_1.17",
    "buggy_commit_id": "2f0fda49452a7653c33de24220c908786f1aa405",
    "github_url": "https://github.com/jenkinsci/docker-commons-plugin",
    "nvd_metadata": {
      "description": "Jenkins Docker Commons Plugin 1.17 and earlier does not sanitize the name of an image or a tag, resulting in an OS command execution vulnerability exploitable by attackers with Item/Configure permission or able to control the contents of a previously configured job's SCM repository.",
      "published_date": "2022-01-12T20:15:08.907",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/docker/commons/credentials/DockerRegistryEndpoint.java",
        "class_name": "DockerRegistryEndpoint",
        "method_name": "imageName",
        "signature": "String imageName(String)",
        "lines_hint_csv": [
          311,
          327
        ],
        "code": "    public String imageName(@Nonnull String userAndRepo) throws IOException {\n        if (userAndRepo == null) {\n            throw new IllegalArgumentException(\"Image name cannot be null.\");\n        }\n        if (url == null) {\n            return userAndRepo;\n        }\n        URL effectiveUrl = getEffectiveUrl();\n\n        StringBuilder s = new StringBuilder(effectiveUrl.getHost());\n        if (effectiveUrl.getPort() > 0 ) {\n            s.append(':').append(effectiveUrl.getPort());\n        }\n        if (userAndRepo.startsWith(String.valueOf(s))) {\n            return userAndRepo;\n        }\n        return s.append('/').append(userAndRepo).toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          311,
          328
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/docker/commons/credentials/DockerRegistryEndpointTest.java",
        "class_name": "DockerRegistryEndpointTest",
        "method_name": "testParseFullyQualifiedImageName",
        "signature": "void testParseFullyQualifiedImageName()",
        "lines_hint_csv": [
          89,
          91
        ],
        "code": "    public void testParseFullyQualifiedImageName() throws Exception {\n        assertEquals(\"private-repo:5000/test-image\", new DockerRegistryEndpoint(\"http://private-repo:5000/\", null).imageName(\"private-repo:5000/test-image\"));\n        assertEquals(\"private-repo:5000/test-image\", new DockerRegistryEndpoint(\"http://private-repo:5000/\", null).imageName(\"test-image\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          89,
          92
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-25173",
    "project_slug": "jenkinsci__workflow-cps-plugin_CVE-2022-25173_2646.v6ed3b5b01ff1",
    "buggy_commit_id": "6ed3b5b01ff16dc4f6f9f4b209dbc21394b13913",
    "github_url": "https://github.com/jenkinsci/workflow-cps-plugin",
    "nvd_metadata": {
      "description": "Jenkins Pipeline: Groovy Plugin 2648.va9433432b33c and earlier uses the same checkout directories for distinct SCMs when reading the script file (typically Jenkinsfile) for Pipelines, allowing attackers with Item/Configure permission to invoke arbitrary OS commands on the controller through crafted SCM contents.",
      "published_date": "2022-02-15T17:15:08.477",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/cps/CpsScmFlowDefinition.java",
        "class_name": "CpsScmFlowDefinition",
        "method_name": "CpsScmFlowDefinition",
        "signature": "CpsScmFlowDefinition(SCM,String)",
        "lines_hint_csv": [
          75,
          77
        ],
        "code": "    @DataBoundConstructor public CpsScmFlowDefinition(SCM scm, String scriptPath) {\n        this.scm = scm;\n        this.scriptPath = scriptPath.trim();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          75,
          78
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/cps/CpsScmFlowDefinition.java",
        "class_name": "CpsScmFlowDefinition",
        "method_name": "create",
        "signature": "CpsFlowExecution create(FlowExecutionOwner,TaskListener,List)",
        "lines_hint_csv": [
          101,
          190
        ],
        "code": "    @Override public CpsFlowExecution create(FlowExecutionOwner owner, TaskListener listener, List<? extends Action> actions) throws Exception {\n        for (Action a : actions) {\n            if (a instanceof CpsFlowFactoryAction2) {\n                return ((CpsFlowFactoryAction2) a).create(this, owner, actions);\n            }\n        }\n        Queue.Executable _build = owner.getExecutable();\n        if (!(_build instanceof Run)) {\n            throw new IOException(\"can only check out SCM into a Run\");\n        }\n        Run<?,?> build = (Run<?,?>) _build;\n        String expandedScriptPath = build.getEnvironment(listener).expand(scriptPath);\n        if (isLightweight()) {\n            try (SCMFileSystem fs = SCMFileSystem.of(build.getParent(), scm)) {\n                if (fs != null) {\n                    try {\n                        String script = fs.child(expandedScriptPath).contentAsString();\n                        listener.getLogger().println(\"Obtained \" + expandedScriptPath + \" from \" + scm.getKey());\n                        Queue.Executable exec = owner.getExecutable();\n                        FlowDurabilityHint hint = (exec instanceof Run) ? DurabilityHintProvider.suggestedFor(((Run)exec).getParent()) : GlobalDefaultFlowDurabilityLevel.getDefaultDurabilityHint();\n                        return new CpsFlowExecution(script, true, owner, hint);\n                    } catch (FileNotFoundException e) {\n                        throw new AbortException(\"Unable to find \" + expandedScriptPath + \" from \" + scm.getKey());\n                    }\n                } else {\n                    listener.getLogger().println(\"Lightweight checkout support not available, falling back to full checkout.\");\n                }\n            }\n        }\n        FilePath dir;\n        Node node = Jenkins.get();\n        if (build.getParent() instanceof TopLevelItem) {\n            FilePath baseWorkspace = node.getWorkspaceFor((TopLevelItem) build.getParent());\n            if (baseWorkspace == null) {\n                throw new IOException(node.getDisplayName() + \" may be offline\");\n            }\n            dir = getFilePathWithSuffix(baseWorkspace);\n        } else { // should not happen, but just in case:\n            dir = new FilePath(owner.getRootDir());\n        }\n        listener.getLogger().println(\"Checking out \" + scm.getKey() + \" into \" + dir + \" to read \" + expandedScriptPath);\n        String script = null;\n        Computer computer = node.toComputer();\n        if (computer == null) {\n            throw new IOException(node.getDisplayName() + \" may be offline\");\n        }\n        SCMStep delegate = new GenericSCMStep(scm);\n        delegate.setPoll(true);\n        delegate.setChangelog(true);\n        FilePath acquiredDir;\n        try (WorkspaceList.Lease lease = computer.getWorkspaceList().acquire(dir)) {\n            for (int retryCount = Jenkins.get().getScmCheckoutRetryCount(); retryCount >= 0; retryCount--) {\n                try {\n                    delegate.checkout(build, dir, listener, node.createLauncher(listener));\n                    break;\n                } catch (AbortException e) {\n                    // abort exception might have a null message.\n                    // If so, just skip echoing it.\n                    if (e.getMessage() != null) {\n                        listener.error(e.getMessage());\n                    }\n                } catch (InterruptedIOException e) {\n                    throw e;\n                } catch (Exception e) {\n                    // checkout error not yet reported\n                    Functions.printStackTrace(e, listener.error(\"Checkout failed\"));\n                }\n\n                if (retryCount == 0)   // all attempts failed\n                    throw new AbortException(\"Maximum checkout retry attempts reached, aborting\");\n\n                listener.getLogger().println(\"Retrying after 10 seconds\");\n                Thread.sleep(10000);\n            }\n\n            FilePath scriptFile = dir.child(expandedScriptPath);\n            if (!scriptFile.absolutize().getRemote().replace('\\\\', '/').startsWith(dir.absolutize().getRemote().replace('\\\\', '/') + '/')) { // TODO JENKINS-26838\n                throw new IOException(scriptFile + \" is not inside \" + dir);\n            }\n            if (!scriptFile.exists()) {\n                throw new AbortException(scriptFile + \" not found\");\n            }\n            script = scriptFile.readToString();\n            acquiredDir = lease.path;\n        }\n        Queue.Executable queueExec = owner.getExecutable();\n        FlowDurabilityHint hint = (queueExec instanceof Run) ? DurabilityHintProvider.suggestedFor(((Run)queueExec).getParent()) : GlobalDefaultFlowDurabilityLevel.getDefaultDurabilityHint();\n        CpsFlowExecution exec = new CpsFlowExecution(script, true, owner, hint);\n        exec.flowStartNodeActions.add(new WorkspaceActionImpl(acquiredDir, null));\n        return exec;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          101,
          191
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/cps/DSL.java",
        "class_name": "DSL",
        "method_name": "logInterpolationWarnings",
        "signature": "void logInterpolationWarnings(String,ArgumentsActionImpl,Set,EnvVars,Set,TaskListener)",
        "lines_hint_csv": [
          363,
          405
        ],
        "code": "    private void logInterpolationWarnings(String stepName, @CheckForNull ArgumentsActionImpl argumentsAction, Set<String> interpolatedStrings, @CheckForNull EnvVars envVars, @Nonnull Set<String> sensitiveVariables, TaskListener listener) throws IOException {\n        if (UNSAFE_GROOVY_INTERPOLATION.equals(\"ignore\")) {\n            return;\n        }\n        boolean shouldFail;\n        if (UNSAFE_GROOVY_INTERPOLATION.equals(\"fail\")) {\n            shouldFail = true;\n        } else {\n            shouldFail = false;\n        }\n\n        if (argumentsAction == null || interpolatedStrings.isEmpty() || envVars == null || envVars.isEmpty() || sensitiveVariables.isEmpty()) {\n            return;\n        }\n\n        List<String> scanResults = sensitiveVariables.stream()\n                .filter(e -> !envVars.get(e, \"\").isEmpty() && interpolatedStrings.stream().anyMatch(g -> g.contains(envVars.get(e))))\n                .collect(Collectors.toList());\n\n        if (scanResults != null && !scanResults.isEmpty()) {\n            String warningType;\n            if (shouldFail) {\n                warningType = \"Error\";\n            } else {\n                warningType = \"Warning\";\n            }\n            String warning = String.format(\"%s: A secret was passed to \\\"%s\\\" using Groovy String interpolation, which is insecure.%n\\t\\t Affected argument(s) used the following variable(s): %s%n\\t\\t See https://jenkins.io/redirect/groovy-string-interpolation for details.\",\n                    warningType, stepName, scanResults.toString());\n            FlowExecutionOwner owner = exec.getOwner();\n            if (owner != null && owner.getExecutable() instanceof Run) {\n                InterpolatedSecretsAction runReport = ((Run) owner.getExecutable()).getAction(InterpolatedSecretsAction.class);\n                if (runReport == null) {\n                    runReport = new InterpolatedSecretsAction();\n                    ((Run) owner.getExecutable()).addAction(runReport);\n                }\n                runReport.record(stepName, scanResults);\n            } else {\n                LOGGER.log(Level.FINE, \"Unable to generate Interpolated Secrets Report\");\n            }\n            if (shouldFail) {\n                throw new AbortException(warning);\n            } else {\n                listener.getLogger().println(warning);\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          363,
          408
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/cps/CpsScmFlowDefinitionTest.java",
        "class_name": "CpsScmFlowDefinitionTest",
        "method_name": "basics",
        "signature": "void basics()",
        "lines_hint_csv": [
          82,
          99
        ],
        "code": "    @Test public void basics() throws Exception {\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        CpsScmFlowDefinition def = new CpsScmFlowDefinition(new SingleFileSCM(\"flow.groovy\", \"echo 'hello from SCM'\"), \"flow.groovy\");\n        def.setLightweight(false); // currently the default, but just to be clear that we do rely on that in this test\n        p.setDefinition(def);\n        WorkflowRun b = r.assertBuildStatusSuccess(p.scheduleBuild2(0));\n        // TODO currently the log text is in Run.log, but not on FlowStartNode/LogAction, so not visible from Workflow Steps etc.\n        r.assertLogContains(\"hello from SCM\", b);\n        r.assertLogContains(\"Staging flow.groovy\", b);\n        r.assertLogNotContains(\"Retrying after 10 seconds\", b);\n        FlowGraphWalker w = new FlowGraphWalker(b.getExecution());\n        int workspaces = 0;\n        for (FlowNode n : w) {\n            if (n.getAction(WorkspaceAction.class) != null) {\n                workspaces++;\n            }\n        }\n        assertEquals(1, workspaces);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          82,
          100
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/cps/CpsScmFlowDefinition.java",
        "class_name": "CpsScmFlowDefinition",
        "method_name": "getFilePathWithSuffix",
        "signature": null,
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "    private FilePath getFilePathWithSuffix(FilePath baseWorkspace) {\n        return baseWorkspace.withSuffix(getFilePathSuffix() + \"script\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          193,
          195
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-25174",
    "project_slug": "jenkinsci__workflow-cps-global-lib-plugin_CVE-2022-25174_544.vff04fa68714d",
    "buggy_commit_id": "ff04fa68714d2cc277e8a87512461bdf3a39e186",
    "github_url": "https://github.com/jenkinsci/workflow-cps-global-lib-plugin",
    "nvd_metadata": {
      "description": "Jenkins Pipeline: Shared Groovy Libraries Plugin 552.vd9cc05b8a2e1 and earlier uses the same checkout directories for distinct SCMs for Pipeline libraries, allowing attackers with Item/Configure permission to invoke arbitrary OS commands on the controller through crafted SCM contents.",
      "published_date": "2022-02-15T17:15:08.560",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/FolderLibraries.java",
        "class_name": "ForJob",
        "method_name": "forGroup",
        "signature": "Collection forGroup(ItemGroup,boolean)",
        "lines_hint_csv": [
          73,
          84
        ],
        "code": "        private Collection<LibraryConfiguration> forGroup(@CheckForNull ItemGroup<?> group, boolean checkPermission) {\n            List<LibraryConfiguration> libraries = new ArrayList<>();\n            for (ItemGroup<?> g = group; g instanceof AbstractFolder; g = ((AbstractFolder) g).getParent()) {\n                AbstractFolder<?> f = (AbstractFolder<?>) g;\n                if (!checkPermission || f.hasPermission(Item.CONFIGURE)) {\n                    FolderLibraries prop = f.getProperties().get(FolderLibraries.class);\n                    if (prop != null) {\n                        libraries.addAll(prop.getLibraries());\n                    }\n                }\n            }\n            return libraries;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          73,
          85
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryAdder.java",
        "class_name": "LibraryAdder",
        "method_name": "retrieve",
        "signature": "List retrieve(String,String,LibraryRetriever,boolean,Boolean,LibraryCachingConfiguration,TaskListener,Run,CpsFlowExecution,Set)",
        "lines_hint_csv": [
          155,
          230
        ],
        "code": "    static List<URL> retrieve(@Nonnull String name, @Nonnull String version, @Nonnull LibraryRetriever retriever, boolean trusted, Boolean changelog, LibraryCachingConfiguration cachingConfiguration, @Nonnull TaskListener listener, @Nonnull Run<?,?> run, @Nonnull CpsFlowExecution execution, @Nonnull Set<String> variables) throws Exception {\n        FilePath libDir = new FilePath(execution.getOwner().getRootDir()).child(\"libs/\" + name);\n        Boolean shouldCache = cachingConfiguration != null;\n        final FilePath libraryCacheDir = new FilePath(LibraryCachingConfiguration.getGlobalLibrariesCacheDir(), name);\n        final FilePath versionCacheDir = new FilePath(libraryCacheDir, version);\n        final FilePath retrieveLockFile = new FilePath(versionCacheDir, LibraryCachingConfiguration.RETRIEVE_LOCK_FILE);\n        final FilePath lastReadFile = new FilePath(versionCacheDir, LibraryCachingConfiguration.LAST_READ_FILE);\n\n        if(shouldCache && cachingConfiguration.isExcluded(version)) {\n            listener.getLogger().println(\"Library \" + name + \"@\" + version + \" is excluded from caching.\");\n            shouldCache = false;\n        }\n\n        if(shouldCache && retrieveLockFile.exists()) {\n            listener.getLogger().println(\"Library \" + name + \"@\" + version + \" is currently being cached by another job, retrieving without cache.\");\n            shouldCache = false;\n        }\n\n        if(shouldCache) {\n            if (cachingConfiguration.isRefreshEnabled()) {\n                final long cachingMinutes = cachingConfiguration.getRefreshTimeMinutes();\n                final long cachingMilliseconds = cachingConfiguration.getRefreshTimeMilliseconds();\n\n                if(versionCacheDir.exists() && (versionCacheDir.lastModified() + cachingMilliseconds) < System.currentTimeMillis()) {\n                    listener.getLogger().println(\"Library \" + name + \"@\" + version + \" is due for a refresh after \" + cachingMinutes + \" minutes, clearing.\");\n                    versionCacheDir.deleteRecursive();\n                }\n            }\n\n            if(versionCacheDir.exists()) {\n                listener.getLogger().println(\"Library \" + name + \"@\" + version + \" is cached. Copying from home.\");\n                lastReadFile.touch(System.currentTimeMillis());\n            } else {\n                listener.getLogger().println(\"Caching library \" + name + \"@\" + version);\n                versionCacheDir.mkdirs();\n                retrieveLockFile.touch(System.currentTimeMillis());\n                retriever.retrieve(name, version, changelog, versionCacheDir, run, listener);\n                retrieveLockFile.delete();\n            }\n            versionCacheDir.copyRecursiveTo(libDir);\n        } else {\n            retriever.retrieve(name, version, changelog, libDir, run, listener);\n        }\n\n        // Replace any classes requested for replay:\n        if (!trusted) {\n            for (String clazz : ReplayAction.replacementsIn(execution)) {\n                for (String root : new String[] {\"src\", \"vars\"}) {\n                    String rel = root + \"/\" + clazz.replace('.', '/') + \".groovy\";\n                    FilePath f = libDir.child(rel);\n                    if (f.exists()) {\n                        String replacement = ReplayAction.replace(execution, clazz);\n                        if (replacement != null) {\n                            listener.getLogger().println(\"Replacing contents of \" + rel);\n                            f.write(replacement, null); // TODO as below, unsure of encoding used by Groovy compiler\n                        }\n                    }\n                }\n            }\n        }\n        List<URL> urls = new ArrayList<>();\n        FilePath srcDir = libDir.child(\"src\");\n        if (srcDir.isDirectory()) {\n            urls.add(srcDir.toURI().toURL());\n        }\n        FilePath varsDir = libDir.child(\"vars\");\n        if (varsDir.isDirectory()) {\n            urls.add(varsDir.toURI().toURL());\n            for (FilePath var : varsDir.list(\"*.groovy\")) {\n                variables.add(var.getBaseName());\n            }\n        }\n        if (urls.isEmpty()) {\n            throw new AbortException(\"Library \" + name + \" expected to contain at least one of src or vars directories\");\n        }\n        return urls;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          155,
          231
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryAdder.java",
        "class_name": "LibraryAdder",
        "method_name": "findResources",
        "signature": "Map findResources(CpsFlowExecution,String,String)",
        "lines_hint_csv": [
          239,
          255
        ],
        "code": "    static @Nonnull Map<String,String> findResources(@Nonnull CpsFlowExecution execution, @Nonnull String name, @CheckForNull String encoding) throws IOException, InterruptedException {\n        Map<String,String> resources = new TreeMap<>();\n        Queue.Executable executable = execution.getOwner().getExecutable();\n        if (executable instanceof Run) {\n            Run<?,?> run = (Run) executable;\n            LibrariesAction action = run.getAction(LibrariesAction.class);\n            if (action != null) {\n                FilePath libs = new FilePath(run.getRootDir()).child(\"libs\");\n                for (LibraryRecord library : action.getLibraries()) {\n                    FilePath f = libs.child(library.name + \"/resources/\" + name);\n                    if (f.exists()) {\n                        resources.put(library.name, readResource(f, encoding));\n                    }\n                }\n            }\n        }\n        return resources;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          239,
          256
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryAdder.java",
        "class_name": "LibraryAdder",
        "method_name": "parse",
        "signature": "String parse(String)",
        "lines_hint_csv": [
          145,
          150
        ],
        "code": "    static @Nonnull String[] parse(@Nonnull String identifier) {\n       int at = identifier.indexOf('@');\n        if (at == -1) {\n            return new String[] {identifier, null}; // pick up defaultVersion\n        } else {\n            return new String[] {identifier.substring(0, at), identifier.substring(at + 1)};\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          145,
          152
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryAdder.java",
        "class_name": "LibraryAdder",
        "method_name": "add",
        "signature": "List add(CpsFlowExecution,List,HashMap)",
        "lines_hint_csv": [
          68,
          142
        ],
        "code": "    @Override public List<Addition> add(CpsFlowExecution execution, List<String> libraries, HashMap<String, Boolean> changelogs) throws Exception {\n        Queue.Executable executable = execution.getOwner().getExecutable();\n        Run<?,?> build;\n        if (executable instanceof Run) {\n            build = (Run) executable;\n        } else {\n            // SCM.checkout does not make it possible to do checkouts outside the context of a Run.\n            return Collections.emptyList();\n        }\n        // First parse the library declarations (if any) looking for requested versions.\n        Map<String,String> libraryVersions = new HashMap<>();\n        Map<String,Boolean> libraryChangelogs = new HashMap<>();\n        Map<String,String> librariesUnparsed = new HashMap<>();\n        for (String library : libraries) {\n            String[] parsed = parse(library);\n            libraryVersions.put(parsed[0], parsed[1]);\n            libraryChangelogs.put(parsed[0], changelogs.get(library));\n            librariesUnparsed.put(parsed[0], library);\n        }\n        List<Addition> additions = new ArrayList<>();\n        LibrariesAction action = build.getAction(LibrariesAction.class);\n        if (action != null) {\n            // Resuming a build, so just look up what we loaded before.\n            for (LibraryRecord record : action.getLibraries()) {\n                FilePath libDir = new FilePath(execution.getOwner().getRootDir()).child(\"libs/\" + record.name);\n                for (String root : new String[] {\"src\", \"vars\"}) {\n                    FilePath dir = libDir.child(root);\n                    if (dir.isDirectory()) {\n                        additions.add(new Addition(dir.toURI().toURL(), record.trusted));\n                    }\n                }\n                String unparsed = librariesUnparsed.get(record.name);\n                if (unparsed != null) {\n                    libraries.remove(unparsed);\n                }\n            }\n            return additions;\n        }\n        // Now we will see which libraries we want to load for this job.\n        Map<String,LibraryRecord> librariesAdded = new LinkedHashMap<>();\n        Map<String,LibraryRetriever> retrievers = new HashMap<>();\n        TaskListener listener = execution.getOwner().getListener();\n        for (LibraryResolver kind : ExtensionList.lookup(LibraryResolver.class)) {\n            boolean kindTrusted = kind.isTrusted();\n            for (LibraryConfiguration cfg : kind.forJob(build.getParent(), libraryVersions)) {\n                String name = cfg.getName();\n                if (!cfg.isImplicit() && !libraryVersions.containsKey(name)) {\n                    continue; // not using this one at all\n                }\n                if (librariesAdded.containsKey(name)) {\n                    listener.getLogger().println(\"Only using first definition of library \" + name);\n                    continue;\n                }\n                String version = cfg.defaultedVersion(libraryVersions.remove(name));\n                Boolean changelog = cfg.defaultedChangelogs(libraryChangelogs.remove(name));\n                librariesAdded.put(name, new LibraryRecord(name, version, kindTrusted, changelog, cfg.getCachingConfiguration()));\n                retrievers.put(name, cfg.getRetriever());\n            }\n        }\n        for (String name : librariesAdded.keySet()) {\n            String unparsed = librariesUnparsed.get(name);\n            if (unparsed != null) {\n                libraries.remove(unparsed);\n            }\n        }\n        // Record libraries we plan to load. We need LibrariesAction there first so variables can be interpolated.\n        build.addAction(new LibrariesAction(new ArrayList<>(librariesAdded.values())));\n        // Now actually try to retrieve the libraries.\n        for (LibraryRecord record : librariesAdded.values()) {\n            listener.getLogger().println(\"Loading library \" + record.name + \"@\" + record.version);\n            for (URL u : retrieve(record.name, record.version, retrievers.get(record.name), record.trusted, record.changelog, record.cachingConfiguration, listener, build, execution, record.variables)) {\n                additions.add(new Addition(u, record.trusted));\n            }\n        }\n        return additions;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          68,
          143
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryAdder.java",
        "class_name": "LoadedLibraries",
        "method_name": "loadScripts",
        "signature": "Map loadScripts(CpsFlowExecution)",
        "lines_hint_csv": [
          293,
          322
        ],
        "code": "        @Override public Map<String,String> loadScripts(CpsFlowExecution execution) {\n            Map<String,String> scripts = new HashMap<>();\n            try {\n                Queue.Executable executable = execution.getOwner().getExecutable();\n                if (executable instanceof Run) {\n                    Run<?,?> run = (Run) executable;\n                    LibrariesAction action = run.getAction(LibrariesAction.class);\n                    if (action != null) {\n                        FilePath libs = new FilePath(run.getRootDir()).child(\"libs\");\n                        for (LibraryRecord library : action.getLibraries()) {\n                            if (library.trusted) {\n                                continue; // TODO JENKINS-41157 allow replay of trusted libraries if you have RUN_SCRIPTS\n                            }\n                            for (String rootName : new String[] {\"src\", \"vars\"}) {\n                                FilePath root = libs.child(library.name + \"/\" + rootName);\n                                if (!root.isDirectory()) {\n                                    continue;\n                                }\n                                for (FilePath groovy : root.list(\"**/*.groovy\")) {\n                                    String clazz = groovy.getRemote().replaceFirst(\"^\\\\Q\" + root.getRemote() + \"\\\\E[/\\\\\\\\](.+)[.]groovy\", \"$1\").replace('/', '.').replace('\\\\', '.');\n                                    scripts.put(clazz, groovy.readToString()); // TODO no idea what encoding the Groovy compiler uses\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException | InterruptedException x) {\n                LOGGER.log(Level.WARNING, null, x);\n            }\n            return scripts;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          293,
          323
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryResolver.java",
        "class_name": "LibraryResolver",
        "method_name": "suggestedConfigurations",
        "signature": "Collection suggestedConfigurations(ItemGroup)",
        "lines_hint_csv": [
          84,
          85
        ],
        "code": "    public @Nonnull Collection<LibraryConfiguration> suggestedConfigurations(@Nonnull ItemGroup<?> group) {\n        return Collections.emptySet();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          84,
          86
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryStep.java",
        "class_name": "Execution",
        "method_name": "run",
        "signature": "LoadedClasses run()",
        "lines_hint_csv": [
          163,
          214
        ],
        "code": "        @Override protected LoadedClasses run() throws Exception {\n            String[] parsed = LibraryAdder.parse(step.identifier);\n            String name = parsed[0], version = parsed[1];\n            boolean trusted = false;\n            Boolean changelog = step.getChangelog();\n            LibraryCachingConfiguration cachingConfiguration = null;\n            LibraryRetriever retriever = step.getRetriever();\n            if (retriever == null) {\n                for (LibraryResolver resolver : ExtensionList.lookup(LibraryResolver.class)) {\n                    for (LibraryConfiguration cfg : resolver.forJob(run.getParent(), Collections.singletonMap(name, version))) {\n                        if (cfg.getName().equals(name)) {\n                            retriever = cfg.getRetriever();\n                            trusted = resolver.isTrusted();\n                            version = cfg.defaultedVersion(version);\n                            changelog = cfg.defaultedChangelogs(changelog);\n                            cachingConfiguration = cfg.getCachingConfiguration();\n                            break;\n                        }\n                    }\n                }\n                if (retriever == null) {\n                    throw new AbortException(\"No library named \" + name + \" found\");\n                }\n            } else if (version == null) {\n                throw new AbortException(\"Must specify a version for library \" + name);\n            }\n\n            LibraryRecord record = new LibraryRecord(name, version, trusted, changelog, cachingConfiguration);\n            LibrariesAction action = run.getAction(LibrariesAction.class);\n            if (action == null) {\n                action = new LibrariesAction(Lists.newArrayList(record));\n                run.addAction(action);\n            } else {\n                List<LibraryRecord> libraries = action.getLibraries();\n                for (LibraryRecord existing : libraries) {\n                    if (existing.name.equals(name)) {\n                        listener.getLogger().println(\"Only using first definition of library \" + name);\n                        return new LoadedClasses(name, trusted, changelog, run);\n                    }\n                }\n                List<LibraryRecord> newLibraries = new ArrayList<>(libraries);\n                newLibraries.add(record);\n                run.replaceAction(new LibrariesAction(newLibraries));\n            }\n            listener.getLogger().println(\"Loading library \" + record.name + \"@\" + record.version);\n            CpsFlowExecution exec = (CpsFlowExecution) getContext().get(FlowExecution.class);\n            GroovyClassLoader loader = (trusted ? exec.getTrustedShell() : exec.getShell()).getClassLoader();\n            for (URL u : LibraryAdder.retrieve(record.name, record.version, retriever, record.trusted, record.changelog, record.cachingConfiguration, listener, run, (CpsFlowExecution) getContext().get(FlowExecution.class), record.variables)) {\n                loader.addURL(u);\n            }\n            run.save(); // persist changes to LibrariesAction.libraries*.variables\n            return new LoadedClasses(name, trusted, changelog, run);\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          163,
          215
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/LibraryStep.java",
        "class_name": "LoadedClasses",
        "method_name": "LoadedClasses",
        "signature": "LoadedClasses(String,boolean,Boolean,String,String,String)",
        "lines_hint_csv": [
          235,
          241
        ],
        "code": "        LoadedClasses(String library, boolean trusted, Boolean changelog, String prefix, String clazz, String srcUrl) {\n            this.library = library;\n            this.trusted = trusted;\n            this.changelog = changelog;\n            this.prefix = prefix;\n            this.clazz = clazz;\n            this.srcUrl = srcUrl;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          235,
          242
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/libs/SCMSourceRetriever.java",
        "class_name": "SCMSourceRetriever",
        "method_name": "doRetrieve",
        "signature": "void doRetrieve(String,boolean,SCM,String,FilePath,Run,TaskListener)",
        "lines_hint_csv": [
          176,
          213
        ],
        "code": "    static void doRetrieve(String name, boolean changelog, @Nonnull SCM scm, String libraryPath, FilePath target, Run<?, ?> run, TaskListener listener) throws Exception {\n        // Adapted from CpsScmFlowDefinition:\n        SCMStep delegate = new GenericSCMStep(scm);\n        delegate.setPoll(false); // TODO we have no API for determining if a given SCMHead is branch-like or tag-like; would we want to turn on polling if the former?\n        delegate.setChangelog(changelog);\n        FilePath dir;\n        Node node = Jenkins.get();\n        if (run.getParent() instanceof TopLevelItem) {\n            FilePath baseWorkspace = node.getWorkspaceFor((TopLevelItem) run.getParent());\n            if (baseWorkspace == null) {\n                throw new IOException(node.getDisplayName() + \" may be offline\");\n            }\n            dir = baseWorkspace.withSuffix(getFilePathSuffix() + \"libs\").child(name);\n        } else { // should not happen, but just in case:\n            throw new AbortException(\"Cannot check out in non-top-level build\");\n        }\n        Computer computer = node.toComputer();\n        if (computer == null) {\n            throw new IOException(node.getDisplayName() + \" may be offline\");\n        }\n        try (WorkspaceList.Lease lease = computer.getWorkspaceList().allocate(dir)) {\n            retrySCMOperation(listener, () -> {\n                delegate.checkout(run, lease.path, listener, node.createLauncher(listener));\n                return null;\n            });\n            if (libraryPath == null) {\n                libraryPath = \".\";\n            } else if (PROHIBITED_DOUBLE_DOT.matcher(libraryPath).matches()) {\n                throw new AbortException(\"Library path may not contain '..'\");\n            }\n            String excludes = INCLUDE_SRC_TEST_IN_LIBRARIES ? null : \"src/test/\";\n            if (lease.path.child(libraryPath).child(\"src/test\").exists()) {\n                listener.getLogger().println(\"Excluding src/test/ from checkout of \" + scm.getKey() + \" so that shared library test code cannot be accessed by Pipelines.\");\n                listener.getLogger().println(\"To remove this log message, move the test code outside of src/. To restore the previous behavior that allowed access to files in src/test/, pass -D\" + SCMSourceRetriever.class.getName() + \".INCLUDE_SRC_TEST_IN_LIBRARIES=true to the java command used to start Jenkins.\");\n            }\n            // Cannot add WorkspaceActionImpl to private CpsFlowExecution.flowStartNodeActions; do we care?\n            // Copy sources with relevant files from the checkout:\n            lease.path.child(libraryPath).copyRecursiveTo(\"src/**/*.groovy,vars/*.groovy,vars/*.txt,resources/\", excludes, target);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          176,
          215
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/libs/LibraryAdderTest.java",
        "class_name": "LibraryAdderTest",
        "method_name": "smokes",
        "signature": "void smokes()",
        "lines_hint_csv": [
          70,
          86
        ],
        "code": "    @Test public void smokes() throws Exception {\n        sampleRepo.init();\n        String lib = \"package pkg; class Lib {static String CONST = 'constant'}\";\n        sampleRepo.write(\"src/pkg/Lib.groovy\", lib);\n        sampleRepo.git(\"add\", \"src\");\n        sampleRepo.git(\"commit\", \"--message=init\");\n        GlobalLibraries.get().setLibraries(Collections.singletonList(new LibraryConfiguration(\"stuff\", new SCMSourceRetriever(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", true)))));\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        String script = \"@Library('stuff@master') import static pkg.Lib.*; echo(/using ${CONST}/)\";\n        p.setDefinition(new CpsFlowDefinition(script, true));\n        r.assertLogContains(\"using constant\", r.buildAndAssertSuccess(p));\n        sampleRepo.git(\"tag\", \"1.0\");\n        sampleRepo.write(\"src/pkg/Lib.groovy\", lib.replace(\"constant\", \"modified\"));\n        sampleRepo.git(\"commit\", \"--all\", \"--message=modified\");\n        r.assertLogContains(\"using modified\", r.buildAndAssertSuccess(p));\n        p.setDefinition(new CpsFlowDefinition(script.replace(\"master\", \"1.0\"), true));\n        r.assertLogContains(\"using constant\", r.buildAndAssertSuccess(p));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          70,
          87
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/libs/LibraryStepTest.java",
        "class_name": "LibraryStepTest",
        "method_name": "classes",
        "signature": "void classes()",
        "lines_hint_csv": [
          111,
          122
        ],
        "code": "    @Test public void classes() throws Exception {\n        sampleRepo.init();\n        sampleRepo.write(\"src/some/pkg/Lib.groovy\", \"package some.pkg; class Lib {static class Inner {static String stuff() {Constants.CONST}}}\");\n        sampleRepo.write(\"src/some/pkg/Constants.groovy\", \"package some.pkg; class Constants {static String CONST = 'constant'}\");\n        sampleRepo.write(\"src/some/pkg/App.groovy\", \"package some.pkg; class App implements Serializable {def run() {Lib.Inner.stuff()}}\");\n        sampleRepo.git(\"add\", \"src\");\n        sampleRepo.git(\"commit\", \"--message=init\");\n        GlobalLibraries.get().setLibraries(Collections.singletonList(new LibraryConfiguration(\"stuff\", new SCMSourceRetriever(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", true)))));\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        p.setDefinition(new CpsFlowDefinition(\"def lib = library 'stuff@master'; echo(/using ${lib.some.pkg.Lib.Inner.stuff()} vs. ${lib.some.pkg.App.new().run()}/)\", true));\n        WorkflowRun b = r.buildAndAssertSuccess(p);\n        r.assertLogContains(\"using constant vs. constant\", b);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          111,
          123
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/libs/LibraryStepTest.java",
        "class_name": "LibraryStepTest",
        "method_name": "vars",
        "signature": "void vars()",
        "lines_hint_csv": [
          90,
          108
        ],
        "code": "    @Test public void vars() throws Exception {\n        sampleRepo.init();\n        sampleRepo.write(\"vars/x.groovy\", \"def call() {echo 'ran library'}\");\n        sampleRepo.git(\"add\", \"vars\");\n        sampleRepo.git(\"commit\", \"--message=init\");\n        GlobalLibraries.get().setLibraries(Collections.singletonList(new LibraryConfiguration(\"stuff\", new SCMSourceRetriever(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", true)))));\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        p.setDefinition(new CpsFlowDefinition(\"library 'stuff@master'; x()\", true));\n        WorkflowRun b = r.buildAndAssertSuccess(p);\n        r.assertLogContains(\"ran library\", b);\n        LibrariesAction action = b.getAction(LibrariesAction.class);\n        assertNotNull(action);\n        assertEquals(\"[LibraryRecord{name=stuff, version=master, variables=[x], trusted=true, changelog=true, cachingConfiguration=null}]\", action.getLibraries().toString());\n        p.setDefinition(new CpsFlowDefinition(\"library identifier: 'otherstuff@master', retriever: modernSCM([$class: 'GitSCMSource', remote: $/\" + sampleRepo + \"/$, credentialsId: '']), changelog: false; x()\", true));\n        b = r.buildAndAssertSuccess(p);\n        r.assertLogContains(\"ran library\", b);\n        action = b.getAction(LibrariesAction.class);\n        assertNotNull(action);\n        assertEquals(\"[LibraryRecord{name=otherstuff, version=master, variables=[x], trusted=false, changelog=false, cachingConfiguration=null}]\", action.getLibraries().toString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          90,
          109
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/libs/ResourceStepTest.java",
        "class_name": "ResourceStepTest",
        "method_name": "smokes",
        "signature": "void smokes()",
        "lines_hint_csv": [
          59,
          66
        ],
        "code": "    @Test public void smokes() throws Exception {\n        initFixedContentLibrary();\n        \n        GlobalLibraries.get().setLibraries(Collections.singletonList(\n            new LibraryConfiguration(\"stuff\", new SCMSourceRetriever(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", true)))));\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        p.setDefinition(new CpsFlowDefinition(\"@Library('stuff@master') import pkg.Stuff; echo(/got ${Stuff.contents(this)}/)\", true));\n        r.assertLogContains(\"got fixed contents\", r.buildAndAssertSuccess(p));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          59,
          67
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/libs/ResourceStepTest.java",
        "class_name": "ResourceStepTest",
        "method_name": "specifyResourceEncoding",
        "signature": "void specifyResourceEncoding()",
        "lines_hint_csv": [
          167,
          187
        ],
        "code": "    @Test public void specifyResourceEncoding() throws Exception {\n        assumeFalse(\"TODO mojibake on windows-11-2.164.1\", Functions.isWindows());\n        sampleRepo.init();\n        sampleRepo.write(\"src/pkg/Stuff.groovy\", \"package pkg; class Stuff {\" +\n                \"static def utf8(script) {script.libraryResource(resource: 'pkg/utf8', encoding: 'ISO-8859-15')}\\n\" +\n                \"static def binary(script) {script.libraryResource(resource: 'pkg/binary', encoding: 'Base64')}}\");\n        Path resourcesDir = Paths.get(sampleRepo.getRoot().getPath(), \"resources\", \"pkg\");\n        Files.createDirectories(resourcesDir);\n        // '' encoded using ISO-8859-1 should turn into '' when decoding using ISO-8859-15.\n        Files.write(resourcesDir.resolve(\"utf8\"), Arrays.asList(\"\"), StandardCharsets.ISO_8859_1);\n        byte[] binaryData = {0x48, 0x45, 0x4c, 0x4c, 0x4f, (byte) 0x80, (byte) 0xec, (byte) 0xf4, 0x00, 0x0d, 0x1b};\n        Files.write(resourcesDir.resolve(\"binary\"), binaryData);\n        sampleRepo.git(\"add\", \"src\", \"resources\");\n        sampleRepo.git(\"commit\", \"--message=init\");\n        GlobalLibraries.get().setLibraries(Collections.singletonList(\n            new LibraryConfiguration(\"stuff\", new SCMSourceRetriever(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", true)))));\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        p.setDefinition(new CpsFlowDefinition(\"@Library('stuff@master') import pkg.Stuff; echo(Stuff.utf8(this)); echo(Stuff.binary(this))\", true));\n        Run run = r.buildAndAssertSuccess(p);\n        r.assertLogContains(\"\", run);\n        r.assertLogContains(Base64.getEncoder().encodeToString(binaryData), run);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          167,
          188
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/libs/SCMSourceRetrieverTest.java",
        "class_name": "SCMSourceRetrieverTest",
        "method_name": "includeChanges",
        "signature": "void includeChanges()",
        "lines_hint_csv": [
          102,
          131
        ],
        "code": "    @Test public void includeChanges() throws Exception {\n        sampleRepo.init();\n        sampleRepo.write(\"vars/myecho.groovy\", \"def call() {echo 'something special'}\");\n        sampleRepo.git(\"add\", \"vars\");\n        sampleRepo.git(\"commit\", \"--message=init\");\n        GlobalLibraries.get().setLibraries(Collections.singletonList(\n            new LibraryConfiguration(\"include_changes\",\n                new SCMSourceRetriever(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", true)))));\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        p.setDefinition(new CpsFlowDefinition(\"@Library('include_changes@master') import myecho; myecho()\", true));\n        FilePath base = r.jenkins.getWorkspaceFor(p).withSuffix(\"@libs\").child(\"include_changes\");\n        try (WorkspaceList.Lease lease = r.jenkins.toComputer().getWorkspaceList().acquire(base)) {\n            WorkflowRun a = r.buildAndAssertSuccess(p);\n            r.assertLogContains(\"something special\", a);\n        }\n        sampleRepo.write(\"vars/myecho.groovy\", \"def call() {echo 'something even more special'}\");\n        sampleRepo.git(\"add\", \"vars\");\n        sampleRepo.git(\"commit\", \"--message=shared_library_commit\");\n        try (WorkspaceList.Lease lease = r.jenkins.toComputer().getWorkspaceList().acquire(base)) {\n            WorkflowRun b = r.buildAndAssertSuccess(p);\n            List<ChangeLogSet<? extends ChangeLogSet.Entry>> changeSets = b.getChangeSets();\n            assertEquals(1, changeSets.size());\n            ChangeLogSet<? extends ChangeLogSet.Entry> changeSet = changeSets.get(0);\n            assertEquals(b, changeSet.getRun());\n            assertEquals(\"git\", changeSet.getKind());\n            Iterator<? extends ChangeLogSet.Entry> iterator = changeSet.iterator();\n            ChangeLogSet.Entry entry = iterator.next();\n            assertEquals(\"shared_library_commit\", entry.getMsg() );\n            r.assertLogContains(\"something even more special\", b);\n            r.assertLogNotContains(\"Retrying after 10 seconds\", b);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          102,
          133
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/libs/SCMSourceRetrieverTest.java",
        "class_name": "SCMSourceRetrieverTest",
        "method_name": "lease",
        "signature": "void lease()",
        "lines_hint_csv": [
          81,
          97
        ],
        "code": "    @Test public void lease() throws Exception {\n        sampleRepo.init();\n        sampleRepo.write(\"vars/myecho.groovy\", \"def call() {echo 'something special'}\");\n        sampleRepo.git(\"add\", \"vars\");\n        sampleRepo.git(\"commit\", \"--message=init\");\n        GlobalLibraries.get().setLibraries(Collections.singletonList(\n            new LibraryConfiguration(\"echoing\",\n                new SCMSourceRetriever(new GitSCMSource(null, sampleRepo.toString(), \"\", \"*\", \"\", true)))));\n        WorkflowJob p = r.jenkins.createProject(WorkflowJob.class, \"p\");\n        p.setDefinition(new CpsFlowDefinition(\"@Library('echoing@master') import myecho; myecho()\", true));\n        FilePath base = r.jenkins.getWorkspaceFor(p).withSuffix(\"@libs\").child(\"echoing\");\n        try (WorkspaceList.Lease lease = r.jenkins.toComputer().getWorkspaceList().acquire(base)) {\n            WorkflowRun b = r.buildAndAssertSuccess(p);\n            r.assertLogContains(\"something special\", b);\n            r.assertLogNotContains(\"Retrying after 10 seconds\", b);\n            assertFalse(base.child(\"vars\").exists());\n            assertTrue(base.withSuffix(\"@2\").child(\"vars\").exists());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          81,
          99
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-25175",
    "project_slug": "jenkinsci__workflow-multibranch-plugin_CVE-2022-25175_706.vd43c65dec013",
    "buggy_commit_id": "d43c65dec013812b084fecbb4a310d856eb6b89a",
    "github_url": "https://github.com/jenkinsci/workflow-multibranch-plugin",
    "nvd_metadata": {
      "description": "Jenkins Pipeline: Multibranch Plugin 706.vd43c65dec013 and earlier uses the same checkout directories for distinct SCMs for the readTrusted step, allowing attackers with Item/Configure permission to invoke arbitrary OS commands on the controller through crafted SCM contents.",
      "published_date": "2022-02-15T17:15:08.627",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/multibranch/ReadTrustedStep.java",
        "class_name": "ReadTrustedStep",
        "method_name": "getPath",
        "signature": "String getPath()",
        "lines_hint_csv": [
          79,
          80
        ],
        "code": "    public String getPath() {\n        return path;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          79,
          81
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/multibranch/ReadTrustedStep.java",
        "class_name": "Execution",
        "method_name": "getFilePathSuffix",
        "signature": "String getFilePathSuffix()",
        "lines_hint_csv": [
          222,
          223
        ],
        "code": "        private String getFilePathSuffix() {\n            return System.getProperty(WorkspaceList.class.getName(), \"@\");\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          222,
          224
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/workflow/multibranch/ReadTrustedStep.java",
        "class_name": "Execution",
        "method_name": "run",
        "signature": "String run()",
        "lines_hint_csv": [
          90,
          215
        ],
        "code": "        @Override protected String run() throws Exception {\n            Job<?, ?> job = build.getParent();\n            // Portions adapted from SCMBinder, SCMVar, and CpsScmFlowDefinition:\n            SCM standaloneSCM = null;\n            BranchJobProperty property = job.getProperty(BranchJobProperty.class);\n            if (property == null) {\n                boolean ok = false;\n                if (job instanceof WorkflowJob) {\n                    FlowDefinition defn = ((WorkflowJob) job).getDefinition();\n                    if (defn instanceof CpsScmFlowDefinition) {\n                        // JENKINS-31386: retrofit to work with standalone projects, without doing any trust checks.\n                        standaloneSCM = ((CpsScmFlowDefinition) defn).getScm();\n                        try (SCMFileSystem fs = SCMBinder.USE_HEAVYWEIGHT_CHECKOUT ? null : SCMFileSystem.of(job, standaloneSCM)) {\n                            if (fs != null) { // JENKINS-33273\n                                try {\n                                    String text = fs.child(step.path).contentAsString();\n                                    listener.getLogger().println(\"Obtained \" + step.path + \" from \" + standaloneSCM.getKey());\n                                    return text;\n                                } catch (IOException | InterruptedException x) {\n                                    listener.error(\"Could not do lightweight checkout, falling back to heavyweight\").println(Functions.printThrowable(x).trim());\n                                }\n                            } else if (!SCMBinder.USE_HEAVYWEIGHT_CHECKOUT) {\n                                listener.getLogger().println(\"No lightweight checkout support in this SCM configuration\");\n                            }\n                        }\n                        ok = true;\n                    }\n                }\n                if (!ok) { // wrong definition or job type\n                    throw new AbortException(\"readTrusted is only available when using \" +\n                        Jenkins.get().getDescriptorByType(WorkflowMultiBranchProject.DescriptorImpl.class).getDisplayName() +\n                        \" or \" + Jenkins.get().getDescriptorByType(CpsScmFlowDefinition.DescriptorImpl.class).getDisplayName() + \"\");\n                }\n            }\n            Node node = Jenkins.get();\n            FilePath dir;\n            if (job instanceof TopLevelItem) {\n                FilePath baseWorkspace = node.getWorkspaceFor((TopLevelItem) job);\n                if (baseWorkspace == null) {\n                    throw new AbortException(node.getDisplayName() + \" may be offline\");\n                }\n                dir = getFilePathWithSuffix(baseWorkspace);\n            } else { // should not happen, but just in case:\n                throw new IllegalStateException(job + \" was not top level\");\n            }\n            FilePath file = dir.child(step.path);\n            if (!file.absolutize().getRemote().replace('\\\\', '/').startsWith(dir.absolutize().getRemote().replace('\\\\', '/') + '/')) { // TODO JENKINS-26838\n                throw new IOException(file + \" is not inside \" + dir);\n            }\n            Computer computer = node.toComputer();\n            if (computer == null) {\n                throw new IOException(node.getDisplayName() + \" may be offline\");\n            }\n            if (standaloneSCM != null) {\n                try (WorkspaceList.Lease lease = computer.getWorkspaceList().acquire(dir)) {\n                    SCMStep delegate = new GenericSCMStep(standaloneSCM);\n                    delegate.setPoll(true);\n                    delegate.setChangelog(true);\n                    delegate.checkout(build, dir, listener, node.createLauncher(listener));\n                    if (!file.exists()) {\n                        throw new AbortException(file + \" not found\");\n                    }\n                    return file.readToString();\n                }\n            }\n            Branch branch = property.getBranch();\n            ItemGroup<?> parent = job.getParent();\n            if (!(parent instanceof WorkflowMultiBranchProject)) {\n                throw new IllegalStateException(\"inappropriate context\");\n            }\n            SCMSource scmSource = ((WorkflowMultiBranchProject) parent).getSCMSource(branch.getSourceId());\n            if (scmSource == null) {\n                throw new IllegalStateException(branch.getSourceId() + \" not found\");\n            }\n            SCMHead head = branch.getHead();\n            SCMRevision tip;\n            SCMRevisionAction action = build.getAction(SCMRevisionAction.class);\n            if (action != null) {\n                tip = action.getRevision();\n            } else {\n                tip = scmSource.fetch(head, listener);\n                if (tip == null) {\n                    throw new AbortException(\"Could not determine exact tip revision of \" + branch.getName());\n                }\n                build.addAction(new SCMRevisionAction(scmSource, tip));\n            }\n            SCMRevision trusted = scmSource.getTrustedRevision(tip, listener);\n            boolean trustCheck = !tip.equals(trusted);\n            String untrustedFile = null;\n            String content;\n            try (SCMFileSystem tipFS = trustCheck && !SCMBinder.USE_HEAVYWEIGHT_CHECKOUT ? SCMFileSystem.of(scmSource, head, tip) : null;\n                 SCMFileSystem trustedFS = SCMBinder.USE_HEAVYWEIGHT_CHECKOUT ? null : SCMFileSystem.of(scmSource, head, trusted)) {\n                if (trustedFS != null && (!trustCheck || tipFS != null)) {\n                    if (trustCheck) {\n                        untrustedFile = tipFS.child(step.path).contentAsString();\n                    }\n                    content = trustedFS.child(step.path).contentAsString();\n                    listener.getLogger().println(\"Obtained \" + step.path + \" from \" + trusted);\n                } else {\n                    listener.getLogger().println(\"Checking out \" + head.getName() + \" to read \" + step.path);\n                    try (WorkspaceList.Lease lease = computer.getWorkspaceList().acquire(dir)) {\n                        if (trustCheck) {\n                            SCMStep delegate = new GenericSCMStep(scmSource.build(head, tip));\n                            delegate.setPoll(false);\n                            delegate.setChangelog(false);\n                            delegate.checkout(build, dir, listener, node.createLauncher(listener));\n                            if (!file.exists()) {\n                                throw new AbortException(file + \" not found\");\n                            }\n                            untrustedFile = file.readToString();\n                        }\n                        SCMStep delegate = new GenericSCMStep(scmSource.build(head, trusted));\n                        delegate.setPoll(true);\n                        delegate.setChangelog(true);\n                        delegate.checkout(build, dir, listener, node.createLauncher(listener));\n                        if (!file.exists()) {\n                            throw new AbortException(file + \" not found\");\n                        }\n                        content = file.readToString();\n                    }\n                }\n            }\n            if (trustCheck && !untrustedFile.equals(content)) {\n                throw new AbortException(Messages.ReadTrustedStep__has_been_modified_in_an_untrusted_revis(step.path));\n            }\n            return content;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          90,
          216
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/workflow/multibranch/ReadTrustedStepTest.java",
        "class_name": "ReadTrustedStepTest",
        "method_name": "smokes",
        "signature": "void smokes()",
        "lines_hint_csv": [
          49,
          89
        ],
        "code": "    @Test public void smokes() throws Exception {\n        sampleRepo.init();\n        sampleRepo.write(\"Jenkinsfile\", \"echo \\\"said ${readTrusted 'message'}\\\"\");\n        sampleRepo.write(\"message\", \"how do you do\");\n        sampleRepo.git(\"add\", \"Jenkinsfile\", \"message\");\n        sampleRepo.git(\"commit\", \"--all\", \"--message=defined\");\n        WorkflowMultiBranchProject mp = r.jenkins.createProject(WorkflowMultiBranchProject.class, \"p\");\n        mp.getSourcesList().add(new BranchSource(new SCMBinderTest.WarySource(null, sampleRepo.toString(), \"\", \"*\", \"\", false)));\n        WorkflowJob p = WorkflowMultiBranchProjectTest.scheduleAndFindBranchProject(mp, \"master\");\n        r.waitUntilNoActivity();\n        WorkflowRun b = p.getLastBuild();\n        assertNotNull(b);\n        assertEquals(1, b.getNumber());\n        SCMBinderTest.assertRevisionAction(b);\n        r.assertBuildStatusSuccess(b);\n        r.assertLogContains(\"said how do you do\", b);\n        r.assertLogContains(\"Obtained message from \", b);\n        String branch = \"evil\";\n        sampleRepo.git(\"checkout\", \"-b\", branch);\n        sampleRepo.write(\"message\", \"your father smelt of elderberries\");\n        sampleRepo.git(\"commit\", \"--all\", \"--message=rude\");\n        p = WorkflowMultiBranchProjectTest.scheduleAndFindBranchProject(mp, branch);\n        r.waitUntilNoActivity();\n        b = p.getLastBuild();\n        assertNotNull(b);\n        assertEquals(1, b.getNumber());\n        SCMBinderTest.assertRevisionAction(b);\n        r.assertBuildStatus(Result.FAILURE, b);\n        r.assertLogContains(Messages.ReadTrustedStep__has_been_modified_in_an_untrusted_revis(\"message\"), b);\n        r.assertLogContains(\"Obtained message from \", b);\n        sampleRepo.write(\"message\", \"how do you do\");\n        sampleRepo.write(\"ignored-message\", \"I fart in your general direction\");\n        sampleRepo.git(\"add\", \"ignored-message\");\n        sampleRepo.git(\"commit\", \"--all\", \"--message=less rude\");\n        sampleRepo.notifyCommit(r);\n        b = p.getLastBuild();\n        assertEquals(2, b.getNumber());\n        SCMBinderTest.assertRevisionAction(b);\n        r.assertBuildStatusSuccess(b);\n        r.assertLogContains(\"said how do you do\", b);\n        r.assertLogContains(\"Obtained message from \", b);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          49,
          90
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2014-3576",
    "project_slug": "apache__activemq_CVE-2014-3576_5.10.1",
    "buggy_commit_id": "8938d14d434447193b02ba635606aa0fb7a80353",
    "github_url": "https://github.com/apache/activemq",
    "nvd_metadata": {
      "description": "The processControlCommand function in broker/TransportConnection.java in Apache ActiveMQ before 5.11.0 allows remote attackers to cause a denial of service (shutdown) via a shutdown command.",
      "published_date": "2015-08-14T18:59:00.097",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "activemq-broker/src/main/java/org/apache/activemq/broker/TransportConnection.java",
        "class_name": "TransportConnection",
        "method_name": "processControlCommand",
        "signature": "Response processControlCommand(ControlCommand)",
        "lines_hint_csv": [
          1536,
          1538
        ],
        "code": "    public Response processControlCommand(ControlCommand command) throws Exception {\n        String control = command.getCommand();\n        if (control != null && control.equals(\"shutdown\")) {\n            System.exit(0);\n        }\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1536,
          1542
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2017-1000487",
    "project_slug": "codehaus-plexus__plexus-utils_CVE-2017-1000487_3.0.15",
    "buggy_commit_id": "3b271b43f9e5021b4232fc2ffdfb4e469c7f8685",
    "github_url": "https://github.com/codehaus-plexus/plexus-utils",
    "nvd_metadata": {
      "description": "Plexus-utils before 3.0.16 is vulnerable to command injection because it does not correctly process the contents of double quoted strings.",
      "published_date": "2018-01-03T20:29:00.703",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Marker",
        "method_name": "getPosition",
        "signature": "int getPosition()",
        "lines_hint_csv": [
          252,
          263
        ],
        "code": "        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( getExecutable() == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Arg arg = (Arg) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          252,
          264
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Commandline",
        "method_name": "getShellCommandline",
        "signature": "String getShellCommandline()",
        "lines_hint_csv": [
          501,
          506
        ],
        "code": "    public String[] getShellCommandline()\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        return (String[]) getShell().getShellCommandLine( getArguments() ).toArray( new String[0] );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          501,
          507
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Commandline",
        "method_name": "getArguments",
        "signature": "String getArguments()",
        "lines_hint_csv": [
          513,
          531
        ],
        "code": "    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          513,
          532
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Commandline",
        "method_name": "execute",
        "signature": "Process execute()",
        "lines_hint_csv": [
          618,
          659
        ],
        "code": "    public Process execute()\n        throws CommandLineException\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        Process process;\n\n        //addEnvironment( \"MAVEN_TEST_ENVAR\", \"MAVEN_TEST_ENVAR_VALUE\" );\n\n        String[] environment = getEnvironmentVariables();\n\n        File workingDir = shell.getWorkingDirectory();\n\n        try\n        {\n            if ( workingDir == null )\n            {\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment );\n            }\n            else\n            {\n                if ( !workingDir.exists() )\n                {\n                    throw new CommandLineException( \"Working directory \\\"\" + workingDir.getPath()\n                        + \"\\\" does not exist!\" );\n                }\n                else if ( !workingDir.isDirectory() )\n                {\n                    throw new CommandLineException( \"Path \\\"\" + workingDir.getPath()\n                        + \"\\\" does not specify a directory.\" );\n                }\n\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment, workingDir );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new CommandLineException( \"Error while executing process.\", ex );\n        }\n\n        return process;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          618,
          660
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Commandline",
        "method_name": "Commandline",
        "signature": "Commandline(String,Shell)",
        "lines_hint_csv": [
          144,
          162
        ],
        "code": "    public Commandline( String toProcess, Shell shell )\n    {\n        this.shell = shell;\n\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          144,
          165
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Commandline",
        "method_name": "Commandline",
        "signature": "Commandline(String)",
        "lines_hint_csv": [
          182,
          199
        ],
        "code": "    public Commandline( String toProcess )\n    {\n        setDefaultShell();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          182,
          202
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Commandline",
        "method_name": "verifyShellState",
        "signature": "void verifyShellState()",
        "lines_hint_csv": [
          665,
          674
        ],
        "code": "    private void verifyShellState()\n    {\n        if ( shell.getWorkingDirectory() == null )\n        {\n            shell.setWorkingDirectory( workingDir );\n        }\n\n        if ( shell.getExecutable() == null )\n        {\n            shell.setExecutable( executable );\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          665,
          676
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
        "class_name": "Commandline",
        "method_name": "translateCommandline",
        "signature": "String translateCommandline(String)",
        "lines_hint_csv": [
          708,
          711
        ],
        "code": "    public static String[] translateCommandline( String toProcess )\n        throws Exception\n    {\n        return CommandLineUtils.translateCommandline( toProcess );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          708,
          712
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java",
        "class_name": "BourneShell",
        "method_name": "BourneShell",
        "signature": "BourneShell(boolean)",
        "lines_hint_csv": [
          55,
          67
        ],
        "code": "    public BourneShell( boolean isLoginShell )\n    {\n        setShellCommand( \"/bin/sh\" );\n        setArgumentQuoteDelimiter( '\\'' );\n        setExecutableQuoteDelimiter( '\\\"' );\n        setSingleQuotedArgumentEscaped( true );\n        setSingleQuotedExecutableEscaped( false );\n        setQuotedExecutableEnabled( true );\n        setArgumentEscapePattern(\"'\\\\%s'\");\n\n        if ( isLoginShell )\n        {\n            addShellArg( \"-l\" );\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          55,
          69
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java",
        "class_name": "BourneShell",
        "method_name": "getShellArgs",
        "signature": "String getShellArgs()",
        "lines_hint_csv": [
          97,
          115
        ],
        "code": "    public String[] getShellArgs()\n    {\n        String[] shellArgs = super.getShellArgs();\n        if ( shellArgs == null )\n        {\n            shellArgs = new String[0];\n        }\n\n        if ( ( shellArgs.length > 0 ) && !shellArgs[shellArgs.length - 1].equals( \"-c\" ) )\n        {\n            String[] newArgs = new String[shellArgs.length + 1];\n\n            System.arraycopy( shellArgs, 0, newArgs, 0, shellArgs.length );\n            newArgs[shellArgs.length] = \"-c\";\n\n            shellArgs = newArgs;\n        }\n\n        return shellArgs;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          97,
          116
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/Shell.java",
        "class_name": "Shell",
        "method_name": "setQuotedArgumentsEnabled",
        "signature": "void setQuotedArgumentsEnabled(boolean)",
        "lines_hint_csv": [
          297,
          299
        ],
        "code": "    public void setQuotedArgumentsEnabled( boolean quotedArgumentsEnabled )\n    {\n        this.quotedArgumentsEnabled = quotedArgumentsEnabled;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          297,
          300
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/Shell.java",
        "class_name": "Shell",
        "method_name": "getExecutionPreamble",
        "signature": "String getExecutionPreamble()",
        "lines_hint_csv": [
          185,
          187
        ],
        "code": "    protected String getExecutionPreamble()\n    {\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          185,
          188
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/Shell.java",
        "class_name": "Shell",
        "method_name": "getRawCommandLine",
        "signature": "List getRawCommandLine(String,String)",
        "lines_hint_csv": [
          132,
          177
        ],
        "code": "    protected List<String> getRawCommandLine( String executable, String[] arguments )\n    {\n        List<String> commandLine = new ArrayList<String>();\n        StringBuilder sb = new StringBuilder();\n\n        if ( executable != null )\n        {\n            String preamble = getExecutionPreamble();\n            if ( preamble != null )\n            {\n                sb.append( preamble );\n            }\n\n            if ( isQuotedExecutableEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedExecutableEscaped(), isDoubleQuotedExecutableEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( getExecutable(), getExecutableQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), '\\\\', false ) );\n            }\n            else\n            {\n                sb.append( getExecutable() );\n            }\n        }\n        for ( int i = 0; i < arguments.length; i++ )\n        {\n            if ( sb.length() > 0 )\n            {\n                sb.append( \" \" );\n            }\n\n            if ( isQuotedArgumentsEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedArgumentEscaped(), isDoubleQuotedArgumentEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( arguments[i], getArgumentQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), getArgumentEscapePattern(), false ) );\n            }\n            else\n            {\n                sb.append( arguments[i] );\n            }\n        }\n\n        commandLine.add( sb.toString() );\n\n        return commandLine;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          132,
          178
        ]
      },
      {
        "file_path": "src/main/java/org/codehaus/plexus/util/cli/shell/Shell.java",
        "class_name": "Shell",
        "method_name": "getEscapeChars",
        "signature": "char getEscapeChars(boolean,boolean)",
        "lines_hint_csv": [
          190,
          206
        ],
        "code": "    protected char[] getEscapeChars( boolean includeSingleQuote, boolean includeDoubleQuote )\n    {\n        StringBuilder buf = new StringBuilder( 2 );\n        if ( includeSingleQuote )\n        {\n            buf.append( '\\'' );\n        }\n\n        if ( includeDoubleQuote )\n        {\n            buf.append( '\\\"' );\n        }\n\n        char[] result = new char[buf.length()];\n        buf.getChars( 0, buf.length(), result, 0 );\n\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          190,
          207
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java",
        "class_name": "CommandlineTest",
        "method_name": "testGetShellCommandLineNonWindows",
        "signature": "void testGetShellCommandLineNonWindows()",
        "lines_hint_csv": [
          322,
          344
        ],
        "code": "    public void testGetShellCommandLineNonWindows()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/usr/bin\" );\n        cmd.addArguments( new String[] {\n            \"a\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertEquals( \"\\\\usr\\\\bin a b\", shellCommandline[2] );\n        }\n        else\n        {\n            assertEquals( \"/usr/bin a b\", shellCommandline[2] );\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          322,
          346
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java",
        "class_name": "CommandlineTest",
        "method_name": "testQuotedPathWithSingleApostrophe",
        "signature": "void testQuotedPathWithSingleApostrophe()",
        "lines_hint_csv": [
          380,
          387
        ],
        "code": "    public void testQuotedPathWithSingleApostrophe()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          380,
          388
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java",
        "class_name": "CommandlineTest",
        "method_name": "testGetShellCommandLineBash_WithSingleQuotedArg",
        "signature": "void testGetShellCommandLineBash_WithSingleQuotedArg()",
        "lines_hint_csv": [
          299,
          319
        ],
        "code": "    public void testGetShellCommandLineBash_WithSingleQuotedArg()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"\\'hello world\\'\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"/bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          299,
          320
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java",
        "class_name": "CommandlineTest",
        "method_name": "testQuotedPathWithQuotationMark",
        "signature": "void testQuotedPathWithQuotationMark()",
        "lines_hint_csv": [
          395,
          408
        ],
        "code": "    public void testQuotedPathWithQuotationMark()\n        throws Exception\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            System.out.println( \"testQuotedPathWithQuotationMark() skipped on Windows\" );\n            return;\n        }\n\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          395,
          409
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java",
        "class_name": "CommandlineTest",
        "method_name": "testGetShellCommandLineBash_WithWorkingDirectory",
        "signature": "void testGetShellCommandLineBash_WithWorkingDirectory()",
        "lines_hint_csv": [
          267,
          292
        ],
        "code": "    public void testGetShellCommandLineBash_WithWorkingDirectory()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n        File root = File.listRoots()[0];\n        File workingDirectory = new File( root, \"path with spaces\" );\n        cmd.setWorkingDirectory( workingDirectory );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"cd \\\"\" + root.getAbsolutePath()\n                                  + \"path with spaces\\\" && /bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"cd \\\"\" + root.getAbsolutePath()\n                               + \"path with spaces\\\" && \\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          267,
          293
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java",
        "class_name": "CommandlineTest",
        "method_name": "testGetShellCommandLineBash",
        "signature": "void testGetShellCommandLineBash()",
        "lines_hint_csv": [
          240,
          260
        ],
        "code": "    public void testGetShellCommandLineBash()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"/bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          240,
          261
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
        "class_name": "BourneShellTest",
        "method_name": "testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes_BackslashFileSep",
        "signature": "void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes_BackslashFileSep()",
        "lines_hint_csv": [
          60,
          69
        ],
        "code": "    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes_BackslashFileSep()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"\\\\usr\\\\local\\\\'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd \\\"\\\\usr\\\\local\\\\\\'something else\\'\\\" && chmod\", executable );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          60,
          70
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
        "class_name": "BourneShellTest",
        "method_name": "testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes",
        "signature": "void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes()",
        "lines_hint_csv": [
          48,
          57
        ],
        "code": "    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd \\\"/usr/local/\\'something else\\'\\\" && chmod\", executable );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          48,
          58
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
        "class_name": "BourneShellTest",
        "method_name": "testBourneShellQuotingCharacters",
        "signature": "void testBourneShellQuotingCharacters()",
        "lines_hint_csv": [
          176,
          210
        ],
        "code": "    public void testBourneShellQuotingCharacters()\n        throws Exception\n    {\n        // { ' ', '$', ';', '&', '|', '<', '>', '*', '?', '(', ')' };\n        // test with values http://steve-parker.org/sh/bourne.shtml Appendix B - Meta-characters and Reserved Words\n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \" \" );\n        commandline.createArg().setValue( \"|\" );\n        commandline.createArg().setValue( \"&&\" );\n        commandline.createArg().setValue( \"||\" );\n        commandline.createArg().setValue( \";\" );\n        commandline.createArg().setValue( \";;\" );\n        commandline.createArg().setValue( \"&\" );\n        commandline.createArg().setValue( \"()\" );\n        commandline.createArg().setValue( \"<\" );\n        commandline.createArg().setValue( \"<<\" );\n        commandline.createArg().setValue( \">\" );\n        commandline.createArg().setValue( \">>\" );\n        commandline.createArg().setValue( \"*\" );\n        commandline.createArg().setValue( \"?\" );\n        commandline.createArg().setValue( \"[\" );\n        commandline.createArg().setValue( \"]\" );\n        commandline.createArg().setValue( \"{\" );\n        commandline.createArg().setValue( \"}\" );\n        commandline.createArg().setValue( \"`\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod ' ' '|' '&&' '||' ';' ';;' '&' '()' '<' '<<' '>' '>>' '*' '?' '[' ']' '{' '}' '`'\",\n                      lines[2] );\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          176,
          212
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
        "class_name": "BourneShellTest",
        "method_name": "testArgumentsWithsemicolon",
        "signature": "void testArgumentsWithsemicolon()",
        "lines_hint_csv": [
          120,
          173
        ],
        "code": "    public void testArgumentsWithsemicolon()\n    {\n\n        System.out.println( \"---- semi colon tests ----\" );\n\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \";some&argwithunix$chars\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( \"\\'\" + args[0] + \"\\'\" ) );\n\n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod --password ';password'\", lines[2] );\n\n        commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod --password ';password'\", lines[2] );\n\n        commandline = new Commandline( new CmdShell() );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"cmd.exe\", lines[0] );\n        assertEquals( \"/X\", lines[1] );\n        assertEquals( \"/C\", lines[2] );\n        assertEquals( \"\\\"--password ;password\\\"\", lines[3] );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          120,
          174
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
        "class_name": "BourneShellTest",
        "method_name": "testEscapeSingleQuotesOnArgument",
        "signature": "void testEscapeSingleQuotesOnArgument()",
        "lines_hint_csv": [
          104,
          117
        ],
        "code": "    public void testEscapeSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"arg'withquote\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertEquals(\"cd /usr/bin && chmod 'arg'\\\\''withquote'\", shellCommandLine.get(shellCommandLine.size() - 1));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          104,
          118
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
        "class_name": "BourneShellTest",
        "method_name": "testPreserveSingleQuotesOnArgument",
        "signature": "void testPreserveSingleQuotesOnArgument()",
        "lines_hint_csv": [
          72,
          85
        ],
        "code": "    public void testPreserveSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"\\'some arg with spaces\\'\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( args[0] ) );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          72,
          86
        ]
      },
      {
        "file_path": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
        "class_name": "BourneShellTest",
        "method_name": "testQuoteWorkingDirectoryAndExecutable",
        "signature": "void testQuoteWorkingDirectoryAndExecutable()",
        "lines_hint_csv": [
          36,
          45
        ],
        "code": "    public void testQuoteWorkingDirectoryAndExecutable()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd /usr/local/bin && chmod\", executable );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          36,
          46
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-10392",
    "project_slug": "jenkinsci__git-client-plugin_CVE-2019-10392_2.8.4",
    "buggy_commit_id": "72add81da4cbeabc95504ebdb9007d47ac1c2b0b",
    "github_url": "https://github.com/jenkinsci/git-client-plugin",
    "nvd_metadata": {
      "description": "Jenkins Git Client Plugin 2.8.4 and earlier and 3.0.0-rc did not properly restrict values passed as URL argument to an invocation of 'git ls-remote', resulting in OS command injection.",
      "published_date": "2019-09-12T14:15:11.257",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/gitclient/CliGitAPIImpl.java",
        "class_name": "CliGitAPIImpl",
        "method_name": "getSubmodules",
        "signature": "List getSubmodules(String)",
        "lines_hint_csv": [
          360,
          369
        ],
        "code": "    public List<IndexEntry> getSubmodules( String treeIsh ) throws GitException, InterruptedException {\n        List<IndexEntry> submodules = lsTree(treeIsh,true);\n\n        // Remove anything that isn't a submodule\n        for (Iterator<IndexEntry> it = submodules.iterator(); it.hasNext();) {\n            if (!it.next().getMode().equals(\"160000\")) {\n                it.remove();\n            }\n        }\n        return submodules;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          361,
          371
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/gitclient/CliGitAPIImpl.java",
        "class_name": "CliGitAPIImpl",
        "method_name": "fetch_",
        "signature": "FetchCommand fetch_(URIish,List,boolean,boolean,boolean,Integer,Integer)",
        "lines_hint_csv": [
          377,
          471
        ],
        "code": "    public FetchCommand fetch_() {\n        return new FetchCommand() {\n            public URIish url;\n            public List<RefSpec> refspecs;\n            public boolean prune;\n            public boolean shallow;\n            public Integer timeout;\n            public boolean tags = true;\n            public Integer depth = 1;\n\n            public FetchCommand from(URIish remote, List<RefSpec> refspecs) {\n                this.url = remote;\n                this.refspecs = refspecs;\n                return this;\n            }\n\n            public FetchCommand tags(boolean tags) {\n                this.tags = tags;\n                return this;\n            }\n\n            public FetchCommand prune() {\n                return prune(true);\n            }\n\n            public FetchCommand prune(boolean prune) {\n                this.prune = prune;\n                return this;\n            }\n\n            public FetchCommand shallow(boolean shallow) {\n                this.shallow = shallow;\n                return this;\n            }\n\n            public FetchCommand timeout(Integer timeout) {\n            \tthis.timeout = timeout;\n            \treturn this;\n            }\n\n            public FetchCommand depth(Integer depth) {\n                this.depth = depth;\n                return this;\n            }\n\n            public void execute() throws GitException, InterruptedException {\n                listener.getLogger().println(\n                        \"Fetching upstream changes from \" + url);\n\n                ArgumentListBuilder args = new ArgumentListBuilder();\n                args.add(\"fetch\");\n                args.add(tags ? \"--tags\" : \"--no-tags\");\n                if (USE_FORCE_FETCH && isAtLeastVersion(2, 20, 0, 0)) {\n                    /* CLI git 2.20.0 fixed a long-standing bug that now requires --force to update existing tags */\n                    args.add(\"--force\");\n                }\n                if (isAtLeastVersion(1,7,1,0))\n                    args.add(\"--progress\");\n\n                StandardCredentials cred = credentials.get(url.toPrivateString());\n                if (cred == null) cred = defaultCredentials;\n                args.add(url);\n\n                if (refspecs != null)\n                    for (RefSpec rs: refspecs)\n                        if (rs != null)\n                            args.add(rs.toString());\n\n                if (prune) args.add(\"--prune\");\n\n                if (shallow) {\n                    if (depth == null){\n                        depth = 1;\n                    }\n                    args.add(\"--depth=\" + depth);\n                }\n\n                warnIfWindowsTemporaryDirNameHasSpaces();\n\n                /* If url looks like a remote name reference, convert to remote URL for authentication */\n                /* See JENKINS-50573 for more details */\n                /* \"git remote add\" rejects remote names with ':' (and it is a common character in remote URLs) */\n                /* \"git remote add\" allows remote names with '@' but internal git parsing problems seem likely (and it is a common character in remote URLs) */\n                /* \"git remote add\" allows remote names with '/' but git client plugin parsing problems will occur (and it is a common character in remote URLs) */\n                /* \"git remote add\" allows remote names with '\\' but git client plugin parsing problems will occur */\n                URIish remoteUrl = url;\n                if (!url.isRemote() && !StringUtils.containsAny(url.toString(), \":@/\\\\\")) {\n                    try {\n                        remoteUrl = new URIish(getRemoteUrl(url.toString()));\n                    } catch (URISyntaxException e) {\n                        listener.getLogger().println(\"Unexpected remote name or URL: '\" + url + \"'\");\n                    }\n                }\n\n                launchCommandWithCredentials(args, workspace, cred, remoteUrl, timeout);\n            }\n        };\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          378,
          475
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/gitclient/CliGitAPIImpl.java",
        "class_name": "CliGitAPIImpl",
        "method_name": "getRemoteReferences",
        "signature": "Map getRemoteReferences(String,String,boolean,boolean)",
        "lines_hint_csv": [
          2916,
          2955
        ],
        "code": "    public Map<String, ObjectId> getRemoteReferences(String url, String pattern, boolean headsOnly, boolean tagsOnly)\n            throws GitException, InterruptedException {\n        ArgumentListBuilder args = new ArgumentListBuilder(\"ls-remote\");\n        if (headsOnly) {\n            args.add(\"-h\");\n        }\n        if (tagsOnly) {\n            args.add(\"-t\");\n        }\n        args.add(url);\n        if (pattern != null) {\n            args.add(pattern);\n        }\n\n        StandardCredentials cred = credentials.get(url);\n        if (cred == null) cred = defaultCredentials;\n\n        String result = launchCommandWithCredentials(args, null, cred, url);\n\n        Map<String, ObjectId> references = new HashMap<>();\n        String[] lines = result.split(\"\\n\");\n        for (String line : lines) {\n            if (line.length() < 41) {\n                continue; // throw new GitException(\"unexpected ls-remote output \" + line);\n            }\n            String refName = line.substring(41);\n            ObjectId refObjectId = ObjectId.fromString(line.substring(0, 40));\n            if (refName.startsWith(\"refs/tags\") && refName.endsWith(\"^{}\")) {\n                // get peeled object id for annotated tag\n                String tagName = refName.replace(\"^{}\", \"\");\n                // Replace with the peeled object id if the entry with tagName exists\n                references.put(tagName, refObjectId);\n            } else {\n                if (!references.containsKey(refName)) {\n                    references.put(refName, refObjectId);\n                }\n            }\n\n        }\n        return references;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2917,
          2957
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/gitclient/CliGitAPIImpl.java",
        "class_name": "CliGitAPIImpl",
        "method_name": "getBranchesContaining",
        "signature": "List getBranchesContaining(String)",
        "lines_hint_csv": [
          3029,
          3032
        ],
        "code": "    public List<Branch> getBranchesContaining(String revspec) throws GitException,\n            InterruptedException {\n        // For backward compatibility we do query remote branches here\n        return getBranchesContaining(revspec, true);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          3030,
          3034
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/gitclient/CliGitAPIImpl.java",
        "class_name": "CliGitAPIImpl",
        "method_name": "clone_",
        "signature": "CloneCommand clone_(String,String,boolean,boolean,boolean,String,Integer,Integer,List)",
        "lines_hint_csv": [
          541,
          687
        ],
        "code": "    public CloneCommand clone_() {\n        return new CloneCommand() {\n            String url;\n            String origin = \"origin\";\n            String reference;\n            boolean shallow,shared;\n            Integer timeout;\n            boolean tags = true;\n            List<RefSpec> refspecs;\n            Integer depth = 1;\n\n            public CloneCommand url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public CloneCommand repositoryName(String name) {\n                this.origin = name;\n                return this;\n            }\n\n            public CloneCommand shared() {\n                return shared(true);\n            }\n\n            @Override\n            public CloneCommand shared(boolean shared) {\n                this.shared = shared;\n                return this;\n            }\n\n            public CloneCommand shallow() {\n                return shallow(true);\n            }\n\n            @Override\n            public CloneCommand shallow(boolean shallow) {\n                this.shallow = shallow;\n                return this;\n            }\n\n            public CloneCommand noCheckout() {\n                //this.noCheckout = true; Since the \"clone\" command has been replaced with init + fetch, the --no-checkout option is always satisfied\n                return this;\n            }\n\n            public CloneCommand tags(boolean tags) {\n                this.tags = tags;\n                return this;\n            }\n\n            public CloneCommand reference(String reference) {\n                this.reference = reference;\n                return this;\n            }\n\n            public CloneCommand timeout(Integer timeout) {\n            \tthis.timeout = timeout;\n            \treturn this;\n            }\n\n            public CloneCommand depth(Integer depth) {\n                this.depth = depth;\n                return this;\n            }\n\n            public CloneCommand refspecs(List<RefSpec> refspecs) {\n                this.refspecs = new ArrayList<>(refspecs);\n                return this;\n            }\n\n            public void execute() throws GitException, InterruptedException {\n\n                URIish urIish = null;\n                try {\n                    urIish = new URIish(url);\n                } catch (URISyntaxException e) {\n                    listener.getLogger().println(\"Invalid repository \" + url);\n                    throw new IllegalArgumentException(\"Invalid repository \" + url, e);\n                }\n\n                listener.getLogger().println(\"Cloning repository \" + url);\n\n                try {\n                    Util.deleteContentsRecursive(workspace);\n                } catch (Exception e) {\n                    e.printStackTrace(listener.error(\"Failed to clean the workspace\"));\n                    throw new GitException(\"Failed to delete workspace\", e);\n                }\n\n                // we don't run a 'git clone' command but git init + git fetch\n                // this allows launchCommandWithCredentials() to pass credentials via a local gitconfig\n\n                init_().workspace(workspace.getAbsolutePath()).execute();\n\n                if (shared) {\n                    if (reference == null || reference.isEmpty()) {\n                        // we use origin as reference\n                        reference = url;\n                    } else {\n                        listener.getLogger().println(\"[WARNING] Both shared and reference is used, shared is ignored.\");\n                    }\n                }\n\n                if (reference != null && !reference.isEmpty()) {\n                    File referencePath = new File(reference);\n                    if (!referencePath.exists())\n                        listener.error(\"Reference path does not exist: \" + reference);\n                    else if (!referencePath.isDirectory())\n                        listener.error(\"Reference path is not a directory: \" + reference);\n                    else {\n                        // reference path can either be a normal or a base repository\n                        File objectsPath = new File(referencePath, \".git/objects\");\n                        if (!objectsPath.isDirectory()) {\n                            // reference path is bare repo\n                            objectsPath = new File(referencePath, \"objects\");\n                        }\n                        if (!objectsPath.isDirectory())\n                            listener.error(\"Reference path does not contain an objects directory (no git repo?): \" + objectsPath);\n                        else {\n                            File alternates = new File(workspace, \".git/objects/info/alternates\");\n                            try (PrintWriter w = new PrintWriter(alternates, Charset.defaultCharset().toString())) {\n                                String absoluteReference = objectsPath.getAbsolutePath().replace('\\\\', '/');\n                                listener.getLogger().println(\"Using reference repository: \" + reference);\n                                // git implementations on windows also use\n                                w.print(absoluteReference);\n                            } catch (UnsupportedEncodingException ex) {\n                                listener.error(\"Default character set is an unsupported encoding\");\n                            } catch (FileNotFoundException e) {\n                                listener.error(\"Failed to setup reference\");\n                            }\n                        }\n                    }\n                }\n\n                if (refspecs == null) {\n                    refspecs = Collections.singletonList(new RefSpec(\"+refs/heads/*:refs/remotes/\"+origin+\"/*\"));\n                }\n                fetch_().from(urIish, refspecs)\n                        .shallow(shallow)\n                        .depth(depth)\n                        .timeout(timeout)\n                        .tags(tags)\n                        .execute();\n                setRemoteUrl(origin, url);\n                for (RefSpec refSpec : refspecs) {\n                    launchCommand(\"config\", \"--add\", \"remote.\" + origin + \".fetch\", refSpec.toString());\n                }\n            }\n\n        };\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          542,
          693
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/gitclient/CliGitAPIImpl.java",
        "class_name": "CliGitAPIImpl",
        "method_name": "getRemoteSymbolicReferences",
        "signature": "Map getRemoteSymbolicReferences(String,String)",
        "lines_hint_csv": [
          2959,
          2986
        ],
        "code": "    public Map<String, String> getRemoteSymbolicReferences(String url, String pattern)\n            throws GitException, InterruptedException {\n        Map<String, String> references = new HashMap<>();\n        if (isAtLeastVersion(2, 8, 0, 0)) {\n            // --symref is only understood by ls-remote starting from git 2.8.0\n            // https://github.com/git/git/blob/afd6726309/Documentation/RelNotes/2.8.0.txt#L72-L73\n            ArgumentListBuilder args = new ArgumentListBuilder(\"ls-remote\");\n            args.add(\"--symref\");\n            args.add(url);\n            if (pattern != null) {\n                args.add(pattern);\n            }\n\n            StandardCredentials cred = credentials.get(url);\n            if (cred == null) cred = defaultCredentials;\n\n            String result = launchCommandWithCredentials(args, null, cred, url);\n\n            String[] lines = result.split(\"\\n\");\n            Pattern symRefPattern = Pattern.compile(\"^ref:\\\\s+([^ ]+)\\\\s+([^ ]+)$\");\n            for (String line : lines) {\n                Matcher matcher = symRefPattern.matcher(line);\n                if (matcher.matches()) {\n                    references.put(matcher.group(2), matcher.group(1));\n                }\n            }\n        }\n        return references;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2960,
          2988
        ]
      },
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/gitclient/CliGitAPIImpl.java",
        "class_name": "CliGitAPIImpl",
        "method_name": "refExists",
        "signature": "boolean refExists(String)",
        "lines_hint_csv": [
          2830,
          2836
        ],
        "code": "    public boolean refExists(String refName) throws GitException, InterruptedException {\n\trefName = refName.replace(' ', '_');\n\ttry {\n\t    launchCommand(\"show-ref\", refName);\n\t    return true; // If show-ref returned zero, ref exists.\n\t} catch (GitException e) {\n\t    return false; // If show-ref returned non-zero, ref doesn't exist.\n\t}\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2831,
          2839
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-2261",
    "project_slug": "jenkinsci__perfecto-plugin_CVE-2020-2261_1.17",
    "buggy_commit_id": "adabcd9da98628e063bb91198e30ff39a34dc921",
    "github_url": "https://github.com/jenkinsci/perfecto-plugin",
    "nvd_metadata": {
      "description": "Jenkins Perfecto Plugin 1.17 and earlier executes a command on the Jenkins controller, allowing attackers with Job/Configure permission to run arbitrary commands on the Jenkins controller",
      "published_date": "2020-09-16T14:15:13.640",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/io/plugins/perfecto/PerfectoBuildWrapper.java",
        "class_name": "PerfectoBuildWrapper",
        "method_name": "getTunnelId",
        "signature": "String getTunnelId(String,String,String,BuildListener)",
        "lines_hint_csv": [
          151,
          193
        ],
        "code": "\tprivate String getTunnelId(String perfectoConnectLocation, String cloudName, String apiKey, BuildListener listener) throws IOException {\n\t\tString tunnelId = null;\n\t\tboolean isWindows = hudson.Functions.isWindows();\n\t\tProcess process;\n\t\tif(perfectoConnectLocation.endsWith(\"/\")||perfectoConnectLocation.endsWith(\"\\\\\")) {\n\t\t\tpcLocation = perfectoConnectLocation+perfectoConnectFile;\n\t\t}else {\n\t\t\tpcLocation = perfectoConnectLocation+File.separator+perfectoConnectFile;\n\t\t}\n\t\tString baseCommand = pcLocation.trim()+\" start -c \"+cloudName.trim()+\".perfectomobile.com -s \"+apiKey.trim();\n\t\tlistener.getLogger().println(pcLocation.trim()+\" start -c \"+cloudName.trim()+\".perfectomobile.com -s <<TOKEN>> \"+pcParameters.trim());\n\t\tif (isWindows) {\n\t\t\tString cmdArgs[] = {\"cmd.exe\", \"/c\", baseCommand+\" \"+pcParameters.trim()};\n\t\t\tprocess = new ProcessBuilder(cmdArgs).redirectErrorStream(true).start();\n\t\t} else {\n\t\t\tString cmdArgs[] = {\"bash\", \"-c\", \"(cd \"+perfectoConnectLocation+\"; \"+baseCommand+\" \"+pcParameters.trim()+\")\"};\n\t\t\tprocess = Runtime.getRuntime().exec(cmdArgs);\n\t\t}\n\t\tInputStream is = process.getInputStream();\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));\n\t\tString s = null;\n\t\twhile ((s = reader.readLine()) != null) {\n\t\t\tlistener.getLogger().println(s);\n\t\t\tMatcher m = Pattern.compile(\"^[A-Za-z0-9-]+$\").matcher(s);\n\t\t\tif (m.find()) {\n\t\t\t\ttunnelId = m.group(0);\n\t\t\t\tlistener.getLogger().println(\"Tunnel Id : \"+tunnelId);\n\t\t\t}\n\t\t\tif(s.contains(\"bash: \")) {\n\t\t\t\tlistener.fatalError(\"Perfecto Connect Path and Name is not Correct. Path Provided : '\"+pcLocation+\"'\");\n\t\t\t\tthrow new IOException(\"Perfecto Connect Path and Name is not Correct. Path Provided : '\"+pcLocation+\"'\");\n\t\t\t}\n\t\t\tif(s.contains(\"Can't start Perfecto Connect\")||s.contains(\"failed to start\")) {\n\t\t\t\tlistener.fatalError(tunnelId);\n\t\t\t\tthrow new IOException(tunnelId);\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\tif(tunnelId == null) {\n\t\t\tlistener.fatalError(\"Unable to create tunnel ID. Kindly cross check your parameters or raise a Perfecto support case.\");\n\t\t\tthrow new IOException(\"Unable to create tunnel ID. Kindly cross check your parameters or raise a Perfecto support case.\");\n\t\t}\n\t\treturn tunnelId;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          151,
          194
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/PerfectoBuildWrapper.java",
        "class_name": "PerfectoBuildWrapper",
        "method_name": "setUp",
        "signature": "Environment setUp(AbstractBuild,Launcher,BuildListener,Map,AbstractBuild,BuildListener)",
        "lines_hint_csv": [
          205,
          249
        ],
        "code": "\tpublic Environment setUp(final AbstractBuild build, Launcher launcher, final BuildListener listener) throws IOException, InterruptedException {\n\t\tlistener.getLogger().println(\"Creating Tunnel Id........!\");\n\t\tlogger.fine(\"Setting Perfecto Build Wrapper\");\n\n\t\tcredentials = PerfectoCredentials.getPerfectoCredentials(build, this);\n\t\tCredentialsProvider.track(build, credentials);\n\n\t\tif(credentials==null && !reuseTunnelId.contains(\"-\")) {\n\t\t\tlistener.fatalError(\"Credentials missing......\");\n\t\t\tthrow new IOException(\"Credentials missing......\");\n\t\t}\n\n\t\tif(!reuseTunnelId.contains(\"-\")) {\n\t\t\tfinal String apiKey = credentials.getPassword().getPlainText();\n\t\t\ttunnelId = getTunnelId(perfectoConnectLocation, credentials.getCloudName(), apiKey, listener);\n\t\t}\n\t\telse\n\t\t\ttunnelId = reuseTunnelId;\n\t\tlistener.getLogger().println(\"Tunnel Id created succesfully.\");\n\n\t\treturn new Environment() {\n\n\t\t\t/**\n\t\t\t * Updates the environment variable map to include the Perfecto specific environment variables applicable to the build.\n\t\t\t * @param env existing environment variables\n\t\t\t */\n\t\t\t@Override\n\t\t\tpublic void buildEnvVars(Map<String, String> env) {\n\t\t\t\tlogger.fine(\"Creating Perfecto environment variables\");\n\t\t\t\tPerfectoEnvironmentUtil.outputEnvironmentVariable(env, tunnelIdCustomName, tunnelId, true);\n\t\t\t}\n\t\t\t/**\n\t\t\t * {@inheritDoc}\n\t\t\t *\n\t\t\t * Tear down method\n\t\t\t * @param build\n\t\t\t *      The build in progress for which an {@link Environment} object is created.\n\t\t\t *      Never null.\n\t\t\t * @param listener\n\t\t\t *      Can be used to send any message.\n\t\t\t *\n\t\t\t */\n\t\t\t@Override\n\t\t\tpublic boolean tearDown(AbstractBuild build, BuildListener listener) throws IOException, InterruptedException {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          205,
          252
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/PerfectoBuildWrapper.java",
        "class_name": "PerfectoBuildWrapper",
        "method_name": "PerfectoBuildWrapper",
        "signature": "PerfectoBuildWrapper(RunCondition,String,String,String,String,String,String,String)",
        "lines_hint_csv": [
          130,
          148
        ],
        "code": "\tpublic PerfectoBuildWrapper(\n\t\t\tRunCondition condition,\n\t\t\tString credentialId,\n\t\t\tString tunnelIdCustomName,\n\t\t\tString pcParameters,\n\t\t\tString perfectoConnectLocation,\n\t\t\tString perfectoSecurityToken,\n\t\t\tString perfectoConnectFile,\n\t\t\tString reuseTunnelId\n\t\t\t) {\n\t\tthis.perfectoConnectLocation = perfectoConnectLocation;\n\t\tthis.condition = condition;\n\t\tif(tunnelIdCustomName.length()>1)\n\t\t\tthis.tunnelIdCustomName = tunnelIdCustomName;\n\t\tthis.credentialId = credentialId;\n\t\tthis.perfectoSecurityToken = perfectoSecurityToken;\n\t\tthis.pcParameters = pcParameters;\n\t\tthis.perfectoConnectFile = perfectoConnectFile;\n\t\tthis.reuseTunnelId = reuseTunnelId;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          130,
          149
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/credentials/PerfectoCredentials.java",
        "class_name": "DescriptorImpl",
        "method_name": "doCheckUserName",
        "signature": "FormValidation doCheckUserName(String)",
        "lines_hint_csv": [
          222,
          227
        ],
        "code": "\t\tpublic FormValidation doCheckUserName(@QueryParameter String value) {\n\t\t\tJenkins.get().checkPermission(Jenkins.ADMINISTER);\n\t\t\tif (Util.fixEmptyAndTrim(value) == null) {\n\t\t\t\treturn FormValidation.error(\"Username cannot be empty\");\n\t\t\t}\n\t\t\treturn FormValidation.ok();\n\t\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          222,
          228
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/credentials/PerfectoCredentials.java",
        "class_name": "DescriptorImpl",
        "method_name": "doAuthenticate",
        "signature": "FormValidation doAuthenticate(String,String,String)",
        "lines_hint_csv": [
          195,
          200
        ],
        "code": "\t\tpublic final FormValidation doAuthenticate(@QueryParameter(\"userName\") String userName, @QueryParameter(\"cloudName\") String cloudName,\n\t\t\t\t@QueryParameter(\"apiKey\") String apiKey) {\n\t\t\tif (StringUtils.isBlank(userName) || StringUtils.isBlank(cloudName) || StringUtils.isBlank(apiKey)) {\n\t\t\t\treturn FormValidation.error(ERR_EMPTY_AUTH);\n\t\t\t}\n\t\t\treturn testAuthentication(userName, cloudName, apiKey);\n\t\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          195,
          201
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/credentials/PerfectoCredentials.java",
        "class_name": "PerfectoCredentials",
        "method_name": "migrateToCredentials",
        "signature": "String migrateToCredentials(String,String,String,String)",
        "lines_hint_csv": [
          231,
          273
        ],
        "code": "\tpublic static String migrateToCredentials(String username, String cloudName, String accessKey, String migratedFrom) throws InterruptedException, IOException {\n\t\tfinal List<PerfectoCredentials> credentialsForDomain = PerfectoCredentials.all((Item) null);\n\t\tfinal StandardUsernameCredentials existingCredentials = CredentialsMatchers.firstOrNull(\n\t\t\t\tcredentialsForDomain,\n\t\t\t\tCredentialsMatchers.withUsername(username)\n\t\t\t\t);\n\n\t\tfinal String credentialId;\n\t\tif (existingCredentials == null) {\n\t\t\tString createdCredentialId = UUID.randomUUID().toString();\n\n\t\t\tfinal StandardUsernameCredentials credentialsToCreate;\n\t\t\tif (!Strings.isNullOrEmpty(accessKey)) {\n\t\t\t\tcredentialsToCreate = new PerfectoCredentials(\n\t\t\t\t\t\tCredentialsScope.GLOBAL,\n\t\t\t\t\t\tcreatedCredentialId,\n\t\t\t\t\t\tusername,\n\t\t\t\t\t\tcloudName,\n\t\t\t\t\t\taccessKey,\n\t\t\t\t\t\t\"migrated from \" + migratedFrom\n\t\t\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow new InterruptedException(\"Did not find password\");\n\t\t\t}\n\n\t\t\tfinal SystemCredentialsProvider credentialsProvider = SystemCredentialsProvider.getInstance();\n\t\t\tfinal Map<Domain, List<Credentials>> credentialsMap = credentialsProvider.getDomainCredentialsMap();\n\n\t\t\tfinal Domain domain = Domain.global();\n\t\t\tif (credentialsMap.get(domain) == null) {\n\t\t\t\tcredentialsMap.put(domain, Collections.EMPTY_LIST);\n\t\t\t}\n\t\t\tcredentialsMap.get(domain).add(credentialsToCreate);\n\n\t\t\tcredentialsProvider.setDomainCredentialsMap(credentialsMap);\n\t\t\tcredentialsProvider.save();\n\n\t\t\tcredentialId = createdCredentialId;\n\t\t} else {\n\t\t\tcredentialId = existingCredentials.getId();\n\t\t}\n\n\t\treturn credentialId;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          231,
          274
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/credentials/PerfectoCredentials.java",
        "class_name": "PerfectoCredentials",
        "method_name": "getPassword",
        "signature": "Secret getPassword()",
        "lines_hint_csv": [
          138,
          159
        ],
        "code": "\tpublic Secret getPassword() {\n\t\tif (getShortLivedConfig() != null) {\n\t\t\ttry {\n\t\t\t\tDate d = new Date();\n\t\t\t\tDate expires = new Date(\n\t\t\t\t\t\tSystem.currentTimeMillis() +\n\t\t\t\t\t\t(long) getShortLivedConfig().getTime() * 1000 /* to millis */ * 60 /* to minutes */\n\t\t\t\t\t\t);\n\n\t\t\t\tString token = JWT.create()\n\t\t\t\t\t\t.withExpiresAt(expires)\n\t\t\t\t\t\t.withIssuedAt(d)\n\t\t\t\t\t\t.sign(Algorithm.HMAC256(apiKey.getPlainText()));\n\t\t\t\treturn Secret.fromString(token);\n\t\t\t} catch (JWTCreationException e){\n\t\t\t\t//Invalid Signing configuration / Couldn't convert Claims.\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn getApiKey();\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          138,
          160
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/credentials/PerfectoCredentials.java",
        "class_name": "DescriptorImpl",
        "method_name": "doCheckApiKey",
        "signature": "FormValidation doCheckApiKey(String)",
        "lines_hint_csv": [
          213,
          218
        ],
        "code": "\t\tpublic FormValidation doCheckApiKey(@QueryParameter String value) {\n\t\t\tJenkins.get().checkPermission(Jenkins.ADMINISTER);\n\t\t\tif (Util.fixEmptyAndTrim(value) == null) {\n\t\t\t\treturn FormValidation.error(\"Security Token cannot be empty\");\n\t\t\t}\n\t\t\treturn FormValidation.ok();\n\t\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          213,
          219
        ]
      },
      {
        "file_path": "src/main/java/io/plugins/perfecto/credentials/PerfectoCredentials.java",
        "class_name": "PerfectoCredentials",
        "method_name": "PerfectoCredentials",
        "signature": "PerfectoCredentials(CredentialsScope,String,String,String,String,String)",
        "lines_hint_csv": [
          76,
          81
        ],
        "code": "\tpublic PerfectoCredentials(@CheckForNull CredentialsScope scope, @CheckForNull String id, @CheckForNull String userName, @CheckForNull String cloudName,\n\t\t\t@NonNull String apiKey, @CheckForNull String description) {\n\t\tsuper(scope, id, description);\n\t\tthis.userName = userName;\n\t\tthis.cloudName = cloudName;\n\t\tthis.apiKey = Secret.fromString(apiKey);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          76,
          82
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-33140",
    "project_slug": "apache__nifi_CVE-2022-33140_1.16.2",
    "buggy_commit_id": "06f04958272dafc30ce357c4c4edcaf470050b52",
    "github_url": "https://github.com/apache/nifi",
    "nvd_metadata": {
      "description": "The optional ShellUserGroupProvider in Apache NiFi 1.10.0 to 1.16.2 and Apache NiFi Registry 0.6.0 to 1.16.2 does not neutralize arguments for group resolution commands, allowing injection of operating system commands on Linux and macOS platforms. The ShellUserGroupProvider is not included in the default configuration. Command injection requires ShellUserGroupProvider to be one of the enabled User Group Providers in the Authorizers configuration. Command injection also requires an authenticated user with elevated privileges. Apache NiFi requires an authenticated user with authorization to modify access policies in order to execute the command. Apache NiFi Registry requires an authenticated user with authorization to read user groups in order to execute the command. The resolution removes command formatting based on user-provided arguments.",
      "published_date": "2022-06-15T15:15:08.050",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/NssShellCommands.java",
        "class_name": "NssShellCommands",
        "method_name": "getGroupMembers",
        "signature": "String getGroupMembers(String)",
        "lines_hint_csv": [
          44,
          45
        ],
        "code": "    public String getGroupMembers(String groupName) {\n        return String.format(\"getent group %s | cut -f 4 -d ':'\", groupName);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          44,
          46
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/OsxShellCommands.java",
        "class_name": "OsxShellCommands",
        "method_name": "getGroupMembers",
        "signature": "String getGroupMembers(String)",
        "lines_hint_csv": [
          46,
          47
        ],
        "code": "    public String getGroupMembers(String groupName) {\n        return String.format(\"dscl . -read /Groups/%s GroupMembership | cut -f 2- -d ' ' | sed 's/\\\\ /,/g'\", groupName);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          46,
          48
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/RemoteShellCommands.java",
        "class_name": "RemoteShellCommands",
        "method_name": "getGroupMembers",
        "signature": "String getGroupMembers(String)",
        "lines_hint_csv": [
          55,
          56
        ],
        "code": "    public String getGroupMembers(String groupName) {\n        return String.format(remoteCommand, innerProvider.getGroupMembers(groupName), privateKeyPath, remotePort, remoteHost);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          55,
          57
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "onConfigured",
        "signature": "void onConfigured(AuthorizerConfigurationContext)",
        "lines_hint_csv": [
          263,
          311
        ],
        "code": "    public void onConfigured(AuthorizerConfigurationContext configurationContext) throws AuthorizerCreationException {\n        logger.info(\"Configuring ShellUserGroupProvider\");\n\n        fixedDelay = getDelayProperty(configurationContext, REFRESH_DELAY_PROPERTY, \"5 mins\");\n        timeoutSeconds = getTimeoutProperty(configurationContext, COMMAND_TIMEOUT_PROPERTY, DEFAULT_COMMAND_TIMEOUT);\n        shellRunner = new ShellRunner(timeoutSeconds);\n        logger.debug(\"Configured ShellRunner with command timeout of '{}' seconds\", new Object[]{timeoutSeconds});\n\n        // Our next init step is to select the command set based on the operating system name:\n        ShellCommandsProvider commands = getCommandsProvider();\n\n        if (commands == null) {\n            commands = getCommandsProviderFromName(null);\n            setCommandsProvider(commands);\n        }\n\n        // Our next init step is to run the system check from that command set to determine if the other commands\n        // will work on this host or not.\n        try {\n            shellRunner.runShell(commands.getSystemCheck());\n        } catch (final Exception e) {\n            logger.error(\"initialize exception: \" + e + \" system check command: \" + commands.getSystemCheck());\n            throw new AuthorizerCreationException(SYS_CHECK_ERROR, e);\n        }\n\n        // The next step is to add the user and group exclude regexes:\n        try {\n            excludeGroups = Pattern.compile(getProperty(configurationContext, EXCLUDE_GROUP_PROPERTY, \"\"));\n            excludeUsers = Pattern.compile(getProperty(configurationContext, EXCLUDE_USER_PROPERTY, \"\"));\n        } catch (final PatternSyntaxException e) {\n            throw new AuthorizerCreationException(e);\n        }\n\n        // Get the value for Legacy Identifier Mo\n        legacyIdentifierMode = Boolean.parseBoolean(getProperty(configurationContext, LEGACY_IDENTIFIER_MODE, \"true\"));\n\n        // With our command set selected, and our system check passed, we can pull in the users and groups:\n        refreshUsersAndGroups();\n\n        // And finally, our last init step is to fire off the refresh thread:\n        scheduler.scheduleWithFixedDelay(() -> {\n            try {\n                refreshUsersAndGroups();\n            }catch (final Throwable t) {\n                logger.error(\"\", t);\n            }\n        }, fixedDelay, fixedDelay, TimeUnit.MILLISECONDS);\n\n        logger.info(\"Completed configuration of ShellUserGroupProvider\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          263,
          312
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "getGroup",
        "signature": "Group getGroup(String)",
        "lines_hint_csv": [
          171,
          188
        ],
        "code": "    public Group getGroup(String identifier) throws AuthorizationAccessException {\n        Group group;\n\n        synchronized (groupsById) {\n            group = groupsById.get(identifier);\n        }\n\n        if (group == null) {\n            refreshOneGroup(selectedShellCommands.getGroupById(identifier), \"Get Single Group by Id\");\n            group = groupsById.get(identifier);\n        }\n\n        if (group == null) {\n            logger.debug(\"getGroup (by id) group not found: \" + identifier);\n        } else {\n            logger.debug(\"getGroup (by id) found group: {} for id: {}\", group.getName(), identifier);\n        }\n        return group;\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          171,
          190
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "preDestruction",
        "signature": "void preDestruction()",
        "lines_hint_csv": [
          394,
          403
        ],
        "code": "    public void preDestruction() throws AuthorizerDestructionException {\n        try {\n            scheduler.shutdownNow();\n        } catch (final Exception e) {\n            logger.warn(\"Error shutting down refresh scheduler: \" + e.getMessage(), e);\n        }\n        try {\n            shellRunner.shutdown();\n        } catch (final Exception e) {\n            logger.warn(\"Error shutting down ShellRunner: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          394,
          405
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "refreshUsersAndGroups",
        "signature": "void refreshUsersAndGroups()",
        "lines_hint_csv": [
          487,
          548
        ],
        "code": "    private void refreshUsersAndGroups() {\n        final long startTime = System.currentTimeMillis();\n\n        Map<String, User> uidToUser = new HashMap<>();\n        Map<String, User> usernameToUser = new HashMap<>();\n        Map<String, User> gidToUser = new HashMap<>();\n        Map<String, Group> gidToGroup = new HashMap<>();\n\n        List<String> userLines;\n        List<String> groupLines;\n\n        try {\n            userLines = shellRunner.runShell(selectedShellCommands.getUsersList(), \"Get Users List\");\n            groupLines = shellRunner.runShell(selectedShellCommands.getGroupsList(), \"Get Groups List\");\n        } catch (final IOException ioexc) {\n            logger.error(\"refreshUsersAndGroups shell exception: \" + ioexc);\n            return;\n        }\n\n        rebuildUsers(userLines, uidToUser, usernameToUser, gidToUser);\n        rebuildGroups(groupLines, gidToGroup);\n        reconcilePrimaryGroups(gidToUser, gidToGroup);\n\n        synchronized (usersById) {\n            usersById.clear();\n            usersById.putAll(uidToUser);\n\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"=== Users by id...\");\n                Set<User> sortedUsers = new TreeSet<>(Comparator.comparing(User::getIdentity));\n                sortedUsers.addAll(usersById.values());\n                sortedUsers.forEach(u -> logger.trace(\"=== \" + u.toString()));\n            }\n        }\n\n        synchronized (usersByName) {\n            usersByName.clear();\n            usersByName.putAll(usernameToUser);\n            logger.debug(\"users now size: \" + usersByName.size());\n        }\n\n        synchronized (groupsById) {\n            groupsById.clear();\n            groupsById.putAll(gidToGroup);\n            logger.debug(\"groupsById now size: \" + groupsById.size());\n\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"=== Groups by id...\");\n                Set<Group> sortedGroups = new TreeSet<>(Comparator.comparing(Group::getName));\n                sortedGroups.addAll(groupsById.values());\n                sortedGroups.forEach(g -> logger.trace(\"=== \" + g.toString()));\n            }\n        }\n\n        synchronized (groupsByName) {\n            groupsByName.clear();\n            gidToGroup.values().forEach(g -> groupsByName.put(g.getName(), g));\n            logger.debug(\"groupsByName now size: \" + groupsByName.size());\n        }\n\n        final long endTime = System.currentTimeMillis();\n        logger.info(\"Refreshed users and groups, took {} seconds\", (endTime - startTime) / 1000);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          487,
          549
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "getCommandsProvider",
        "signature": "ShellCommandsProvider getCommandsProvider()",
        "lines_hint_csv": [
          407,
          408
        ],
        "code": "    public ShellCommandsProvider getCommandsProvider() {\n        return selectedShellCommands;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          407,
          409
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/main/java/org/apache/nifi/authorization/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "getUserByIdentity",
        "signature": "User getUserByIdentity(String)",
        "lines_hint_csv": [
          129,
          146
        ],
        "code": "    public User getUserByIdentity(String identity) throws AuthorizationAccessException {\n        User user;\n\n        synchronized (usersByName) {\n            user = usersByName.get(identity);\n        }\n\n        if (user == null) {\n            refreshOneUser(selectedShellCommands.getUserByName(identity), \"Get Single User by Name\");\n            user = usersByName.get(identity);\n        }\n\n        if (user == null) {\n            logger.debug(\"getUser (by name) user not found: \" + identity);\n        } else {\n            logger.debug(\"getUser (by name) found user: \" + user.getIdentity() + \" for name: \" + identity);\n        }\n        return user;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          129,
          147
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-shell-authorizer/src/test/java/org/apache/nifi/authorization/ShellUserGroupProviderIT.java",
        "class_name": "ShellUserGroupProviderIT",
        "method_name": "setupOnce",
        "signature": "void setupOnce()",
        "lines_hint_csv": [
          96,
          116
        ],
        "code": "    public static void setupOnce() throws IOException {\n        sshPrivKeyFile = tempFolder.getRoot().getAbsolutePath() + \"/id_rsa\";\n        sshPubKeyFile = sshPrivKeyFile + \".pub\";\n\n        shellRunner = new ShellRunner(60);\n        try {\n            // NB: this command is a bit perplexing: it works without prompt from the shell, but hangs\n            // here without the pipe from `yes`:\n            shellRunner.runShell(\"yes | ssh-keygen -C '' -N '' -t rsa -f \" + sshPrivKeyFile);\n        } catch (final IOException ioexc) {\n            systemCheckFailed = true;\n            logger.error(\"setupOnce() exception: \" + ioexc + \"; tests cannot run on this system.\");\n            return;\n        }\n\n        // Fix the file permissions to abide by the ssh client\n        // requirements:\n        Arrays.asList(sshPrivKeyFile, sshPubKeyFile).forEach(name -> {\n                final File f = new File(name);\n                Assert.assertTrue(f.setReadable(false, false));\n                Assert.assertTrue(f.setReadable(true));\n            });\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          96,
          118
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/NssShellCommands.java",
        "class_name": "NssShellCommands",
        "method_name": "getGroupMembers",
        "signature": "String getGroupMembers(String)",
        "lines_hint_csv": [
          43,
          44
        ],
        "code": "    public String getGroupMembers(String groupName) {\n        return String.format(\"getent group %s | cut -f 4 -d ':'\", groupName);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          43,
          45
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/OsxShellCommands.java",
        "class_name": "OsxShellCommands",
        "method_name": "getGroupMembers",
        "signature": "String getGroupMembers(String)",
        "lines_hint_csv": [
          45,
          46
        ],
        "code": "    public String getGroupMembers(String groupName) {\n        return String.format(\"dscl . -read /Groups/%s GroupMembership | cut -f 2- -d ' ' | sed 's/\\\\ /,/g'\", groupName);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          45,
          47
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "getCommandsProvider",
        "signature": "ShellCommandsProvider getCommandsProvider()",
        "lines_hint_csv": [
          390,
          391
        ],
        "code": "    public ShellCommandsProvider getCommandsProvider() {\n        return selectedShellCommands;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          390,
          392
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "getUserByIdentity",
        "signature": "User getUserByIdentity(String)",
        "lines_hint_csv": [
          131,
          148
        ],
        "code": "    public User getUserByIdentity(String identity) throws AuthorizationAccessException {\n        User user;\n\n        synchronized (usersByName) {\n            user = usersByName.get(identity);\n        }\n\n        if (user == null) {\n            refreshOneUser(selectedShellCommands.getUserByName(identity), \"Get Single User by Name\");\n            user = usersByName.get(identity);\n        }\n\n        if (user == null) {\n            logger.debug(\"getUser (by name) user not found: \" + identity);\n        } else {\n            logger.debug(\"getUser (by name) found user: \" + user.getIdentity() + \" for name: \" + identity);\n        }\n        return user;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          131,
          149
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "getGroup",
        "signature": "Group getGroup(String)",
        "lines_hint_csv": [
          173,
          190
        ],
        "code": "    public Group getGroup(String identifier) throws AuthorizationAccessException {\n        Group group;\n\n        synchronized (groupsById) {\n            group = groupsById.get(identifier);\n        }\n\n        if (group == null) {\n            refreshOneGroup(selectedShellCommands.getGroupById(identifier), \"Get Single Group by Id\");\n            group = groupsById.get(identifier);\n        }\n\n        if (group == null) {\n            logger.debug(\"getGroup (by id) group not found: \" + identifier);\n        } else {\n            logger.debug(\"getGroup (by id) found group: \" + group.getName() + \" for id: \" + identifier);\n        }\n        return group;\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          173,
          192
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "onConfigured",
        "signature": "void onConfigured(AuthorizerConfigurationContext)",
        "lines_hint_csv": [
          248,
          294
        ],
        "code": "    public void onConfigured(AuthorizerConfigurationContext configurationContext) throws SecurityProviderCreationException {\n        logger.info(\"Configuring ShellUserGroupProvider\");\n\n        fixedDelay = getDelayProperty(configurationContext, REFRESH_DELAY_PROPERTY, \"5 mins\");\n        timeoutSeconds = getTimeoutProperty(configurationContext, COMMAND_TIMEOUT_PROPERTY, DEFAULT_COMMAND_TIMEOUT);\n        shellRunner = new ShellRunner(timeoutSeconds);\n        logger.debug(\"Configured ShellRunner with command timeout of '{}' seconds\", new Object[]{timeoutSeconds});\n\n\n        // Our next init step is to select the command set based on the operating system name:\n        ShellCommandsProvider commands = getCommandsProvider();\n\n        if (commands == null) {\n            commands = getCommandsProviderFromName(null);\n            setCommandsProvider(commands);\n        }\n\n        // Our next init step is to run the system check from that command set to determine if the other commands\n        // will work on this host or not.\n        try {\n            shellRunner.runShell(commands.getSystemCheck());\n        } catch (final Exception e) {\n            logger.error(\"initialize exception: \" + e + \" system check command: \" + commands.getSystemCheck());\n            throw new SecurityProviderCreationException(SYS_CHECK_ERROR, e);\n        }\n\n        // The next step is to add the user and group exclude regexes:\n        try {\n            excludeGroups = Pattern.compile(getProperty(configurationContext, EXCLUDE_GROUP_PROPERTY, \"\"));\n            excludeUsers = Pattern.compile(getProperty(configurationContext, EXCLUDE_USER_PROPERTY, \"\"));\n        } catch (final PatternSyntaxException e) {\n            throw new SecurityProviderCreationException(e);\n        }\n\n        // With our command set selected, and our system check passed, we can pull in the users and groups:\n        refreshUsersAndGroups();\n\n        // And finally, our last init step is to fire off the refresh thread:\n        scheduler.scheduleWithFixedDelay(() -> {\n            try {\n                refreshUsersAndGroups();\n            }catch (final Throwable t) {\n                logger.error(\"\", t);\n            }\n        }, fixedDelay, fixedDelay, TimeUnit.MILLISECONDS);\n\n        logger.info(\"Completed configuration of ShellUserGroupProvider\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          248,
          295
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "refreshUsersAndGroups",
        "signature": "void refreshUsersAndGroups()",
        "lines_hint_csv": [
          467,
          522
        ],
        "code": "    private void refreshUsersAndGroups() {\n        final long startTime = System.currentTimeMillis();\n\n        Map<String, User> uidToUser = new HashMap<>();\n        Map<String, User> usernameToUser = new HashMap<>();\n        Map<String, User> gidToUser = new HashMap<>();\n        Map<String, Group> gidToGroup = new HashMap<>();\n\n        List<String> userLines;\n        List<String> groupLines;\n\n        try {\n            userLines = shellRunner.runShell(selectedShellCommands.getUsersList(), \"Get Users List\");\n            groupLines = shellRunner.runShell(selectedShellCommands.getGroupsList(), \"Get Groups List\");\n        } catch (final IOException ioexc) {\n            logger.error(\"refreshUsersAndGroups shell exception: \" + ioexc);\n            return;\n        }\n\n        rebuildUsers(userLines, uidToUser, usernameToUser, gidToUser);\n        rebuildGroups(groupLines, gidToGroup);\n        reconcilePrimaryGroups(gidToUser, gidToGroup);\n\n        synchronized (usersById) {\n            usersById.clear();\n            usersById.putAll(uidToUser);\n\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"=== Users by id...\");\n                Set<User> sortedUsers = new TreeSet<>(Comparator.comparing(User::getIdentity));\n                sortedUsers.addAll(usersById.values());\n                sortedUsers.forEach(u -> logger.trace(\"=== \" + u.toString()));\n            }\n        }\n\n        synchronized (usersByName) {\n            usersByName.clear();\n            usersByName.putAll(usernameToUser);\n            logger.debug(\"users now size: \" + usersByName.size());\n        }\n\n        synchronized (groupsById) {\n            groupsById.clear();\n            groupsById.putAll(gidToGroup);\n            logger.debug(\"groups now size: \" + groupsById.size());\n\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"=== Groups by id...\");\n                Set<Group> sortedGroups = new TreeSet<>(Comparator.comparing(Group::getName));\n                sortedGroups.addAll(groupsById.values());\n                sortedGroups.forEach(g -> logger.trace(\"=== \" + g.toString()));\n            }\n        }\n\n        final long endTime = System.currentTimeMillis();\n        logger.info(\"Refreshed users and groups, took {} seconds\", (endTime - startTime) / 1000);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          467,
          523
        ]
      },
      {
        "file_path": "nifi-registry/nifi-registry-core/nifi-registry-framework/src/main/java/org/apache/nifi/registry/security/authorization/shell/ShellUserGroupProvider.java",
        "class_name": "ShellUserGroupProvider",
        "method_name": "preDestruction",
        "signature": "void preDestruction()",
        "lines_hint_csv": [
          377,
          386
        ],
        "code": "    public void preDestruction() throws SecurityProviderDestructionException {\n        try {\n            scheduler.shutdownNow();\n        } catch (final Exception e) {\n            logger.warn(\"Error shutting down refresh scheduler: \" + e.getMessage(), e);\n        }\n        try {\n            shellRunner.shutdown();\n        } catch (final Exception e) {\n            logger.warn(\"Error shutting down ShellRunner: \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          377,
          388
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-24422",
    "project_slug": "jenkinsci__script-security-plugin_CVE-2023-24422_1228.vd93135a_2fb_25",
    "buggy_commit_id": "d93135a2fb250c04cc361b0bb1efd809bc63ad08",
    "github_url": "https://github.com/jenkinsci/script-security-plugin",
    "nvd_metadata": {
      "description": "A sandbox bypass vulnerability involving map constructors in Jenkins Script Security Plugin 1228.vd93135a_2fb_25 and earlier allows attackers with permission to define and run sandboxed scripts, including Pipelines, to bypass the sandbox protection and execute arbitrary code in the context of the Jenkins controller JVM.",
      "published_date": "2023-01-26T21:18:16.633",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/SandboxInterceptor.java",
        "class_name": "SandboxInterceptor",
        "method_name": "onNewInstance",
        "signature": "Object onNewInstance(GroovyInterceptor,Class,Object)",
        "lines_hint_csv": [
          170,
          179
        ],
        "code": "    @Override public Object onNewInstance(GroovyInterceptor.Invoker invoker, Class receiver, Object... args) throws Throwable {\n        Constructor<?> c = GroovyCallSiteSelector.constructor(receiver, args);\n        if (c == null) {\n            throw new RejectedAccessException(\"No such constructor found: new \" + EnumeratingWhitelist.getName(receiver) + printArgumentTypes(args));\n        } else if (StaticWhitelist.isPermanentlyBlacklistedConstructor(c)) {\n            throw StaticWhitelist.rejectNew(c);\n        } else if (whitelist.permitsConstructor(c, args)) {\n            return super.onNewInstance(invoker, receiver, args);\n        } else {\n            throw StaticWhitelist.rejectNew(c);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          170,
          181
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/SandboxInterceptorTest.java",
        "class_name": "SandboxInterceptorTest",
        "method_name": "groovyInterceptable",
        "signature": "void groovyInterceptable()",
        "lines_hint_csv": [
          1380,
          1393
        ],
        "code": "    @Test public void groovyInterceptable() throws Throwable {\n        assertRejected(new GenericWhitelist(), \"method groovy.lang.GroovyObject invokeMethod java.lang.String java.lang.Object\",\n                \"class Test implements GroovyInterceptable {\\n\" +\n                \"  def hello() { 'world' }\\n\" +\n                \"  def invokeMethod(String name, Object args) { 'goodbye' }\\n\" +\n                \"}\\n\" +\n                \"new Test().hello()\\n\");\n        // Property access is not affected by GroovyInterceptable.\n        assertEvaluate(new GenericWhitelist(), \"world\",\n                \"class Test implements GroovyInterceptable {\\n\" +\n                \"  def hello = 'world'\\n\" +\n                \"  def invokeMethod(String name, Object args) { 'goodbye' }\\n\" +\n                \"}\\n\" +\n                \"new Test().hello\\n\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1380,
          1394
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/SandboxInterceptorTest.java",
        "class_name": "SandboxInterceptorTest",
        "method_name": "unsafeReturnValue",
        "signature": "void unsafeReturnValue()",
        "lines_hint_csv": [
          1397,
          1413
        ],
        "code": "    @Test public void unsafeReturnValue() throws Throwable {\n        final SecurityException e = assertThrows(SecurityException.class, () -> {\n            Object result = evaluate(new GenericWhitelist(),\n                    \"class Test {\\n\" +\n                            \"  @Override public String toString() {\\n\" +\n                            \"    jenkins.model.Jenkins.get().setSystemMessage('Hello, world!')\\n\" +\n                            \"    'test'\\n\" +\n                            \"  }\\n\" +\n                            \"}\\n\" +\n                            \"new Test()\");\n            // Test.equals and Test.getClass are inherited and not sandbox-transformed, so they can be called outside of the sandbox.\n            assertNotEquals(result, new Object());\n            assertThat(result.getClass().getSimpleName(), equalTo(\"Test\"));\n            // Test.toString is defined in the sandbox, so it cannot be called outside of the sandbox.\n            result.toString();\n        });\n        assertThat(e.getMessage(), equalTo(\"Rejecting unsandboxed static method call: jenkins.model.Jenkins.get()\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1397,
          1414
        ]
      },
      {
        "file_path": "src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/SandboxInterceptorTest.java",
        "class_name": "SandboxInterceptorTest",
        "method_name": "primitiveTypes",
        "signature": "void primitiveTypes()",
        "lines_hint_csv": [
          676,
          688
        ],
        "code": "    @Test public void primitiveTypes() throws Exception {\n        // Some String operations:\n        assertRejected(new ProxyWhitelist(), \"method java.lang.CharSequence charAt int\", \"'123'.charAt(1);\");\n        assertEvaluate(new StaticWhitelist(\"method java.lang.CharSequence charAt int\"), '2', \"'123'.charAt(1);\");\n        // Unrelated to math:\n        assertRejected(new ProxyWhitelist(), \"staticMethod java.lang.Integer getInteger java.lang.String\", \"Integer.getInteger('whatever')\");\n        // Some of http://groovy-lang.org/operators.html#Operator-Overloading on numbers are handled internally:\n        assertEvaluate(new ProxyWhitelist(), 4, \"2 + 2\");\n        assertEvaluate(new ProxyWhitelist(), 4, \"2.plus(2)\");\n        // Others are handled via DefaultGroovyMethods:\n        assertEvaluate(new GenericWhitelist(), 4, \"2 ** 2\");\n        assertEvaluate(new GenericWhitelist(), 4, \"2.power(2)\");\n        assertEvaluate(new GenericWhitelist(), \"23\", \"'2' + 3\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          676,
          689
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2016-10006",
    "project_slug": "nahsra__antisamy_CVE-2016-10006_1.5.3",
    "buggy_commit_id": "8bebe1eb2ec1ac23e34111e9d06024d7dab7fa25",
    "github_url": "https://github.com/nahsra/antisamy",
    "nvd_metadata": {
      "description": "In OWASP AntiSamy before 1.5.5, by submitting a specially crafted input (a tag that supports style with active content), you could bypass the library protections and supply executable code. The impact is XSS.",
      "published_date": "2016-12-24T18:59:00.130",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "scriptAttacks",
        "signature": "void scriptAttacks()",
        "lines_hint_csv": [
          115,
          144
        ],
        "code": "    public void scriptAttacks() {\n\n        try {\n\n            assertTrue(!as.scan(\"test<script>alert(document.cookie)</script>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"script\"));\n            assertTrue(!as.scan(\"test<script>alert(document.cookie)</script>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"script\"));\n\n            assertTrue(!as.scan(\"<<<><<script src=http://fake-evil.ru/test.js>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<<<><<script src=http://fake-evil.ru/test.js>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as.scan(\"<script<script src=http://fake-evil.ru/test.js>>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<script<script src=http://fake-evil.ru/test.js>>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as.scan(\"<SCRIPT/XSS SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<SCRIPT/XSS SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as.scan(\"<BODY onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\\\"XSS\\\")>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"onload\"));\n            assertTrue(!as.scan(\"<BODY onload!#$%&()*~+-_.,:;?@[/|\\\\]^`=alert(\\\"XSS\\\")>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"onload\"));\n\n            assertTrue(!as.scan(\"<BODY ONLOAD=alert('XSS')>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n            assertTrue(!as.scan(\"<BODY ONLOAD=alert('XSS')>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n            assertTrue(!as.scan(\"<iframe src=http://ha.ckers.org/scriptlet.html <\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<iframe\"));\n            assertTrue(!as.scan(\"<iframe src=http://ha.ckers.org/scriptlet.html <\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<iframe\"));\n\n            assertTrue(!as.scan(\"<INPUT TYPE=\\\"IMAGE\\\" SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"src\"));\n            assertTrue(!as.scan(\"<INPUT TYPE=\\\"IMAGE\\\" SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"src\"));\n\n            as.scan(\"<a onblur=\\\"alert(secret)\\\" href=\\\"http://www.google.com\\\">Google</a>\", policy, AntiSamy.DOM);\n            as.scan(\"<a onblur=\\\"alert(secret)\\\" href=\\\"http://www.google.com\\\">Google</a>\", policy, AntiSamy.SAX);\n\n        } catch (Exception e) {\n            fail(\"Caught exception in testScriptAttack(): \" + e.getMessage());\n        }\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          108,
          143
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "imgAttacks",
        "signature": "void imgAttacks()",
        "lines_hint_csv": [
          147,
          193
        ],
        "code": "    public void imgAttacks() {\n\n        try {\n\n            assertTrue(as.scan(\"<img src=\\\"http://www.myspace.com/img.gif\\\"/>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n            assertTrue(as.scan(\"<img src=\\\"http://www.myspace.com/img.gif\\\"/>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n            assertTrue(!as.scan(\"<img src=javascript:alert(document.cookie)>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n            assertTrue(!as.scan(\"<img src=javascript:alert(document.cookie)>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n            assertTrue(!as.scan(\"<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n            assertTrue(!as.scan(\"<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>\", policy, AntiSamy.SAX)\n                    .getCleanHTML().contains(\"<img\"));\n\n            assertTrue(!as\n                    .scan(\n                            \"<IMG SRC='&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041'>\",\n                            policy, AntiSamy.DOM).getCleanHTML().contains(\"<img\"));\n            assertTrue(!as\n                    .scan(\n                            \"<IMG SRC='&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041'>\",\n                            policy, AntiSamy.SAX).getCleanHTML().contains(\"<img\"));\n\n            assertTrue(!as.scan(\"<IMG SRC=\\\"jav&#x0D;ascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n            assertTrue(!as.scan(\"<IMG SRC=\\\"jav&#x0D;ascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n            String s = as\n                    .scan(\n                            \"<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>\",\n                            policy, AntiSamy.DOM).getCleanHTML();\n            assertTrue(s.length() == 0 || s.contains(\"&amp;\"));\n            s = as\n                    .scan(\n                            \"<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>\",\n                            policy, AntiSamy.SAX).getCleanHTML();\n            assertTrue(s.length() == 0 || s.contains(\"&amp;\"));\n\n            as.scan(\"<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>\", policy, AntiSamy.DOM);\n            as.scan(\"<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>\", policy, AntiSamy.SAX);\n\n            assertTrue(!as.scan(\"<IMG SRC=\\\"javascript:alert('XSS')\\\"\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<IMG SRC=\\\"javascript:alert('XSS')\\\"\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<IMG LOWSRC=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<IMG LOWSRC=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<BGSOUND SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<BGSOUND SRC=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Caught exception in testImgSrcAttacks(): \" + e.getMessage());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          146,
          199
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "hrefAttacks",
        "signature": "void hrefAttacks()",
        "lines_hint_csv": [
          196,
          312
        ],
        "code": "    public void hrefAttacks() {\n\n        try {\n\n            assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"href\"));\n            assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"href\"));\n\n            assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"http://ha.ckers.org/xss.css\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"href\"));\n            assertTrue(!as.scan(\"<LINK REL=\\\"stylesheet\\\" HREF=\\\"http://ha.ckers.org/xss.css\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"href\"));\n\n            assertTrue(!as.scan(\"<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ha.ckers.org\"));\n            assertTrue(!as.scan(\"<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ha.ckers.org\"));\n\n            assertTrue(!as.scan(\"<STYLE>BODY{-moz-binding:url(\\\"http://ha.ckers.org/xssmoz.xml#xss\\\")}</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ha.ckers.org\"));\n            assertTrue(!as.scan(\"<STYLE>BODY{-moz-binding:url(\\\"http://ha.ckers.org/xssmoz.xml#xss\\\")}</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ha.ckers.org\"));\n\n            assertTrue(!as.scan(\"<STYLE>li {list-style-image: url(\\\"javascript:alert('XSS')\\\");}</STYLE><UL><LI>XSS\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<STYLE>li {list-style-image: url(\\\"javascript:alert('XSS')\\\");}</STYLE><UL><LI>XSS\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<IMG SRC='vbscript:msgbox(\\\"XSS\\\")'>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"vbscript\"));\n            assertTrue(!as.scan(\"<IMG SRC='vbscript:msgbox(\\\"XSS\\\")'>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"vbscript\"));\n\n            assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0; URL=http://;URL=javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n            assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0; URL=http://;URL=javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n            assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=javascript:alert('XSS');\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n            assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=javascript:alert('XSS');\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n            assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<meta\"));\n            assertTrue(!as.scan(\"<META HTTP-EQUIV=\\\"refresh\\\" CONTENT=\\\"0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<meta\"));\n\n            assertTrue(!as.scan(\"<IFRAME SRC=\\\"javascript:alert('XSS');\\\"></IFRAME>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"iframe\"));\n            assertTrue(!as.scan(\"<IFRAME SRC=\\\"javascript:alert('XSS');\\\"></IFRAME>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"iframe\"));\n\n            assertTrue(!as.scan(\"<FRAMESET><FRAME SRC=\\\"javascript:alert('XSS');\\\"></FRAMESET>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<FRAMESET><FRAME SRC=\\\"javascript:alert('XSS');\\\"></FRAMESET>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<TABLE BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"background\"));\n            assertTrue(!as.scan(\"<TABLE BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"background\"));\n\n            assertTrue(!as.scan(\"<TABLE><TD BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"background\"));\n            assertTrue(!as.scan(\"<TABLE><TD BACKGROUND=\\\"javascript:alert('XSS')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"background\"));\n\n            assertTrue(!as.scan(\"<DIV STYLE=\\\"background-image: url(javascript:alert('XSS'))\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<DIV STYLE=\\\"background-image: url(javascript:alert('XSS'))\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<DIV STYLE=\\\"width: expression(alert('XSS'));\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n            assertTrue(!as.scan(\"<DIV STYLE=\\\"width: expression(alert('XSS'));\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n            assertTrue(!as.scan(\"<IMG STYLE=\\\"xss:expr/*XSS*/ession(alert('XSS'))\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"alert\"));\n            assertTrue(!as.scan(\"<IMG STYLE=\\\"xss:expr/*XSS*/ession(alert('XSS'))\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"alert\"));\n\n            assertTrue(!as.scan(\"<STYLE>@im\\\\port'\\\\ja\\\\vasc\\\\ript:alert(\\\"XSS\\\")';</STYLE>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"ript:alert\"));\n            assertTrue(!as.scan(\"<STYLE>@im\\\\port'\\\\ja\\\\vasc\\\\ript:alert(\\\"XSS\\\")';</STYLE>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"ript:alert\"));\n\n            assertTrue(!as.scan(\"<BASE HREF=\\\"javascript:alert('XSS');//\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<BASE HREF=\\\"javascript:alert('XSS');//\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<BaSe hReF=\\\"http://arbitrary.com/\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<base\"));\n            assertTrue(!as.scan(\"<BaSe hReF=\\\"http://arbitrary.com/\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<base\"));\n\n            assertTrue(!as.scan(\"<OBJECT TYPE=\\\"text/x-scriptlet\\\" DATA=\\\"http://ha.ckers.org/scriptlet.html\\\"></OBJECT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<object\"));\n            assertTrue(!as.scan(\"<OBJECT TYPE=\\\"text/x-scriptlet\\\" DATA=\\\"http://ha.ckers.org/scriptlet.html\\\"></OBJECT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<object\"));\n\n            assertTrue(!as.scan(\"<OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389><param name=url value=javascript:alert('XSS')></OBJECT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n\n            CleanResults cr = as.scan(\"<OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389><param name=url value=javascript:alert('XSS')></OBJECT>\", policy, AntiSamy.SAX);\n            // System.out.println(cr.getErrorMessages().get(0));\n            assertTrue(!cr.getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<EMBED SRC=\\\"http://ha.ckers.org/xss.swf\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<embed\"));\n            assertTrue(!as.scan(\"<EMBED SRC=\\\"http://ha.ckers.org/xss.swf\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<embed\"));\n\n            assertTrue(!as\n                    .scan(\n                            \"<EMBED SRC=\\\"data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\\\" type=\\\"image/svg+xml\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\",\n                            policy, AntiSamy.DOM).getCleanHTML().contains(\"<embed\"));\n            assertTrue(!as\n                    .scan(\n                            \"<EMBED SRC=\\\"data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\\\" type=\\\"image/svg+xml\\\" AllowScriptAccess=\\\"always\\\"></EMBED>\",\n                            policy, AntiSamy.SAX).getCleanHTML().contains(\"<embed\"));\n\n            assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" '' SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<SCRIPT a=\\\">\\\" '' SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as.scan(\"<SCRIPT a=`>` SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<SCRIPT a=`>` SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as.scan(\"<SCRIPT a=\\\">'>\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<SCRIPT a=\\\">'>\\\" SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as.scan(\"<SCRIPT>document.write(\\\"<SCRI\\\");</SCRIPT>PT SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"script\"));\n            assertTrue(!as.scan(\"<SCRIPT>document.write(\\\"<SCRI\\\");</SCRIPT>PT SRC=\\\"http://ha.ckers.org/xss.js\\\"></SCRIPT>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"script\"));\n\n            assertTrue(!as.scan(\"<SCRIPT SRC=http://ha.ckers.org/xss.js\", policy, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n            assertTrue(!as.scan(\"<SCRIPT SRC=http://ha.ckers.org/xss.js\", policy, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n\n            assertTrue(!as\n                    .scan(\n                            \"<div/style=&#92&#45&#92&#109&#111&#92&#122&#92&#45&#98&#92&#105&#92&#110&#100&#92&#105&#110&#92&#103:&#92&#117&#114&#108&#40&#47&#47&#98&#117&#115&#105&#110&#101&#115&#115&#92&#105&#92&#110&#102&#111&#46&#99&#111&#46&#117&#107&#92&#47&#108&#97&#98&#115&#92&#47&#120&#98&#108&#92&#47&#120&#98&#108&#92&#46&#120&#109&#108&#92&#35&#120&#115&#115&#41&>\",\n                            policy, AntiSamy.DOM).getCleanHTML().contains(\"style\"));\n            assertTrue(!as\n                    .scan(\n                            \"<div/style=&#92&#45&#92&#109&#111&#92&#122&#92&#45&#98&#92&#105&#92&#110&#100&#92&#105&#110&#92&#103:&#92&#117&#114&#108&#40&#47&#47&#98&#117&#115&#105&#110&#101&#115&#115&#92&#105&#92&#110&#102&#111&#46&#99&#111&#46&#117&#107&#92&#47&#108&#97&#98&#115&#92&#47&#120&#98&#108&#92&#47&#120&#98&#108&#92&#46&#120&#109&#108&#92&#35&#120&#115&#115&#41&>\",\n                            policy, AntiSamy.SAX).getCleanHTML().contains(\"style\"));\n\n            assertTrue(!as.scan(\"<a href='aim: &c:\\\\windows\\\\system32\\\\calc.exe' ini='C:\\\\Documents and Settings\\\\All Users\\\\Start Menu\\\\Programs\\\\Startup\\\\pwnd.bat'>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"aim.exe\"));\n            assertTrue(!as.scan(\"<a href='aim: &c:\\\\windows\\\\system32\\\\calc.exe' ini='C:\\\\Documents and Settings\\\\All Users\\\\Start Menu\\\\Programs\\\\Startup\\\\pwnd.bat'>\", policy, AntiSamy.SAX)\n                    .getCleanHTML().contains(\"aim.exe\"));\n\n            assertTrue(!as.scan(\"<!--\\n<A href=\\n- --><a href=javascript:alert:document.domain>test-->\", policy, AntiSamy.DOM).getCleanHTML().contains(\"javascript\"));\n            assertTrue(!as.scan(\"<!--\\n<A href=\\n- --><a href=javascript:alert:document.domain>test-->\", policy, AntiSamy.SAX).getCleanHTML().contains(\"javascript\"));\n\n            assertTrue(!as.scan(\"<a></a style=\\\"\\\"xx:expr/**/ession(document.appendChild(document.createElement('script')).src='http://h4k.in/i.js')\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"document\"));\n            assertTrue(!as.scan(\"<a></a style=\\\"\\\"xx:expr/**/ession(document.appendChild(document.createElement('script')).src='http://h4k.in/i.js')\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"document\"));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Caught exception in testHrefSrcAttacks(): \" + e.getMessage());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          202,
          325
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "cssAttacks",
        "signature": "void cssAttacks()",
        "lines_hint_csv": [
          319,
          333
        ],
        "code": "    public void cssAttacks() {\n\n        try {\n\n            assertTrue(!as.scan(\"<div style=\\\"position:absolute\\\">\", policy, AntiSamy.DOM).getCleanHTML().contains(\"position\"));\n            assertTrue(!as.scan(\"<div style=\\\"position:absolute\\\">\", policy, AntiSamy.SAX).getCleanHTML().contains(\"position\"));\n\n            assertTrue(!as.scan(\"<style>b { position:absolute }</style>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"position\"));\n            assertTrue(!as.scan(\"<style>b { position:absolute }</style>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"position\"));\n\n            assertTrue(!as.scan(\"<div style=\\\"z-index:25\\\">test</div>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"z-index\"));\n            assertTrue(!as.scan(\"<div style=\\\"z-index:25\\\">test</div>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"z-index\"));\n\n            assertTrue(!as.scan(\"<style>z-index:25</style>\", policy, AntiSamy.DOM).getCleanHTML().contains(\"z-index\"));\n            assertTrue(!as.scan(\"<style>z-index:25</style>\", policy, AntiSamy.SAX).getCleanHTML().contains(\"z-index\"));\n\n        } catch (Exception e) {\n            fail(\"Caught exception in testCssAttacks(): \" + e.getMessage());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          332,
          351
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "IllegalXML",
        "signature": "void IllegalXML()",
        "lines_hint_csv": [
          340,
          381
        ],
        "code": "    public void IllegalXML() {\n\n        for (String BASE64_BAD_XML_STRING : BASE64_BAD_XML_STRINGS) {\n\n            try {\n\n                String testStr = new String(Base64.decodeBase64(BASE64_BAD_XML_STRING.getBytes()));\n                as.scan(testStr, policy, AntiSamy.DOM);\n                as.scan(testStr, policy, AntiSamy.SAX);\n\n            } catch (ScanException ex) {\n                // still success!\n\n            } catch (Throwable ex) {\n                ex.printStackTrace();\n                fail(\"Caught unexpected exception in testIllegalXML(): \" + ex.getMessage());\n            }\n        }\n\n        // This fails due to a bug in NekoHTML\n        // try {\n        // assertTrue (\n        // as.scan(\"<a . href=\\\"http://www.test.com\\\">\",policy, AntiSamy.DOM).getCleanHTML().indexOf(\"href\")\n        // != -1 );\n        // } catch (Exception e) {\n        // e.printStackTrace();\n        // fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        // }\n\n        // This fails due to a bug in NekoHTML\n        // try {\n        // assertTrue (\n        // as.scan(\"<a - href=\\\"http://www.test.com\\\">\",policy, AntiSamy.DOM).getCleanHTML().indexOf(\"href\")\n        // != -1 );\n        // } catch (Exception e) {\n        // e.printStackTrace();\n        // fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        // }\n\n        try {\n            assertTrue(as.scan(\"<style>\", policy, AntiSamy.DOM) != null);\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Couldn't parse malformed HTML: \" + e.getMessage());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          358,
          403
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/validator/html/scan/MagicSAXFilter.java",
        "class_name": "MagicSAXFilter",
        "method_name": "startElement",
        "signature": "void startElement(QName,XMLAttributes,Augmentations)",
        "lines_hint_csv": [
          224,
          388
        ],
        "code": "\tpublic void startElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\t// see if we have a policy for this tag.\n        String tagNameLowerCase = element.localpart.toLowerCase();\n        Tag tag = policy.getTagByLowercaseName(tagNameLowerCase);\n\n\t\t/*\n\t\t * Handle the automatic translation of <param> to nested <embed> for IE.\n\t\t * This is only if the \"validateParamAsEmbed\" directive is enabled.\n\t\t */\n\t\tboolean masqueradingParam = false;\n\t\tString embedName = null;\n\t\tString embedValue = null;\n\t\tif (tag == null && isValidateParamAsEmbed && \"param\".equals(tagNameLowerCase)) {\n\t\t\tTag embedPolicy = policy.getEmbedTag();\n\t\t\tif (embedPolicy != null && embedPolicy.isAction( Policy.ACTION_VALIDATE)) {\n\t\t\t\ttag = embedPolicy;// Constants.BASIC_PARAM_TAG_RULE;\n\t\t\t\tmasqueradingParam = true;\n\t\t\t\t// take <param name=x value=y> and turn into\n\t\t\t\t// <embed x=y></embed>\n\t\t\t\tembedName = attributes.getValue(\"name\");\n\t\t\t\tembedValue = attributes.getValue(\"value\");\n\t\t\t\tXMLAttributes masqueradingAttrs = new XMLAttributesImpl();\n\t\t\t\tmasqueradingAttrs.addAttribute(makeSimpleQname(embedName), \"CDATA\", embedValue);\n\t\t\t\tattributes = masqueradingAttrs;\n\t\t\t}\n\t\t}\n\n\t\tXMLAttributes validattributes = new XMLAttributesImpl();\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp || Ops.CSS == topOp) {\n\t\t\t// we are in removal-mode, so remove this tag as well\n\t\t\t// we also remove all child elements of a style element\n\t\t\tthis.operations.push( Ops.REMOVE);\n\t\t} else if ((tag == null && policy.isEncodeUnknownTag()) || (tag != null && tag.isAction( \"encode\" ))) {\n\t\t\tString name = \"<\" + element.localpart + \">\";\n\t\t\tsuper.characters( new XMLString( name.toCharArray(), 0, name.length() ), augs );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag == null) {\n\t\t\taddError( ErrorMessageUtil.ERROR_TAG_NOT_IN_POLICY,\n                      new Object[]{ HTMLEntityEncoder.htmlEntityEncode( element.localpart ) } );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"filter\")) {\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_FILTERED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"validate\")) {\n\n\t\t\tboolean isStyle = \"style\".endsWith(element.localpart);\n\n\t\t\tif (isStyle) {\n\t\t\t\tthis.operations.push(Ops.CSS);\n\t\t\t\tcssContent = new StringBuffer();\n\t\t\t\tcssAttributes = attributes;\n\t\t\t} else {\n\t\t\t\t// validate all attributes, we need to do this now to find out\n\t\t\t\t// how to deal with the element\n\t\t\t\tboolean removeTag = false;\n\t\t\t\tboolean filterTag = false;\n\t\t\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\t\t\tString name = attributes.getQName(i);\n\t\t\t\t\tString value = attributes.getValue(i);\n\t\t\t\t\tString nameLower = name.toLowerCase();\n\t\t\t\t\tAttribute attribute = tag.getAttributeByName(nameLower);\n\t\t\t\t\tif (attribute == null) {\n\t\t\t\t\t\t// no policy defined, perhaps it is a global attribute\n\t\t\t\t\t\tattribute = policy.getGlobalAttributeByName(nameLower);\n\t\t\t\t\t}\n\t\t\t\t\t// boolean isAttributeValid = false;\n\t\t\t\t\tif (\"style\".equalsIgnoreCase(name)) {\n\t\t\t\t\t\tCssScanner styleScanner = makeCssScanner();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tCleanResults cr = styleScanner.scanInlineStyle(value, element.localpart, maxInputSize);\n\t\t\t\t\t\t\tattributes.setValue(i, cr.getCleanHTML());\n\t\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(name), \"CDATA\", cr.getCleanHTML());\n\t\t\t\t\t\t\terrorMessages.addAll(cr.getErrorMessages());\n\t\t\t\t\t\t} catch (ScanException e) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_ATTRIBUTE_MALFORMED, new Object[] {\n\t\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (attribute != null) {\n\t\t\t\t\t\t// validate the values against the policy\n\t\t\t\t\t\tboolean isValid = false;\n                        if (attribute.containsAllowedValue(value.toLowerCase())) {\n                            validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            isValid = true;\n                        }\n\n\n                        if (!isValid) {\n                            isValid = attribute.matchesAllowedExpression(value);\n                            if (isValid) {\n                                validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            }\n                        }\n\n\n                        // if value or regexp matched, attribute is already\n\t\t\t\t\t\t// copied, but what happens if not\n\t\t\t\t\t\tif (!isValid && \"removeTag\".equals(attribute.getOnInvalid())) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID_REMOVED,\n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tremoveTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid && (\"filterTag\".equals(attribute.getOnInvalid()) || masqueradingParam)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_FILTER, \n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID, new Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else { // attribute == null\n\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY, new Object[] {\n\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeTag) {\n\t\t\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t\t\t} else if (filterTag) {\n\t\t\t\t\tthis.operations.push(Ops.FILTER);\n\t\t\t\t} else {\n\n\t\t\t\t\tif (isNofollowAnchors && \"a\".equals(element.localpart)) {\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"rel\"), \"CDATA\", \"nofollow\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\tvalidattributes = new XMLAttributesImpl();\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"name\"), \"CDATA\", embedName);\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"value\"), \"CDATA\", embedValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.operations.push(Ops.KEEP);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag.isAction( \"truncate\")) {\n\t\t\tthis.operations.push(Ops.TRUNCATE);\n\t\t} else {\n\t\t\t// no options left, so the tag will be removed\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_DISALLOWED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t}\n\t\t// now we know exactly what to do, let's do it\n\t\tif ( Ops.TRUNCATE.equals( operations.peek() )) {\n\t\t\t// copy the element, but remove all attributes\n\t\t\tsuper.startElement(element, new XMLAttributesImpl(), augs);\n\t\t} else if ( Ops.KEEP.equals(operations.peek())) {\n\t\t\t// copy the element, but only copy accepted attributes\n\t\t\tsuper.startElement(element, validattributes, augs);\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          224,
          389
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/validator/html/scan/MagicSAXFilter.java",
        "class_name": "MagicSAXFilter",
        "method_name": "startElement",
        "signature": "void startElement(QName,XMLAttributes,Augmentations)",
        "lines_hint_csv": [
          224,
          388
        ],
        "code": "\tpublic void startElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\t// see if we have a policy for this tag.\n        String tagNameLowerCase = element.localpart.toLowerCase();\n        Tag tag = policy.getTagByLowercaseName(tagNameLowerCase);\n\n\t\t/*\n\t\t * Handle the automatic translation of <param> to nested <embed> for IE.\n\t\t * This is only if the \"validateParamAsEmbed\" directive is enabled.\n\t\t */\n\t\tboolean masqueradingParam = false;\n\t\tString embedName = null;\n\t\tString embedValue = null;\n\t\tif (tag == null && isValidateParamAsEmbed && \"param\".equals(tagNameLowerCase)) {\n\t\t\tTag embedPolicy = policy.getEmbedTag();\n\t\t\tif (embedPolicy != null && embedPolicy.isAction( Policy.ACTION_VALIDATE)) {\n\t\t\t\ttag = embedPolicy;// Constants.BASIC_PARAM_TAG_RULE;\n\t\t\t\tmasqueradingParam = true;\n\t\t\t\t// take <param name=x value=y> and turn into\n\t\t\t\t// <embed x=y></embed>\n\t\t\t\tembedName = attributes.getValue(\"name\");\n\t\t\t\tembedValue = attributes.getValue(\"value\");\n\t\t\t\tXMLAttributes masqueradingAttrs = new XMLAttributesImpl();\n\t\t\t\tmasqueradingAttrs.addAttribute(makeSimpleQname(embedName), \"CDATA\", embedValue);\n\t\t\t\tattributes = masqueradingAttrs;\n\t\t\t}\n\t\t}\n\n\t\tXMLAttributes validattributes = new XMLAttributesImpl();\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp || Ops.CSS == topOp) {\n\t\t\t// we are in removal-mode, so remove this tag as well\n\t\t\t// we also remove all child elements of a style element\n\t\t\tthis.operations.push( Ops.REMOVE);\n\t\t} else if ((tag == null && policy.isEncodeUnknownTag()) || (tag != null && tag.isAction( \"encode\" ))) {\n\t\t\tString name = \"<\" + element.localpart + \">\";\n\t\t\tsuper.characters( new XMLString( name.toCharArray(), 0, name.length() ), augs );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag == null) {\n\t\t\taddError( ErrorMessageUtil.ERROR_TAG_NOT_IN_POLICY,\n                      new Object[]{ HTMLEntityEncoder.htmlEntityEncode( element.localpart ) } );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"filter\")) {\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_FILTERED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"validate\")) {\n\n\t\t\tboolean isStyle = \"style\".endsWith(element.localpart);\n\n\t\t\tif (isStyle) {\n\t\t\t\tthis.operations.push(Ops.CSS);\n\t\t\t\tcssContent = new StringBuffer();\n\t\t\t\tcssAttributes = attributes;\n\t\t\t} else {\n\t\t\t\t// validate all attributes, we need to do this now to find out\n\t\t\t\t// how to deal with the element\n\t\t\t\tboolean removeTag = false;\n\t\t\t\tboolean filterTag = false;\n\t\t\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\t\t\tString name = attributes.getQName(i);\n\t\t\t\t\tString value = attributes.getValue(i);\n\t\t\t\t\tString nameLower = name.toLowerCase();\n\t\t\t\t\tAttribute attribute = tag.getAttributeByName(nameLower);\n\t\t\t\t\tif (attribute == null) {\n\t\t\t\t\t\t// no policy defined, perhaps it is a global attribute\n\t\t\t\t\t\tattribute = policy.getGlobalAttributeByName(nameLower);\n\t\t\t\t\t}\n\t\t\t\t\t// boolean isAttributeValid = false;\n\t\t\t\t\tif (\"style\".equalsIgnoreCase(name)) {\n\t\t\t\t\t\tCssScanner styleScanner = makeCssScanner();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tCleanResults cr = styleScanner.scanInlineStyle(value, element.localpart, maxInputSize);\n\t\t\t\t\t\t\tattributes.setValue(i, cr.getCleanHTML());\n\t\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(name), \"CDATA\", cr.getCleanHTML());\n\t\t\t\t\t\t\terrorMessages.addAll(cr.getErrorMessages());\n\t\t\t\t\t\t} catch (ScanException e) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_ATTRIBUTE_MALFORMED, new Object[] {\n\t\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (attribute != null) {\n\t\t\t\t\t\t// validate the values against the policy\n\t\t\t\t\t\tboolean isValid = false;\n                        if (attribute.containsAllowedValue(value.toLowerCase())) {\n                            validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            isValid = true;\n                        }\n\n\n                        if (!isValid) {\n                            isValid = attribute.matchesAllowedExpression(value);\n                            if (isValid) {\n                                validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            }\n                        }\n\n\n                        // if value or regexp matched, attribute is already\n\t\t\t\t\t\t// copied, but what happens if not\n\t\t\t\t\t\tif (!isValid && \"removeTag\".equals(attribute.getOnInvalid())) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID_REMOVED,\n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tremoveTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid && (\"filterTag\".equals(attribute.getOnInvalid()) || masqueradingParam)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_FILTER, \n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID, new Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else { // attribute == null\n\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY, new Object[] {\n\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeTag) {\n\t\t\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t\t\t} else if (filterTag) {\n\t\t\t\t\tthis.operations.push(Ops.FILTER);\n\t\t\t\t} else {\n\n\t\t\t\t\tif (isNofollowAnchors && \"a\".equals(element.localpart)) {\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"rel\"), \"CDATA\", \"nofollow\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\tvalidattributes = new XMLAttributesImpl();\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"name\"), \"CDATA\", embedName);\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"value\"), \"CDATA\", embedValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.operations.push(Ops.KEEP);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag.isAction( \"truncate\")) {\n\t\t\tthis.operations.push(Ops.TRUNCATE);\n\t\t} else {\n\t\t\t// no options left, so the tag will be removed\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_DISALLOWED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t}\n\t\t// now we know exactly what to do, let's do it\n\t\tif ( Ops.TRUNCATE.equals( operations.peek() )) {\n\t\t\t// copy the element, but remove all attributes\n\t\t\tsuper.startElement(element, new XMLAttributesImpl(), augs);\n\t\t} else if ( Ops.KEEP.equals(operations.peek())) {\n\t\t\t// copy the element, but only copy accepted attributes\n\t\t\tsuper.startElement(element, validattributes, augs);\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          224,
          389
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "testIssue2",
        "signature": "void testIssue2()",
        "lines_hint_csv": [
          1238,
          1242
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2017-14735",
    "project_slug": "nahsra__antisamy_CVE-2017-14735_1.5.6",
    "buggy_commit_id": "1369d4c904e1f021d3616580daf9e1d8e43e0ddb",
    "github_url": "https://github.com/nahsra/antisamy",
    "nvd_metadata": {
      "description": "OWASP AntiSamy before 1.5.7 allows XSS via HTML5 entities, as demonstrated by use of &colon; to construct a javascript: URL.",
      "published_date": "2017-09-25T21:29:01.147",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/owasp/validator/html/Policy.java",
        "class_name": "Policy",
        "method_name": "parseRequireClosingTags",
        "signature": "void parseRequireClosingTags(Element,List)",
        "lines_hint_csv": [
          606,
          617
        ],
        "code": "  private static void parseRequireClosingTags(\n      Element requireClosingTagsListNode, List<String> requireClosingTags) {\n    if (requireClosingTagsListNode != null) {\n      for (Element literalNode :\n          getGrandChildrenByTagName(requireClosingTagsListNode, \"literal-list\", \"literal\")) {\n\n        String value = getAttributeValue(literalNode, \"value\");\n        if (value != null && value.length() > 0) {\n          requireClosingTags.add(value);\n        }\n      }\n    } else requireClosingTags.addAll(Constants.defaultRequireClosingTags);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          606,
          618
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/validator/html/Policy.java",
        "class_name": "Policy",
        "method_name": "parseAllowedEmptyTags",
        "signature": "void parseAllowedEmptyTags(Element,List)",
        "lines_hint_csv": [
          586,
          597
        ],
        "code": "  private static void parseAllowedEmptyTags(\n      Element allowedEmptyTagsListNode, List<String> allowedEmptyTags) {\n    if (allowedEmptyTagsListNode != null) {\n      for (Element literalNode :\n          getGrandChildrenByTagName(allowedEmptyTagsListNode, \"literal-list\", \"literal\")) {\n\n        String value = getAttributeValue(literalNode, \"value\");\n        if (value != null && value.length() > 0) {\n          allowedEmptyTags.add(value);\n        }\n      }\n    } else allowedEmptyTags.addAll(Constants.defaultAllowedEmptyTags);\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          586,
          598
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/validator/html/Policy.java",
        "class_name": "Policy",
        "method_name": "parseGlobalAttributes",
        "signature": "void parseGlobalAttributes(Element,Map,Map)",
        "lines_hint_csv": [
          628,
          641
        ],
        "code": "  private static void parseGlobalAttributes(\n      Element root,\n      Map<String, Attribute> globalAttributes1,\n      Map<String, Attribute> commonAttributes)\n      throws PolicyException {\n    for (Element ele : getByTagName(root, \"attribute\")) {\n\n      String name = getAttributeValue(ele, \"name\");\n      Attribute toAdd = commonAttributes.get(name.toLowerCase());\n\n      if (toAdd != null) globalAttributes1.put(name.toLowerCase(), toAdd);\n      else\n        throw new PolicyException(\n            \"Global attribute '\" + name + \"' was not defined in <common-attributes>\");\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          628,
          643
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/validator/html/Policy.java",
        "class_name": "Policy",
        "method_name": "parseCommonAttributes",
        "signature": "void parseCommonAttributes(Element,Map,Map)",
        "lines_hint_csv": [
          541,
          562
        ],
        "code": "  private static void parseCommonAttributes(\n      Element root,\n      Map<String, Attribute> commonAttributes1,\n      Map<String, AntiSamyPattern> commonRegularExpressions1) {\n\n    for (Element ele : getByTagName(root, \"attribute\")) {\n      String onInvalid = getAttributeValue(ele, \"onInvalid\");\n      String name = getAttributeValue(ele, \"name\");\n\n      List<Pattern> allowedRegexps = getAllowedRegexps(commonRegularExpressions1, ele);\n      List<String> allowedValues = getAllowedLiterals(ele);\n\n      final String onInvalidStr;\n      if (onInvalid != null && onInvalid.length() > 0) {\n        onInvalidStr = onInvalid;\n      } else onInvalidStr = DEFAULT_ONINVALID;\n\n      String description = getAttributeValue(ele, \"description\");\n      Attribute attribute =\n          new Attribute(\n              getAttributeValue(ele, \"name\"),\n              allowedRegexps,\n              allowedValues,\n              onInvalidStr,\n              description);\n      commonAttributes1.put(name.toLowerCase(), attribute);\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          688,
          715
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/validator/html/scan/AntiSamyDOMScanner.java",
        "class_name": "AntiSamyDOMScanner",
        "method_name": "scan",
        "signature": "public CleanResults scan(String html)",
        "lines_hint_csv": [
          127,
          220
        ],
        "code": "  public CleanResults scan(String html) throws ScanException {\n\n    if (html == null) {\n      throw new ScanException(new NullPointerException(\"Null HTML input\"));\n    }\n\n    errorMessages.clear();\n    int maxInputSize = policy.getMaxInputSize();\n\n    if (maxInputSize < html.length()) {\n      addError(ErrorMessageUtil.ERROR_INPUT_SIZE, new Object[] {html.length(), maxInputSize});\n      throw new ScanException(errorMessages.get(0));\n    }\n\n    isNofollowAnchors = policy.isNofollowAnchors();\n    isNoopenerAndNoreferrerAnchors = policy.isNoopenerAndNoreferrerAnchors();\n    isValidateParamAsEmbed = policy.isValidateParamAsEmbed();\n\n    long startOfScan = System.currentTimeMillis();\n\n    try {\n\n      CachedItem cachedItem;\n      cachedItem = cachedItems.poll();\n      if (cachedItem == null) {\n        cachedItem = new CachedItem();\n      }\n\n      /*\n       * We have to replace any invalid XML characters to prevent NekoHTML\n       * from breaking when it gets passed encodings like %21.\n       */\n\n      html = stripNonValidXMLCharacters(html, cachedItem.invalidXmlCharMatcher);\n\n      /*\n       * First thing we do is call the HTML cleaner (\"NekoHTML\") on it\n       * with the appropriate options. We choose not to omit tags due to\n       * the fallibility of our own listing in the ever changing world of\n       * W3C.\n       */\n\n      DOMFragmentParser parser = cachedItem.getDomFragmentParser();\n\n      try {\n        parser.parse(new InputSource(new StringReader(html)), dom);\n      } catch (Exception e) {\n        throw new ScanException(e);\n      }\n\n      processChildren(dom, 0);\n\n      /*\n       * Serialize the output and then return the resulting DOM object and\n       * its string representation.\n       */\n\n      final String trimmedHtml = html;\n\n      StringWriter out = new StringWriter();\n\n      @SuppressWarnings(\"deprecation\")\n      org.apache.xml.serialize.OutputFormat format = getOutputFormat();\n\n      //noinspection deprecation\n      org.apache.xml.serialize.HTMLSerializer serializer = getHTMLSerializer(out, format);\n      serializer.serialize(dom);\n\n      /*\n       * Get the String out of the StringWriter and rip out the XML\n       * declaration if the Policy says we should.\n       */\n      final String trimmed = trim(trimmedHtml, out.getBuffer().toString());\n\n      Callable<String> cleanHtml =\n          new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n              return trimmed;\n            }\n          };\n\n      /*\n       * Return the DOM object as well as string HTML.\n       */\n      results = new CleanResults(startOfScan, cleanHtml, dom, errorMessages);\n\n      cachedItems.add(cachedItem);\n      return results;\n\n    } catch (SAXException | IOException e) {\n      throw new ScanException(e);\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          127,
          220
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/validator/html/scan/AntiSamySAXScanner.java",
        "class_name": "AntiSamySAXScanner",
        "method_name": "scan",
        "signature": "CleanResults scan(Reader reader, Writer writer)",
        "lines_hint_csv": [
          204,
          244
        ],
        "code": "  public CleanResults scan(Reader reader, Writer writer) throws ScanException {\n    try {\n\n      CachedItem candidateCachedItem = cachedItems.poll();\n      if (candidateCachedItem == null) {\n        candidateCachedItem =\n            new CachedItem(getNewTransformer(), getParser(), new MagicSAXFilter(messages));\n      }\n\n      final CachedItem cachedItem = candidateCachedItem;\n\n      SAXParser parser = cachedItem.saxParser;\n      cachedItem.magicSAXFilter.reset(policy);\n\n      long startOfScan = System.currentTimeMillis();\n\n      final SAXSource source = new SAXSource(parser, new InputSource(reader));\n\n      final Transformer transformer = cachedItem.transformer;\n      boolean formatOutput = policy.isFormatOutput();\n      boolean omitXml = policy.isOmitXmlDeclaration();\n\n      transformer.setOutputProperty(OutputKeys.INDENT, formatOutput ? \"yes\" : \"no\");\n      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, omitXml ? \"yes\" : \"no\");\n      transformer.setOutputProperty(OutputKeys.METHOD, \"html\");\n\n      //noinspection deprecation\n      final org.apache.xml.serialize.OutputFormat format = getOutputFormat();\n      //noinspection deprecation\n      final org.apache.xml.serialize.HTMLSerializer serializer = getHTMLSerializer(writer, format);\n\n      transformer.transform(source, new SAXResult(serializer));\n      errorMessages.clear();\n      errorMessages.addAll(cachedItem.magicSAXFilter.getErrorMessages());\n      cachedItems.add(cachedItem);\n      return new CleanResults(startOfScan, (String) null, null, errorMessages);\n\n    } catch (Exception e) {\n      throw new ScanException(e);\n    }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          204,
          244
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "issue41",
        "signature": "void issue41()",
        "lines_hint_csv": [
          1096,
          1195
        ],
        "code": "  public void issue41() throws ScanException, PolicyException {\n    /* issue #41 - comment handling */\n\n    Policy revised = policy.cloneWithDirective(Policy.PRESERVE_SPACE, \"true\");\n\n    policy.cloneWithDirective(Policy.PRESERVE_COMMENTS, \"false\");\n\n    assertEquals(\"text \", as.scan(\"text <!-- comment -->\", revised, AntiSamy.DOM).getCleanHTML());\n    assertEquals(\"text \", as.scan(\"text <!-- comment -->\", revised, AntiSamy.SAX).getCleanHTML());\n\n    Policy revised2 =\n        policy\n            .cloneWithDirective(Policy.PRESERVE_COMMENTS, \"true\")\n            .cloneWithDirective(Policy.PRESERVE_SPACE, \"true\")\n            .cloneWithDirective(Policy.FORMAT_OUTPUT, \"false\");\n\n    /*\n     * These make sure the regular comments are kept alive and that\n     * conditional comments are ripped out.\n     */\n    assertEquals(\n        \"<div>text <!-- comment --></div>\",\n        as.scan(\"<div>text <!-- comment --></div>\", revised2, AntiSamy.DOM).getCleanHTML());\n    assertEquals(\n        \"<div>text <!-- comment --></div>\",\n        as.scan(\"<div>text <!-- comment --></div>\", revised2, AntiSamy.SAX).getCleanHTML());\n\n    assertEquals(\n        \"<div>text <!-- comment --></div>\",\n        as.scan(\"<div>text <!--[if IE]> comment <[endif]--></div>\", revised2, AntiSamy.DOM)\n            .getCleanHTML());\n    assertEquals(\n        \"<div>text <!-- comment --></div>\",\n        as.scan(\"<div>text <!--[if IE]> comment <[endif]--></div>\", revised2, AntiSamy.SAX)\n            .getCleanHTML());\n\n    /*\n     * Check to see how nested conditional comments are handled. This is\n     * not very clean but the main goal is to avoid any tags. Not sure\n     * on encodings allowed in comments.\n     */\n    String input = \"<div>text <!--[if IE]> <!--[if gte 6]> comment <[endif]--><[endif]--></div>\";\n    String expected = \"<div>text <!-- <!-- comment -->&lt;[endif]--&gt;</div>\";\n    String output = as.scan(input, revised2, AntiSamy.DOM).getCleanHTML();\n    assertEquals(expected, output);\n\n    input = \"<div>text <!--[if IE]> <!--[if gte 6]> comment <[endif]--><[endif]--></div>\";\n    expected = \"<div>text <!-- <!-- comment -->&lt;[endif]--&gt;</div>\";\n    output = as.scan(input, revised2, AntiSamy.SAX).getCleanHTML();\n\n    assertEquals(expected, output);\n\n    /*\n     * Regular comment nested inside conditional comment. Test makes sure.\n     */\n    assertEquals(\n        \"<div>text <!-- <!-- IE specific --> comment &lt;[endif]--&gt;</div>\",\n        as.scan(\n                \"<div>text <!--[if IE]> <!-- IE specific --> comment <[endif]--></div>\",\n                revised2,\n                AntiSamy.DOM)\n            .getCleanHTML());\n\n    /*\n     * These play with whitespace and have invalid comment syntax.\n     */\n    assertEquals(\n        \"<div>text <!-- \\ncomment --></div>\",\n        as.scan(\n                \"<div>text <!-- [ if lte 6 ]>\\ncomment <[ endif\\n]--></div>\",\n                revised2,\n                AntiSamy.DOM)\n            .getCleanHTML());\n    assertEquals(\n        \"<div>text  comment </div>\",\n        as.scan(\"<div>text <![if !IE]> comment <![endif]></div>\", revised2, AntiSamy.DOM)\n            .getCleanHTML());\n    assertEquals(\n        \"<div>text  comment </div>\",\n        as.scan(\"<div>text <![ if !IE]> comment <![endif]></div>\", revised2, AntiSamy.DOM)\n            .getCleanHTML());\n\n    String attack = \"[if lte 8]<script>\";\n    String spacer = \"<![if IE]>\";\n\n    StringBuilder sb = new StringBuilder();\n\n    sb.append(\"<div>text<!\");\n\n    for (int i = 0; i < attack.length(); i++) {\n      sb.append(attack.charAt(i));\n      sb.append(spacer);\n    }\n\n    sb.append(\"<![endif]>\");\n\n    String s = sb.toString();\n\n    assertTrue(!as.scan(s, revised2, AntiSamy.DOM).getCleanHTML().contains(\"<script\"));\n    assertTrue(!as.scan(s, revised2, AntiSamy.SAX).getCleanHTML().contains(\"<script\"));\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1096,
          1196
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-10077",
    "project_slug": "apache__jspwiki_CVE-2019-10077_2.11.0.M3",
    "buggy_commit_id": "2ea7973c1c7fdf2771a9743dbc8ecb27c9bb162d",
    "github_url": "https://github.com/apache/jspwiki",
    "nvd_metadata": {
      "description": "A carefully crafted InterWiki link could trigger an XSS vulnerability on Apache JSPWiki 2.9.0 to 2.11.0.M3, which could lead to session hijacking.",
      "published_date": "2019-05-20T21:29:00.817",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java",
        "class_name": "JSPWikiMarkupParser",
        "method_name": "handleHyperlinks",
        "signature": "Element handleHyperlinks(String,int)",
        "lines_hint_csv": [
          1189,
          1398
        ],
        "code": "    private Element handleHyperlinks( String linktext, int pos )\n    {\n        ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );\n\n        StringBuilder sb = new StringBuilder(linktext.length()+80);\n\n        if( m_linkParsingOperations.isAccessRule( linktext ) )\n        {\n            return handleAccessRule( linktext );\n        }\n\n        if( m_linkParsingOperations.isMetadata( linktext ) )\n        {\n            return handleMetadata( linktext );\n        }\n\n        if( m_linkParsingOperations.isPluginLink( linktext ) )\n        {\n            try\n            {\n                PluginContent pluginContent = PluginContent.parsePluginLine( m_context, linktext, pos );\n                //\n                //  This might sometimes fail, especially if there is something which looks\n                //  like a plugin invocation but is really not.\n                //\n                if( pluginContent != null )\n                {\n                    addElement( pluginContent );\n\n                    pluginContent.executeParse( m_context );\n                }\n            }\n            catch( PluginException e )\n            {\n                log.info( m_context.getRealPage().getWiki() + \" : \" + m_context.getRealPage().getName() + \" - Failed to insert plugin: \" + e.getMessage() );\n                //log.info( \"Root cause:\",e.getRootThrowable() );\n                if( !m_wysiwygEditorMode )\n                {\n                    ResourceBundle rbPlugin = Preferences.getBundle( m_context, WikiPlugin.CORE_PLUGINS_RESOURCEBUNDLE );\n                    return addElement( makeError( MessageFormat.format( rbPlugin.getString( \"plugin.error.insertionfailed\" ),\n                    \t\t                                            m_context.getRealPage().getWiki(),\n                    \t\t                                            m_context.getRealPage().getName(),\n                    \t\t                                            e.getMessage() ) ) );\n                }\n            }\n\n            return m_currentElement;\n        }\n\n        try\n        {\n            LinkParser.Link link = m_linkParser.parse(linktext);\n            linktext       = link.getText();\n            String linkref = link.getReference();\n\n            //\n            //  Yes, we now have the components separated.\n            //  linktext = the text the link should have\n            //  linkref  = the url or page name.\n            //\n            //  In many cases these are the same.  [linktext|linkref].\n            //\n            if( m_linkParsingOperations.isVariableLink( linktext ) )\n            {\n                Content el = new VariableContent(linktext);\n\n                addElement( el );\n            }\n            else if( m_linkParsingOperations.isExternalLink( linkref ) )\n            {\n                // It's an external link, out of this Wiki\n\n                callMutatorChain( m_externalLinkMutatorChain, linkref );\n\n                if( m_linkParsingOperations.isImageLink( linkref ) )\n                {\n                    handleImageLink( linkref, linktext, link.hasReference() );\n                }\n                else\n                {\n                    makeLink( EXTERNAL, linkref, linktext, null, link.getAttributes() );\n                    addElement( outlinkImage() );\n                }\n            }\n            else if( link.isInterwikiLink() )\n            {\n                // It's an interwiki link\n                // InterWiki links also get added to external link chain\n                // after the links have been resolved.\n\n                // FIXME: There is an interesting issue here:  We probably should\n                //        URLEncode the wikiPage, but we can't since some of the\n                //        Wikis use slashes (/), which won't survive URLEncoding.\n                //        Besides, we don't know which character set the other Wiki\n                //        is using, so you'll have to write the entire name as it appears\n                //        in the URL.  Bugger.\n\n                String extWiki  = link.getExternalWiki();\n                String wikiPage = link.getExternalWikiPage();\n\n                if( m_wysiwygEditorMode )\n                {\n                    makeLink( INTERWIKI, extWiki + \":\" + wikiPage, linktext, null, link.getAttributes() );\n                }\n                else\n                {\n                    String urlReference = m_engine.getInterWikiURL( extWiki );\n\n                    if( urlReference != null )\n                    {\n                        urlReference = TextUtil.replaceString( urlReference, \"%s\", wikiPage );\n                        urlReference = callMutatorChain( m_externalLinkMutatorChain, urlReference );\n\n                        if( m_linkParsingOperations.isImageLink(urlReference) )\n                        {\n                            handleImageLink( urlReference, linktext, link.hasReference() );\n                        }\n                        else\n                        {\n                            makeLink( INTERWIKI, urlReference, linktext, null, link.getAttributes() );\n                        }\n\n                        if( m_linkParsingOperations.isExternalLink(urlReference) )\n                        {\n                            addElement( outlinkImage() );\n                        }\n                    }\n                    else\n                    {\n                        Object[] args = { extWiki };\n                        addElement( makeError( MessageFormat.format( rb.getString( \"markupparser.error.nointerwikiref\" ), args ) ) );\n                    }\n                }\n            }\n            else if( linkref.startsWith(\"#\") )\n            {\n                // It defines a local footnote\n                makeLink( LOCAL, linkref, linktext, null, link.getAttributes() );\n            }\n            else if( TextUtil.isNumber( linkref ) )\n            {\n                // It defines a reference to a local footnote\n                makeLink( LOCALREF, linkref, linktext, null, link.getAttributes() );\n            }\n            else\n            {\n                int hashMark = -1;\n\n                //\n                //  Internal wiki link, but is it an attachment link?\n                //\n                String attachment = m_engine.getAttachmentManager().getAttachmentInfoName( m_context, linkref );\n                if( attachment != null )\n                {\n                    callMutatorChain( m_attachmentLinkMutatorChain, attachment );\n\n                    if( m_linkParsingOperations.isImageLink( linkref ) )\n                    {\n                        attachment = m_context.getURL( WikiContext.ATTACH, attachment );\n                        sb.append( handleImageLink( attachment, linktext, link.hasReference() ) );\n                    }\n                    else\n                    {\n                        makeLink( ATTACHMENT, attachment, linktext, null, link.getAttributes() );\n                    }\n                }\n                else if( (hashMark = linkref.indexOf('#')) != -1 )\n                {\n                    // It's an internal Wiki link, but to a named section\n\n                    String namedSection = linkref.substring( hashMark+1 );\n                    linkref = linkref.substring( 0, hashMark );\n\n                    linkref = MarkupParser.cleanLink( linkref );\n\n                    callMutatorChain( m_localLinkMutatorChain, linkref );\n\n                    String matchedLink = m_linkParsingOperations.linkIfExists( linkref );\n                    if( matchedLink != null ) {\n                        String sectref = \"section-\"+m_engine.encodeName(matchedLink+\"-\"+wikifyLink(namedSection));\n                        sectref = sectref.replace('%', '_');\n                        makeLink( READ, matchedLink, linktext, sectref, link.getAttributes() );\n                    } else {\n                        makeLink( EDIT, linkref, linktext, null, link.getAttributes() );\n                    }\n                }\n                else\n                {\n                    // It's an internal Wiki link\n                    linkref = MarkupParser.cleanLink( linkref );\n\n                    callMutatorChain( m_localLinkMutatorChain, linkref );\n\n                    String matchedLink = m_linkParsingOperations.linkIfExists( linkref );\n                    if( matchedLink != null ) {\n                        makeLink( READ, matchedLink, linktext, null, link.getAttributes() );\n                    } else {\n                        makeLink( EDIT, linkref, linktext, null, link.getAttributes() );\n                    }\n                }\n            }\n        }\n        catch( ParseException e )\n        {\n            log.info(\"Parser failure: \",e);\n            Object[] args = { e.getMessage() };\n            addElement( makeError( MessageFormat.format( rb.getString( \"markupparser.error.parserfailure\" ), args ) ) );\n        }\n\n        return m_currentElement;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1189,
          1399
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/parser/JSPWikiMarkupParser.java",
        "class_name": "JSPWikiMarkupParser",
        "method_name": "handleDiv",
        "signature": "Element handleDiv(boolean)",
        "lines_hint_csv": [
          2031,
          2171
        ],
        "code": "    private Element handleDiv( boolean newLine )\n        throws IOException\n    {\n        int ch = nextToken();\n        Element el = null;\n\n        if( ch == '%' )\n        {\n            String style = null;\n            String clazz = null;\n\n            ch = nextToken();\n\n            //\n            //  Style or class?\n            //\n            if( ch == '(' )\n            {\n                style = readBraceContent('(',')');\n            }\n            else if( Character.isLetter( (char) ch ) )\n            {\n                pushBack( ch );\n                clazz = readUntil( \" \\t\\n\\r\" );\n                //Note: ref.https://www.w3.org/TR/CSS21/syndata.html#characters\n                //CSS Classnames can contain only the characters [a-zA-Z0-9] and\n                //ISO 10646 characters U+00A0 and higher, plus the \"-\" and the \"_\".\n                //They cannot start with a digit, two hyphens, or a hyphen followed by a digit.\n\n                //(1) replace '.' by spaces, allowing multiple classnames on a div or span\n                //(2) remove any invalid character\n                if( clazz != null){\n\n                    clazz = clazz.replace('.', ' ')\n                                 .replaceAll(\"[^\\\\s-_\\\\w\\\\x200-\\\\x377]+\",\"\");\n\n                }\n                ch = nextToken();\n\n                //\n                //  Pop out only spaces, so that the upcoming EOL check does not check the\n                //  next line.\n                //\n                if( ch == '\\n' || ch == '\\r' )\n                {\n                    pushBack(ch);\n                }\n            }\n            else\n            {\n                //\n                // Anything else stops.\n                //\n\n                pushBack(ch);\n\n                try\n                {\n                    Boolean isSpan = m_styleStack.pop();\n\n                    if( isSpan == null )\n                    {\n                        // Fail quietly\n                    }\n                    else if( isSpan.booleanValue() )\n                    {\n                        el = popElement( \"span\" );\n                    }\n                    else\n                    {\n                        el = popElement( \"div\" );\n                    }\n                }\n                catch( EmptyStackException e )\n                {\n                    log.debug(\"Page '\"+m_context.getName()+\"' closes a %%-block that has not been opened.\");\n                    return m_currentElement;\n                }\n\n                return el;\n            }\n\n            //\n            //  Check if there is an attempt to do something nasty\n            //\n\n            try\n            {\n                style = StringEscapeUtils.unescapeHtml(style);\n                if( style != null && style.indexOf(\"javascript:\") != -1 )\n                {\n                    log.debug(\"Attempt to output javascript within CSS:\"+style);\n                    ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );\n                    return addElement( makeError( rb.getString( \"markupparser.error.javascriptattempt\" ) ) );\n                }\n            }\n            catch( NumberFormatException e )\n            {\n                //\n                //  If there are unknown entities, we don't want the parser to stop.\n                //\n                ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );\n                String msg = MessageFormat.format( rb.getString( \"markupparser.error.parserfailure\"), e.getMessage() );\n                return addElement( makeError( msg ) );\n            }\n\n            //\n            //  Decide if we should open a div or a span?\n            //\n            String eol = peekAheadLine();\n\n            if( eol.trim().length() > 0 )\n            {\n                // There is stuff after the class\n\n                el = new Element(\"span\");\n\n                m_styleStack.push( Boolean.TRUE );\n            }\n            else\n            {\n                startBlockLevel();\n                el = new Element(\"div\");\n                m_styleStack.push( Boolean.FALSE );\n            }\n\n            if( style != null ) el.setAttribute(\"style\", style);\n            if( clazz != null ) el.setAttribute(\"class\", clazz);\n            el = pushElement( el );\n\n            return el;\n        }\n\n        pushBack(ch);\n\n        return el;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          2031,
          2167
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-10076",
    "project_slug": "apache__jspwiki_CVE-2019-10076_2.11.0.M3",
    "buggy_commit_id": "2ea7973c1c7fdf2771a9743dbc8ecb27c9bb162d",
    "github_url": "https://github.com/apache/jspwiki",
    "nvd_metadata": {
      "description": "A carefully crafted malicious attachment could trigger an XSS vulnerability on Apache JSPWiki 2.9.0 to 2.11.0.M3, which could lead to session hijacking.",
      "published_date": "2019-05-20T21:29:00.753",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/tags/LinkToTag.java",
        "class_name": "LinkToTag",
        "method_name": "doWikiStartTag",
        "signature": "int doWikiStartTag()",
        "lines_hint_csv": [
          80,
          134
        ],
        "code": "    public int doWikiStartTag()\n        throws IOException\n    {\n        String     pageName = m_pageName;\n        boolean    isattachment = false;\n\n        if( m_pageName == null )\n        {\n            WikiPage p = m_wikiContext.getPage();\n\n            if( p != null )\n            {\n                pageName = p.getName();\n\n                isattachment = p instanceof Attachment;\n            }\n            else\n            {\n                return SKIP_BODY;\n            }\n        }\n\n        JspWriter out = pageContext.getOut();\n        String url;\n        String linkclass;\n\n        if( isattachment )\n        {\n            url = m_wikiContext.getURL(WikiContext.ATTACH,pageName,\n                                       (getVersion() != null) ? \"version=\"+getVersion() : null );\n            linkclass = \"attachment\";\n        }\n        else\n        {\n        \tStringBuilder params = new StringBuilder();\n            if( getVersion() != null ) params.append( \"version=\"+getVersion() );\n            if( getTemplate() != null ) params.append( (params.length()>0?\"&amp;\":\"\") + \"skin=\"+getTemplate() );\n\n            url = m_wikiContext.getURL( WikiContext.VIEW, pageName,\n                                        params.toString() );\n            linkclass = \"wikipage\";\n        }\n\n        switch( m_format )\n        {\n          case ANCHOR:\n            out.print(\"<a class=\\\"\"+linkclass+\"\\\" href=\\\"\"+url+\"\\\" accesskey=\\\"\" \n                          + m_accesskey + \"\\\" title=\\\"\" + m_title + \"\\\">\");\n            break;\n          case URL:\n            out.print( url );\n            break;\n        }\n\n        return EVAL_BODY_INCLUDE;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          80,
          135
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/tags/LinkToTag.java",
        "class_name": "LinkToTag",
        "method_name": "initTag",
        "signature": "void initTag()",
        "lines_hint_csv": [
          53,
          56
        ],
        "code": "    public void initTag()\n    {\n        super.initTag();\n        m_version = null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          53,
          57
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/tags/LinkToTag.java",
        "class_name": "LinkToTag",
        "method_name": "setAccesskey",
        "signature": "void setAccesskey(String)",
        "lines_hint_csv": [
          74,
          76
        ],
        "code": "    public void setAccesskey( String access )\n    {\n        m_accesskey = access;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          74,
          77
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-10078",
    "project_slug": "apache__jspwiki_CVE-2019-10078_2.11.0.M3",
    "buggy_commit_id": "2ea7973c1c7fdf2771a9743dbc8ecb27c9bb162d",
    "github_url": "https://github.com/apache/jspwiki",
    "nvd_metadata": {
      "description": "A carefully crafted plugin link invocation could trigger an XSS vulnerability on Apache JSPWiki 2.9.0 to 2.11.0.M3, which could lead to session hijacking. Initial reporting indicated ReferredPagesPlugin, but further analysis showed that multiple plugins were vulnerable.",
      "published_date": "2019-05-20T21:29:00.877",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/plugin/ReferredPagesPlugin.java",
        "class_name": "ReferredPagesPlugin",
        "method_name": "handleLinks",
        "signature": "void handleLinks(WikiContext,Collection,int,String)",
        "lines_hint_csv": [
          194,
          252
        ],
        "code": "    private void handleLinks(WikiContext context,Collection<String> links, int depth, String pagename) {\n        boolean isUL = false;\n        HashSet<String> localLinkSet = new HashSet<>();  // needed to skip multiple\n        // links to the same page\n        localLinkSet.add(pagename);\n\n        ArrayList<String> allLinks = new ArrayList<>();\n\n        if( links != null )\n            allLinks.addAll( links );\n\n        if( m_formatSort ) context.getEngine().getPageManager().getPageSorter().sort( allLinks );\n\n        for( Iterator<String> i = allLinks.iterator(); i.hasNext(); ) {\n            String link = i.next() ;\n\n            if( localLinkSet.contains( link ) ) continue; // skip multiple links to the same page\n            localLinkSet.add( link );\n\n            if( !m_engine.pageExists( link ) ) continue; // hide links to non existing pages\n\n            if(  m_matcher.matches( link , m_excludePattern ) ) continue;\n            if( !m_matcher.matches( link , m_includePattern ) ) continue;\n\n            if( m_exists.contains( link ) ) {\n                if( !m_formatCompact ) {\n                    if( !isUL ) {\n                        isUL = true;\n                        m_result.append(\"<ul>\\n\");\n                    }\n\n                    //See https://www.w3.org/wiki/HTML_lists  for proper nesting of UL and LI\n                    m_result.append(\"<li> \" + link + \"\\n\");\n\n                    getReferredPages( context, link, depth );  // added recursive call - on general request\n\n                    m_result.append(\"\\n</li>\\n\");\n\n                }\n            } else {\n                if( !isUL ) {\n                    isUL = true; \n                    m_result.append(\"<ul>\\n\");\n                }\n\n                String href = context.getURL(WikiContext.VIEW,link);\n                m_result.append(\"<li><a class=\\\"wikipage\\\" href=\\\"\"+ href +\"\\\">\"+link+\"</a>\\n\" );\n\n                m_exists.add( link );\n\n                getReferredPages( context, link, depth );\n\n                m_result.append(\"\\n</li>\\n\");\n\n            }\n        }\n\n        if( isUL ) {\n            m_result.append(\"</ul>\\n\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          194,
          254
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/plugin/ReferredPagesPlugin.java",
        "class_name": "ReferredPagesPlugin",
        "method_name": "execute",
        "signature": "String execute(WikiContext,Map)",
        "lines_hint_csv": [
          97,
          175
        ],
        "code": "    public String execute( WikiContext context, Map<String, String> params ) throws PluginException {\n        m_engine = context.getEngine();\n\n        WikiPage         page   = context.getPage();\n        if( page == null ) return \"\";\n\n        // parse parameters\n        String rootname = params.get( PARAM_ROOT );\n        if( rootname == null ) rootname = page.getName() ;\n\n        String format = params.get( PARAM_FORMAT );\n        if( format == null) format = \"\";\n        if( format.indexOf( \"full\" ) >=0 ) m_formatCompact = false ;\n        if( format.indexOf( \"sort\" ) >=0 ) m_formatSort    = true  ;\n\n        m_depth = TextUtil.parseIntParameter( params.get( PARAM_DEPTH ), MIN_DEPTH );\n        if( m_depth > MAX_DEPTH )  m_depth = MAX_DEPTH;\n\n        String includePattern = params.get(PARAM_INCLUDE);\n        if( includePattern == null ) includePattern = \".*\";\n\n        String excludePattern = params.get(PARAM_EXCLUDE);\n        if( excludePattern == null ) excludePattern = \"^$\";\n\n        log.debug( \"Fetching referred pages for \"+ rootname +\n                   \" with a depth of \"+ m_depth +\n                   \" with include pattern of \"+ includePattern +\n                   \" with exclude pattern of \"+ excludePattern );\n\n        //\n        // do the actual work\n        //\n        String href  = context.getViewURL(rootname);\n        String title = \"ReferredPagesPlugin: depth[\"+m_depth+\n                       \"] include[\"+includePattern+\"] exclude[\"+excludePattern+\n                       \"] format[\"+(m_formatCompact ? \"compact\" : \"full\") +\n                       (m_formatSort ? \" sort\" : \"\") + \"]\";\n\n        m_result.append(\"<div class=\\\"ReferredPagesPlugin\\\">\\n\");\n        m_result.append(\"<a class=\\\"wikipage\\\" href=\\\"\"+ href +\n                        \"\\\" title=\\\"\" + title +\n                        \"\\\">\" + rootname + \"</a>\\n\");\n        m_exists.add(rootname);\n\n        // pre compile all needed patterns\n        // glob compiler :  * is 0..n instance of any char  -- more convenient as input\n        // perl5 compiler : .* is 0..n instances of any char -- more powerful\n        //PatternCompiler g_compiler = new GlobCompiler();\n        PatternCompiler compiler = new Perl5Compiler();\n\n        try\n        {\n            m_includePattern = compiler.compile(includePattern);\n\n            m_excludePattern = compiler.compile(excludePattern);\n        }\n        catch( MalformedPatternException e )\n        {\n            if (m_includePattern == null )\n            {\n                throw new PluginException(\"Illegal include pattern detected.\");\n            }\n            else if (m_excludePattern == null )\n            {\n                throw new PluginException(\"Illegal exclude pattern detected.\");\n            }\n            else\n            {\n                throw new PluginException(\"Illegal internal pattern detected.\");\n            }\n        }\n\n        // go get all referred links\n        getReferredPages(context,rootname, 0);\n\n        // close and finish\n        m_result.append (\"</div>\\n\" ) ;\n\n        return m_result.toString() ;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          97,
          176
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-10089",
    "project_slug": "apache__jspwiki_CVE-2019-10089_2.11.0.M4",
    "buggy_commit_id": "6e1dc66adf3faa22e7f1f60189611a3d8ddb0726",
    "github_url": "https://github.com/apache/jspwiki",
    "nvd_metadata": {
      "description": "On Apache JSPWiki, up to version 2.11.0.M4, a carefully crafted plugin link invocation could trigger an XSS vulnerability on Apache JSPWiki, related to the WYSIWYG editor, which could allow the attacker to execute javascript in the victim's browser and get some sensitive information about the victim.",
      "published_date": "2019-09-23T15:15:10.420",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/render/WysiwygEditingRenderer.java",
        "class_name": "WysiwygEditingRenderer",
        "method_name": "getString",
        "signature": "String getString()",
        "lines_hint_csv": [
          159,
          178
        ],
        "code": "    public String getString()\n        throws IOException\n    {\n        Element rootElement = m_document.getRootElement();\n        processChildren( rootElement );\n\n        m_document.setContext( m_context );\n\n        XMLOutputter output = new XMLOutputter();\n\n        StringWriter out = new StringWriter();\n\n        Format fmt = Format.getRawFormat();\n        fmt.setExpandEmptyElements( false );\n        fmt.setLineSeparator( LINEBREAK );\n\n        output.setFormat( fmt );\n        output.outputElementContent( m_document.getRootElement(), out );\n\n        return out.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          159,
          179
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-10219",
    "project_slug": "hibernate__hibernate-validator_CVE-2019-10219_6.0.17.Final",
    "buggy_commit_id": "7694cff9ed6325006382390c9bb2d8e4f3efedb6",
    "github_url": "https://github.com/hibernate/hibernate-validator",
    "nvd_metadata": {
      "description": "A vulnerability was found in Hibernate-Validator. The SafeHtml validator annotation fails to properly sanitize payloads consisting of potentially malicious code in HTML comments and instructions. This vulnerability can result in an XSS attack.",
      "published_date": "2019-11-08T15:15:11.157",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "engine/src/main/java/org/hibernate/validator/internal/constraintvalidators/hv/SafeHtmlValidator.java",
        "class_name": "SafeHtmlValidator",
        "method_name": "getFragmentAsDocument",
        "signature": "Document getFragmentAsDocument(CharSequence)",
        "lines_hint_csv": [
          86,
          99
        ],
        "code": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n\t\t}\n\n\t\treturn document;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          86,
          100
        ]
      },
      {
        "file_path": "engine/src/test/java/org/hibernate/validator/test/internal/constraintvalidators/hv/SafeHtmlValidatorTest.java",
        "class_name": "SafeHtmlValidatorTest",
        "method_name": "testInvalidScriptTagIncluded",
        "signature": "void testInvalidScriptTagIncluded()",
        "lines_hint_csv": [
          54,
          57
        ],
        "code": "\tpublic void testInvalidScriptTagIncluded() throws Exception {\n\t\tdescriptorBuilder.setAttribute( \"whitelistType\", WhiteListType.BASIC );\n\n\t\tassertFalse( getSafeHtmlValidator().isValid( \"Hello<script>alert('Doh')</script>World !\", null ) );\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          54,
          58
        ]
      },
      {
        "file_path": "engine/src/test/java/org/hibernate/validator/test/internal/constraintvalidators/hv/SafeHtmlValidatorTest.java",
        "class_name": "SafeHtmlValidatorTest",
        "method_name": "testDivWithWhiteListedClassAttribute",
        "signature": "void testDivWithWhiteListedClassAttribute()",
        "lines_hint_csv": [
          100,
          115
        ],
        "code": "\tpublic void testDivWithWhiteListedClassAttribute() throws Exception {\n\t\tdescriptorBuilder.setAttribute( \"whitelistType\", WhiteListType.RELAXED );\n\n\t\tAnnotationDescriptor.Builder<SafeHtml.Tag> tagDescriptorBuilder = new AnnotationDescriptor.Builder<>( SafeHtml.Tag.class );\n\t\ttagDescriptorBuilder.setAttribute( \"name\", \"div\" );\n\t\ttagDescriptorBuilder.setAttribute( \"attributes\", new String[] { \"class\" } );\n\t\tSafeHtml.Tag tag = tagDescriptorBuilder.build().getAnnotation();\n\t\tdescriptorBuilder.setAttribute( \"additionalTagsWithAttributes\", new SafeHtml.Tag[] { tag } );\n\n\t\tassertTrue(\n\t\t\t\tgetSafeHtmlValidator().isValid( \"<div class='foo'>test</div>\", null ),\n\t\t\t\t\"class attribute should be white listed\"\n\t\t);\n\t\tassertFalse(\n\t\t\t\tgetSafeHtmlValidator().isValid( \"<div style='foo'>test</div>\", null ),\n\t\t\t\t\"style attribute is not white listed\"\n\t\t);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          100,
          117
        ]
      },
      {
        "file_path": "engine/src/main/java/org/hibernate/validator/internal/constraintvalidators/hv/SafeHtmlValidator.java",
        "class_name": "SafeHtmlValidator",
        "method_name": "getFragmentAsDocument",
        "signature": "Document getFragmentAsDocument(CharSequence)",
        "lines_hint_csv": [
          86,
          99
        ],
        "code": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n\t\t}\n\n\t\treturn document;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          86,
          100
        ]
      },
      {
        "file_path": "engine/src/test/java/org/hibernate/validator/test/internal/constraintvalidators/hv/SafeHtmlValidatorTest.java",
        "class_name": "SafeHtmlValidatorTest",
        "method_name": "testDivWithWhiteListedClassAttribute",
        "signature": "void testDivWithWhiteListedClassAttribute()",
        "lines_hint_csv": [
          100,
          115
        ],
        "code": "\tpublic void testDivWithWhiteListedClassAttribute() throws Exception {\n\t\tdescriptorBuilder.setAttribute( \"whitelistType\", WhiteListType.RELAXED );\n\n\t\tAnnotationDescriptor.Builder<SafeHtml.Tag> tagDescriptorBuilder = new AnnotationDescriptor.Builder<>( SafeHtml.Tag.class );\n\t\ttagDescriptorBuilder.setAttribute( \"name\", \"div\" );\n\t\ttagDescriptorBuilder.setAttribute( \"attributes\", new String[] { \"class\" } );\n\t\tSafeHtml.Tag tag = tagDescriptorBuilder.build().getAnnotation();\n\t\tdescriptorBuilder.setAttribute( \"additionalTagsWithAttributes\", new SafeHtml.Tag[] { tag } );\n\n\t\tassertTrue(\n\t\t\t\tgetSafeHtmlValidator().isValid( \"<div class='foo'>test</div>\", null ),\n\t\t\t\t\"class attribute should be white listed\"\n\t\t);\n\t\tassertFalse(\n\t\t\t\tgetSafeHtmlValidator().isValid( \"<div style='foo'>test</div>\", null ),\n\t\t\t\t\"style attribute is not white listed\"\n\t\t);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          100,
          117
        ]
      },
      {
        "file_path": "engine/src/test/java/org/hibernate/validator/test/internal/constraintvalidators/hv/SafeHtmlValidatorTest.java",
        "class_name": "SafeHtmlValidatorTest",
        "method_name": "testInvalidScriptTagIncluded",
        "signature": "void testInvalidScriptTagIncluded()",
        "lines_hint_csv": [
          54,
          57
        ],
        "code": "\tpublic void testInvalidScriptTagIncluded() throws Exception {\n\t\tdescriptorBuilder.setAttribute( \"whitelistType\", WhiteListType.BASIC );\n\n\t\tassertFalse( getSafeHtmlValidator().isValid( \"Hello<script>alert('Doh')</script>World !\", null ) );\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          54,
          58
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-17573",
    "project_slug": "asf__cxf_CVE-2019-17573_3.2.11",
    "buggy_commit_id": "da2d27d97f9e9abd7d307e2224e5e0338b767ee2",
    "github_url": "https://github.com/apache/cxf",
    "nvd_metadata": {
      "description": "By default, Apache CXF creates a /services page containing a listing of the available endpoint names and addresses. This webpage is vulnerable to a reflected Cross-Site Scripting (XSS) attack, which allows a malicious actor to inject javascript into the web page. Please note that the attack exploits a feature which is not typically not present in modern browsers, who remove dot segments before sending the request. However, Mobile applications may be vulnerable.",
      "published_date": "2020-01-16T18:15:11.587",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "writeRESTfulEndpoint",
        "signature": "void writeRESTfulEndpoint(PrintWriter,String,AbstractDestination)",
        "lines_hint_csv": [
          165,
          186
        ],
        "code": "    private void writeRESTfulEndpoint(PrintWriter writer,\n                                      String basePath,\n                                      AbstractDestination sd) {\n        String absoluteURL = getAbsoluteAddress(basePath, sd);\n        if (absoluteURL == null) {\n            return;\n        }\n\n        writer.write(\"<tr><td>\");\n        writer.write(\"<span class=\\\"field\\\">Endpoint address:</span> \" + \"<span class=\\\"value\\\">\"\n                     + absoluteURL + \"</span>\");\n        \n        Bus sb = bus;\n        if (sd instanceof AbstractHTTPDestination) {\n            sb = ((AbstractHTTPDestination)sd).getBus();\n        }        \n        \n        addWadlIfNeeded(absoluteURL, sb, writer);\n        addOpenApiIfNeeded(absoluteURL, sb, writer);\n        addSwaggerIfNeeded(absoluteURL, sb, writer);\n        addAtomLinkIfNeeded(absoluteURL, atomMap, writer);\n        writer.write(\"</td></tr>\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          165,
          187
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "writeApiSpec",
        "signature": "void writeApiSpec(String,Bus,PrintWriter,String,String)",
        "lines_hint_csv": [
          208,
          224
        ],
        "code": "    private static void writeApiSpec(String absoluteURL, Bus sb, PrintWriter writer, \n            String specPath, String specName) {\n        if (PropertyUtils.isTrue(sb.getProperty(\"swagger.service.ui.available\"))) {\n            URI uri = URI.create(absoluteURL);\n            String schemePath = uri.getScheme() + \"://\" + uri.getHost()\n                + (uri.getPort() == -1 ? \"\" : \":\" + uri.getPort());\n            String relPath = absoluteURL.substring(schemePath.length());\n            if (!relPath.endsWith(\"/\")) {\n                relPath += \"/\";\n            }\n            specPath = \"api-docs?url=\" + relPath + specPath;\n        }\n        if (!absoluteURL.endsWith(\"/\")) {\n            specPath = \"/\" + specPath;\n        }\n        writer.write(\"<br/><span class=\\\"field\\\">\" + specName + \" :</span> \" + \"<a href=\\\"\" + absoluteURL\n                 + specPath + \"\\\">\" + absoluteURL + specPath + \"</a>\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          208,
          225
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "getExtensionEndpointAddress",
        "signature": "String getExtensionEndpointAddress(String,Map)",
        "lines_hint_csv": [
          235,
          246
        ],
        "code": "    private static String getExtensionEndpointAddress(String endpointAddress, Map<String, String> extMap) {\n        if (extMap != null) {\n            for (Map.Entry<String, String> entry : extMap.entrySet()) {\n                if (endpointAddress.endsWith(entry.getKey())) {\n                    endpointAddress = endpointAddress.substring(0, endpointAddress.length()\n                                                                   - entry.getKey().length());\n                    endpointAddress += entry.getValue();\n                    return endpointAddress;\n                }\n            }\n        }\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          235,
          247
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "writerSoapEndpoint",
        "signature": "void writerSoapEndpoint(PrintWriter,String,AbstractDestination)",
        "lines_hint_csv": [
          101,
          130
        ],
        "code": "    private void writerSoapEndpoint(PrintWriter writer,\n                                    String basePath,\n                                    AbstractDestination sd) {\n        String absoluteURL = getAbsoluteAddress(basePath, sd);\n        if (absoluteURL == null) {\n            return;\n        }\n\n        writer.write(\"<tr><td>\");\n        writer.write(\"<span class=\\\"porttypename\\\">\"\n                     + sd.getEndpointInfo().getInterface().getName().getLocalPart() + \"</span>\");\n        writer.write(\"<ul>\");\n        for (OperationInfo oi : sd.getEndpointInfo().getInterface().getOperations()) {\n            if (!Boolean.TRUE.equals(oi.getProperty(\"operation.is.synthetic\"))) {\n                writer.write(\"<li>\" + oi.getName().getLocalPart() + \"</li>\");\n            }\n        }\n        writer.write(\"</ul>\");\n        writer.write(\"</td><td>\");\n\n\n        writer.write(\"<span class=\\\"field\\\">Endpoint address:</span> \" + \"<span class=\\\"value\\\">\"\n                     + absoluteURL + \"</span>\");\n        writer.write(\"<br/><span class=\\\"field\\\">WSDL :</span> \" + \"<a href=\\\"\" + absoluteURL\n                     + \"?wsdl\\\">\" + sd.getEndpointInfo().getService().getName() + \"</a>\");\n        writer.write(\"<br/><span class=\\\"field\\\">Target namespace:</span> \"\n                     + \"<span class=\\\"value\\\">\"\n                     + sd.getEndpointInfo().getService().getTargetNamespace() + \"</span>\");\n        addAtomLinkIfNeeded(absoluteURL, atomMap, writer);\n        writer.write(\"</td></tr>\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          101,
          131
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/UnformattedServiceListWriter.java",
        "class_name": "UnformattedServiceListWriter",
        "method_name": "writeUnformattedSOAPEndpoints",
        "signature": "void writeUnformattedSOAPEndpoints(PrintWriter,String,AbstractDestination)",
        "lines_hint_csv": [
          57,
          69
        ],
        "code": "    private void writeUnformattedSOAPEndpoints(PrintWriter writer,\n                                               String baseAddress,\n                                               AbstractDestination[] destinations) throws IOException {\n        for (AbstractDestination sd : destinations) {\n            String address = getAbsoluteAddress(baseAddress, sd);\n            writer.write(address);\n\n            if (renderWsdlList) {\n                writer.write(\"?wsdl\");\n            }\n            writer.write('\\n');\n        }\n        writer.write('\\n');\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          57,
          70
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/UnformattedServiceListWriter.java",
        "class_name": "UnformattedServiceListWriter",
        "method_name": "writeUnformattedRESTfulEndpoints",
        "signature": "void writeUnformattedRESTfulEndpoints(PrintWriter,String,AbstractDestination)",
        "lines_hint_csv": [
          72,
          94
        ],
        "code": "    private void writeUnformattedRESTfulEndpoints(PrintWriter writer,\n                                                  String baseAddress,\n                                                  AbstractDestination[] destinations) throws IOException {\n        for (AbstractDestination sd : destinations) {\n            String address = getAbsoluteAddress(baseAddress, sd);\n            boolean wadlAvailable = bus != null\n                && PropertyUtils.isTrue(bus.getProperty(\"wadl.service.descrition.available\"));\n            boolean swaggerAvailable = bus != null\n                && PropertyUtils.isTrue(bus.getProperty(\"swagger.service.descrition.available\"));\n            boolean openApiAvailable = bus != null\n                && PropertyUtils.isTrue(bus.getProperty(\"openapi.service.descrition.available\"));\n            if (!wadlAvailable && !swaggerAvailable) {\n                writer.write(address + \"\\n\");\n                return;\n            }\n            if (wadlAvailable) {\n                writer.write(address + \"?_wadl\\n\");\n            }\n            if (swaggerAvailable) {\n                writer.write(address + \"/swagger.json\\n\");\n            }\n            if (openApiAvailable) {\n                writer.write(address + \"/openapi.json\\n\");\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          72,
          97
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-29204",
    "project_slug": "xuxueli__xxl-job_CVE-2020-29204_2.2.0",
    "buggy_commit_id": "1874c4854f81d6af4a9471d3fe111cdbf713f336",
    "github_url": "https://github.com/xuxueli/xxl-job",
    "nvd_metadata": {
      "description": "XXL-JOB 2.2.0 allows Stored XSS (in Add User) to bypass the 20-character limit via xxl-job-admin/src/main/java/com/xxl/job/admin/controller/UserController.java.",
      "published_date": "2020-12-27T06:15:12.387",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "xxl-job-admin/src/main/java/com/xxl/job/admin/controller/JobGroupController.java",
        "class_name": "JobGroupController",
        "method_name": "save",
        "signature": "ReturnT save(XxlJobGroup)",
        "lines_hint_csv": [
          62,
          90
        ],
        "code": "\tpublic ReturnT<String> save(XxlJobGroup xxlJobGroup){\n\n\t\t// valid\n\t\tif (xxlJobGroup.getAppname()==null || xxlJobGroup.getAppname().trim().length()==0) {\n\t\t\treturn new ReturnT<String>(500, (I18nUtil.getString(\"system_please_input\")+\"AppName\") );\n\t\t}\n\t\tif (xxlJobGroup.getAppname().length()<4 || xxlJobGroup.getAppname().length()>64) {\n\t\t\treturn new ReturnT<String>(500, I18nUtil.getString(\"jobgroup_field_appname_length\") );\n\t\t}\n\t\tif (xxlJobGroup.getTitle()==null || xxlJobGroup.getTitle().trim().length()==0) {\n\t\t\treturn new ReturnT<String>(500, (I18nUtil.getString(\"system_please_input\") + I18nUtil.getString(\"jobgroup_field_title\")) );\n\t\t}\n\t\tif (xxlJobGroup.getAddressType()!=0) {\n\t\t\tif (xxlJobGroup.getAddressList()==null || xxlJobGroup.getAddressList().trim().length()==0) {\n\t\t\t\treturn new ReturnT<String>(500, I18nUtil.getString(\"jobgroup_field_addressType_limit\") );\n\t\t\t}\n\t\t\tString[] addresss = xxlJobGroup.getAddressList().split(\",\");\n\t\t\tfor (String item: addresss) {\n\t\t\t\tif (item==null || item.trim().length()==0) {\n\t\t\t\t\treturn new ReturnT<String>(500, I18nUtil.getString(\"jobgroup_field_registryList_unvalid\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = xxlJobGroupDao.save(xxlJobGroup);\n\t\treturn (ret>0)?ReturnT.SUCCESS:ReturnT.FAIL;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          62,
          88
        ]
      },
      {
        "file_path": "xxl-job-admin/src/main/java/com/xxl/job/admin/controller/UserController.java",
        "class_name": "UserController",
        "method_name": "pageList",
        "signature": "Map pageList(int,int,String,int)",
        "lines_hint_csv": [
          51,
          64
        ],
        "code": "    public Map<String, Object> pageList(@RequestParam(required = false, defaultValue = \"0\") int start,\n                                        @RequestParam(required = false, defaultValue = \"10\") int length,\n                                        String username, int role) {\n\n        // page list\n        List<XxlJobUser> list = xxlJobUserDao.pageList(start, length, username, role);\n        int list_count = xxlJobUserDao.pageListCount(start, length, username, role);\n\n        // package result\n        Map<String, Object> maps = new HashMap<String, Object>();\n        maps.put(\"recordsTotal\", list_count);\t\t// \n        maps.put(\"recordsFiltered\", list_count);\t// \n        maps.put(\"data\", list);  \t\t\t\t\t// \n        return maps;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          51,
          65
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-13973",
    "project_slug": "OWASP__json-sanitizer_CVE-2020-13973_1.2.0",
    "buggy_commit_id": "bb41f80ad575cb90ea6535976d7c17accb4b4c87",
    "github_url": "https://github.com/OWASP/json-sanitizer",
    "nvd_metadata": {
      "description": "OWASP json-sanitizer before 1.2.1 allows XSS. An attacker who controls a substring of the input JSON, and controls another substring adjacent to a SCRIPT element in which the output is embedded as JavaScript, may be able to confuse the HTML parser as to where the SCRIPT element ends, and cause non-script content to be interpreted as JavaScript.",
      "published_date": "2020-06-09T04:15:10.983",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/com/google/json/JsonSanitizer.java",
        "class_name": "JsonSanitizer",
        "method_name": "sanitizeString",
        "signature": "void sanitizeString(int,int)",
        "lines_hint_csv": [
          511,
          644
        ],
        "code": "  private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding.  Disallow </script and ]]> in string literals so that\n        // the output can be embedded in HTML script elements and in XML CDATA\n        // sections.\n        case '/':\n          // Don't over escape.  Many JSON bodies contain innocuous HTML\n          // that can be safely embedded.\n          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n              && 's' == (jsonish.charAt(i + 1) | 32)\n              && 'c' == (jsonish.charAt(i + 2) | 32)) {\n            insert(i, '\\\\');\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \"u00\");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          511,
          645
        ]
      },
      {
        "file_path": "src/test/java/com/google/json/JsonSanitizerTest.java",
        "class_name": "JsonSanitizerTest",
        "method_name": "testIssue13",
        "signature": "void testIssue13()",
        "lines_hint_csv": [
          209,
          212
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "src/test/java/com/google/json/JsonSanitizerTest.java",
        "class_name": "JsonSanitizerTest",
        "method_name": "testSanitize",
        "signature": "void testSanitize()",
        "lines_hint_csv": [
          44,
          156
        ],
        "code": "  public static final void testSanitize() {\n    // On the left is the sanitized output, and on the right the input.\n    // If there is a single string, then the input is fine as-is.\n    assertSanitized(\"null\", null);\n    assertSanitized(\"null\", \"\");\n    assertSanitized(\"null\");\n    assertSanitized(\"false\");\n    assertSanitized(\"true\");\n    assertSanitized(\" false \");\n    assertSanitized(\"  false\");\n    assertSanitized(\"false\\n\");\n    assertSanitized(\"false\", \"false,true\");\n    assertSanitized(\"\\\"foo\\\"\");\n    assertSanitized(\"\\\"foo\\\"\", \"'foo'\");\n    assertSanitized(\n        \"\\\"<script>foo()<\\\\/script>\\\"\", \"\\\"<script>foo()</script>\\\"\");\n    assertSanitized(\n        \"\\\"<script>foo()<\\\\/script>\\\"\", \"\\\"<script>foo()</script>\\\"\");\n    assertSanitized(\"\\\"<\\\\/SCRIPT\\\\n>\\\"\", \"\\\"</SCRIPT\\n>\\\"\");\n    assertSanitized(\"\\\"<\\\\/ScRIpT\\\"\", \"\\\"</ScRIpT\\\"\");\n    // \\u0130 is a Turkish dotted upper-case 'I' so the lower case version of\n    // the tag name is \"script\".\n    assertSanitized(\"\\\"<\\\\/ScR\\u0130pT\\\"\", \"\\\"</ScR\\u0130pT\\\"\");\n    assertSanitized(\"\\\"<b>Hello</b>\\\"\");\n    assertSanitized(\"\\\"<s>Hello</s>\\\"\");\n    assertSanitized(\"\\\"<[[\\\\u005d]>\\\"\", \"'<[[]]>'\");\n    assertSanitized(\"\\\"\\\\u005d]>\\\"\", \"']]>'\");\n    assertSanitized(\"[[0]]\", \"[[0]]>\");\n    assertSanitized(\"[1,-1,0.0,-0.5,1e2]\", \"[1,-1,0.0,-0.5,1e2,\");\n    assertSanitized(\"[1,2,3]\", \"[1,2,3,]\");\n    assertSanitized(\"[1,null,3]\", \"[1,,3,]\");\n    assertSanitized(\"[1 ,2 ,3]\", \"[1 2 3]\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ \\\"foo\\\": \\\"bar\\\", }\");\n    assertSanitized(\"{\\\"foo\\\":\\\"bar\\\"}\", \"{\\\"foo\\\",\\\"bar\\\"}\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ foo: \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\"}\", \"{ foo: 'bar\");\n    assertSanitized(\"{ \\\"foo\\\": [\\\"bar\\\"]}\", \"{ foo: ['bar\");\n    assertSanitized(\"false\", \"// comment\\nfalse\");\n    assertSanitized(\"false\", \"false// comment\");\n    assertSanitized(\"false\", \"false// comment\\n\");\n    assertSanitized(\"false\", \"false/* comment */\");\n    assertSanitized(\"false\", \"false/* comment *\");\n    assertSanitized(\"false\", \"false/* comment \");\n    assertSanitized(\"false\", \"/*/true**/false\");\n    assertSanitized(\"1\");\n    assertSanitized(\"-1\");\n    assertSanitized(\"1.0\");\n    assertSanitized(\"-1.0\");\n    assertSanitized(\"1.05\");\n    assertSanitized(\"427.0953333\");\n    assertSanitized(\"6.0221412927e+23\");\n    assertSanitized(\"6.0221412927e23\");\n    assertSanitized(\"6.0221412927e0\", \"6.0221412927e\");\n    assertSanitized(\"6.0221412927e-0\", \"6.0221412927e-\");\n    assertSanitized(\"6.0221412927e+0\", \"6.0221412927e+\");\n    assertSanitized(\"1.660538920287695E-24\");\n    assertSanitized(\"-6.02e-23\");\n    assertSanitized(\"1.0\", \"1.\");\n    assertSanitized(\"0.5\", \".5\");\n    assertSanitized(\"-0.5\", \"-.5\");\n    assertSanitized(\"0.5\", \"+.5\");\n    assertSanitized(\"0.5e2\", \"+.5e2\");\n    assertSanitized(\"1.5e+2\", \"+1.5e+2\");\n    assertSanitized(\"0.5e-2\", \"+.5e-2\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{-0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{+0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{.5:0}\");\n    assertSanitized(\"{\\\"-0.5\\\":0}\", \"{-.5:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{+.5:0}\");\n    assertSanitized(\"{\\\"50\\\":0}\", \"{+.5e2:0}\");\n    assertSanitized(\"{\\\"150\\\":0}\", \"{+1.5e+2:0}\");\n    assertSanitized(\"{\\\"0.1\\\":0}\", \"{+.1:0}\");\n    assertSanitized(\"{\\\"0.01\\\":0}\", \"{+.01:0}\");\n    assertSanitized(\"{\\\"0.005\\\":0}\", \"{+.5e-2:0}\");\n    assertSanitized(\"{\\\"1e+101\\\":0}\", \"{10e100:0}\");\n    assertSanitized(\"{\\\"1e-99\\\":0}\", \"{10e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.5e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.500e-100:0}\");\n    assertSanitized(\"{\\\"1.234e+101\\\":0}\", \"{12.34e100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{}\");\n    // Remove grouping parentheses.\n    assertSanitized(\"{}\", \"({})\");\n    // Escape code-points and isolated surrogates which are not XML embeddable.\n    assertSanitized(\"\\\"\\\\u0000\\\\u0008\\\\u001f\\\"\", \"'\\u0000\\u0008\\u001f'\");\n    assertSanitized(\"\\\"\\ud800\\udc00\\\\udc00\\\\ud800\\\"\",\n                    \"'\\ud800\\udc00\\udc00\\ud800'\");\n    assertSanitized(\"\\\"\\ufffd\\\\ufffe\\\\uffff\\\"\", \"'\\ufffd\\ufffe\\uffff'\");\n    // These control characters should be elided if they appear outside a string\n    // literal.\n    assertSanitized(\"42\", \"\\uffef\\u000042\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"null\", \"\\uffef\\u0000\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"[null]\", \"[,]\");\n    assertSanitized(\"[null]\", \"[null,]\");\n    assertSanitized(\"{\\\"a\\\":0,\\\"false\\\":\\\"x\\\",\\\"\\\":{\\\"\\\":-1}}\",\n                    \"{\\\"a\\\":0,false\\\"x\\\":{\\\"\\\":-1}}\");\n    assertSanitized(\"[true ,false]\", \"[true false]\");\n    assertSanitized(\"[\\\"\\\\u00a0\\\\u1234\\\"]\");\n    assertSanitized(\"{\\\"a\\\\b\\\":\\\"c\\\"}\", \"{a\\\\b\\\"c\");\n    assertSanitized(\"{\\\"a\\\":\\\"b\\\",\\\"c\\\":null}\", \"{\\\"a\\\":\\\"b\\\",\\\"c\\\":\");\n    assertSanitized(\n        \"{\\\"1e0001234567890123456789123456789123456789\\\":0}\",\n        // Exponent way out of representable range in a JS double.\n        \"{1e0001234567890123456789123456789123456789:0}\"\n                    );\n    // This is an odd consequence of the way we recode octal literals.\n    // Our octal recoder does not fail on digits '8' or '9'.\n    assertSanitized(\"-2035208041\", \"-016923547559\");\n  }\n\n  @Test\n  public static final void testIssue3() {\n    // These triggered index out of bounds and assertion errors.\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{},\\u00E4\");\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{\\u00E4\\u00E4},\\u00E4\");\n  }\n\n  @Test\n  public static final void testIssue4() {\n    // Make sure that bare words are quoted.\n    assertSanitized(\"\\\"dev\\\"\", \"dev\");\n    assertSanitized(\"\\\"eval\\\"\", \"eval\");\n    assertSanitized(\"\\\"comment\\\"\", \"comment\");\n    assertSanitized(\"\\\"fasle\\\"\", \"fasle\");\n    assertSanitized(\"\\\"FALSE\\\"\", \"FALSE\");\n    assertSanitized(\"\\\"dev/comment\\\"\", \"dev/comment\");\n    assertSanitized(\"\\\"devcomment\\\"\", \"dev\\\\comment\");\n    assertSanitized(\"\\\"dev\\\\ncomment\\\"\", \"dev\\\\ncomment\");\n    assertSanitized(\"[\\\"dev\\\", \\\"comment\\\"]\", \"[dev\\\\, comment]\");\n  }\n\n  @Test\n  public static final void testMaximumNestingLevel() {\n    String nestedMaps = \"{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n    String sanitizedNestedMaps = \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n\n    boolean exceptionIfTooMuchNesting = false;\n    try {\n      assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      Logger.getAnonymousLogger().log(Level.FINEST, \"Expected exception in testing maximum nesting level\", e);\n      exceptionIfTooMuchNesting = true;\n    }\n    assertTrue(\"Expecting failure for too nested JSON\", exceptionIfTooMuchNesting);\n    assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH + 1);\n  }\n\n  @Test\n  public static final void testMaximumNestingLevelAssignment() {\n    assertEquals(1, new JsonSanitizer(\"\", Integer.MIN_VALUE).getMaximumNestingDepth());\n    assertEquals(JsonSanitizer.MAXIMUM_NESTING_DEPTH, new JsonSanitizer(\"\", Integer.MAX_VALUE).getMaximumNestingDepth());\n  }\n}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          44,
          201
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-27219",
    "project_slug": "eclipse__hawkbit_CVE-2020-27219_0.3.0M6",
    "buggy_commit_id": "f3659f01425ad0162f92fa73357f8c507058bcb2",
    "github_url": "https://github.com/eclipse/hawkbit",
    "nvd_metadata": {
      "description": "In all version of Eclipse Hawkbit prior to 0.3.0M7, the HTTP 404 (Not Found) JSON response body returned by the REST API may contain unsafe characters within the path attribute. Sending a POST request to a non existing resource will return the full path from the given URL unescaped to the client.",
      "published_date": "2021-01-14T23:15:12.977",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": []
  },
  {
    "cve_id": "CVE-2021-44667",
    "project_slug": "alibaba__nacos_CVE-2021-44667_2.0.3",
    "buggy_commit_id": "5a4d433970be9b8402f57e65bffa497027f21e30",
    "github_url": "https://github.com/alibaba/nacos",
    "nvd_metadata": {
      "description": "A Cross Site Scripting (XSS) vulnerability exists in Nacos 2.0.3 in auth/users via the (1) pageSize and (2) pageNo parameters.",
      "published_date": "2022-03-11T19:15:09.023",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": []
  },
  {
    "cve_id": "CVE-2022-28367",
    "project_slug": "nahsra__antisamy_CVE-2022-28367_1.6.5",
    "buggy_commit_id": "b7c151112dd19928e700ee48639942fd1079d1e3",
    "github_url": "https://github.com/nahsra/antisamy",
    "nvd_metadata": {
      "description": "OWASP AntiSamy before 1.6.6 allows XSS via HTML tag smuggling on STYLE content with crafted input. The output serializer does not properly encode the supposed Cascading Style Sheets (CSS) content.",
      "published_date": "2022-04-21T23:15:10.427",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/owasp/validator/html/scan/AntiSamyDOMScanner.java",
        "class_name": "AntiSamyDOMScanner",
        "method_name": "processStyleTag",
        "signature": "boolean processStyleTag(Element,Node)",
        "lines_hint_csv": [
          403,
          446
        ],
        "code": "    private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            Node firstChild = ele.getFirstChild();\n            if (firstChild != null) {\n\n                String toScan = firstChild.getNodeValue();\n                CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                final String cleanHTML = cr.getCleanHTML();\n\n                if (cleanHTML == null || cleanHTML.equals(\"\")) {\n                    firstChild.setNodeValue(\"/* */\");\n                } else {\n                    firstChild.setNodeValue(cleanHTML);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          403,
          447
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "testGithubIssue151",
        "signature": "void testGithubIssue151()",
        "lines_hint_csv": [
          1693,
          1703
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2022-24891",
    "project_slug": "ESAPI__esapi-java-legacy_CVE-2022-24891_2.2.3.1",
    "buggy_commit_id": "2e8694c6beb3bdbb2645b882eba72ce41bc63242",
    "github_url": "https://github.com/ESAPI/esapi-java-legacy",
    "nvd_metadata": {
      "description": "ESAPI (The OWASP Enterprise Security API) is a free, open source, web application security control library. Prior to version 2.3.0.0, there is a potential for a cross-site scripting vulnerability in ESAPI caused by a incorrect regular expression for \"onsiteURL\" in the **antisamy-esapi.xml** configuration file that can cause \"javascript:\" URLs to fail to be correctly sanitized. This issue is patched in ESAPI 2.3.0.0. As a workaround, manually edit the **antisamy-esapi.xml** configuration files to change the \"onsiteURL\" regular expression. More information about remediation of the vulnerability, including the workaround, is available in the maintainers' release notes and security bulletin.",
      "published_date": "2022-04-27T21:15:08.523",
      "cvss_v3_score": 5.4,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidHTTPRequestParameterSet",
        "signature": "boolean isValidHTTPRequestParameterSet(String,HttpServletRequest,Set,Set,ValidationErrorList)",
        "lines_hint_csv": [
          908,
          914
        ],
        "code": "\tpublic boolean isValidHTTPRequestParameterSet(String context, HttpServletRequest request, Set<String> requiredNames, Set<String> optionalNames, ValidationErrorList errors) {\n\t\ttry {\n\t\t\tassertValidHTTPRequestParameterSet( context, request, requiredNames, optionalNames);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          908,
          916
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidSafeHTML",
        "signature": "boolean isValidSafeHTML(String,String,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          331,
          337
        ],
        "code": "\tpublic boolean isValidSafeHTML(String context, String input, int maxLength, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidSafeHTML( context, input, maxLength, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          331,
          339
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidFileName",
        "signature": "boolean isValidFileName(String,String,List,boolean)",
        "lines_hint_csv": [
          517,
          522
        ],
        "code": "\tpublic boolean isValidFileName(String context, String input, List<String> allowedExtensions, boolean allowNull) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidFileName( context, input, allowedExtensions, allowNull);\n\t\t\treturn true;\n\t\t} catch( Exception e ) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          517,
          524
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidFileContent",
        "signature": "boolean isValidFileContent(String,byte,int,boolean)",
        "lines_hint_csv": [
          740,
          745
        ],
        "code": "\tpublic boolean isValidFileContent(String context, byte[] input, int maxBytes, boolean allowNull) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidFileContent( context, input, maxBytes, allowNull);\n\t\t\treturn true;\n\t\t} catch( Exception e ) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          740,
          747
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "safeReadLine",
        "signature": "String safeReadLine(InputStream,int)",
        "lines_hint_csv": [
          1143,
          1172
        ],
        "code": "\tpublic String safeReadLine(InputStream in, int max) throws ValidationException {\n\t\tif (max <= 0) {\n\t\t\tthrow new ValidationAvailabilityException( \"Invalid input\", \"Invalid readline. Must read a positive number of bytes from the stream\");\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint count = 0;\n\t\tint c;\n\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tc = in.read();\n\t\t\t\tif ( c == -1 ) {\n\t\t\t\t\tif (sb.length() == 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (c == '\\n' || c == '\\r') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count > max) {\n\t\t\t\t\tthrow new ValidationAvailabilityException( \"Invalid input\", \"Invalid readLine. Read more than maximum characters allowed (\" + max + \")\");\n\t\t\t\t}\n\t\t\t\tsb.append((char) c);\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ValidationAvailabilityException( \"Invalid input\", \"Invalid readLine. Problem reading from input stream\", e);\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1143,
          1174
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidDouble",
        "signature": "boolean isValidDouble(String,String,double,double,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          658,
          664
        ],
        "code": "\tpublic boolean isValidDouble(String context, String input, double minValue, double maxValue, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n        try {\n            getValidDouble( context, input, minValue, maxValue, allowNull );\n            return true;\n        } catch( ValidationException e ) {\n            errors.addError(context, e);\n            return false;\n        }\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          658,
          666
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidFileUpload",
        "signature": "boolean isValidFileUpload(String,String,String,File,byte,int,boolean)",
        "lines_hint_csv": [
          798,
          801
        ],
        "code": "\tpublic boolean isValidFileUpload(String context, String directorypath, String filename, File parent, byte[] content, int maxBytes, boolean allowNull) throws IntrusionException {\n\t\treturn( isValidFileName( context, filename, allowNull ) &&\n\t\t\t\tisValidDirectoryPath( context, directorypath, parent, allowNull ) &&\n\t\t\t\tisValidFileContent( context, content, maxBytes, allowNull ) );\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          798,
          802
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidDirectoryPath",
        "signature": "boolean isValidDirectoryPath(String,String,File,boolean)",
        "lines_hint_csv": [
          419,
          424
        ],
        "code": "\tpublic boolean isValidDirectoryPath(String context, String input, File parent, boolean allowNull) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidDirectoryPath( context, input, parent, allowNull);\n\t\t\treturn true;\n\t\t} catch( Exception e ) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          419,
          426
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidInteger",
        "signature": "boolean isValidInteger(String,String,int,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          705,
          711
        ],
        "code": "\tpublic boolean isValidInteger(String context, String input, int minValue, int maxValue, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidInteger( context, input, minValue, maxValue, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          705,
          713
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidDirectoryPath",
        "signature": "String getValidDirectoryPath(String,String,File,boolean)",
        "lines_hint_csv": [
          447,
          481
        ],
        "code": "\tpublic String getValidDirectoryPath(String context, String input, File parent, boolean allowNull) throws ValidationException, IntrusionException {\n\t\ttry {\n\t\t\tif (isEmpty(input)) {\n\t\t\t\tif (allowNull) return null;\n       \t\t\tthrow new ValidationException( context + \": Input directory path required\", \"Input directory path required: context=\" + context + \", input=\" + input, context );\n\t\t\t}\n\n\t\t\tFile dir = new File( input );\n\n\t\t\t// check dir exists and parent exists and dir is inside parent\n\t\t\tif ( !dir.exists() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, does not exist: context=\" + context + \", input=\" + input );\n\t\t\t}\n\t\t\tif ( !dir.isDirectory() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, not a directory: context=\" + context + \", input=\" + input );\n\t\t\t}\n\t\t\tif ( !parent.exists() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, specified parent does not exist: context=\" + context + \", input=\" + input + \", parent=\" + parent );\n\t\t\t}\n\t\t\tif ( !parent.isDirectory() ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, specified parent is not a directory: context=\" + context + \", input=\" + input + \", parent=\" + parent );\n\t\t\t}\n\t\t\tif ( !dir.getCanonicalPath().startsWith(parent.getCanonicalPath() ) ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory, not inside specified parent: context=\" + context + \", input=\" + input + \", parent=\" + parent );\n\t\t\t}\n\n\t\t\t// check canonical form matches input\n\t\t\tString canonicalPath = dir.getCanonicalPath();\n\t\t\tString canonical = fileValidator.getValidInput( context, canonicalPath, \"DirectoryName\", 255, false);\n\t\t\tif ( !canonical.equals( input ) ) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Invalid directory name does not match the canonical path: context=\" + context + \", input=\" + input + \", canonical=\" + canonical, context );\n\t\t\t}\n\t\t\treturn canonical;\n\t\t} catch (Exception e) {\n\t\t\tthrow new ValidationException( context + \": Invalid directory name\", \"Failure to validate directory path: context=\" + context + \", input=\" + input, e, context );\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          447,
          483
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidFileContent",
        "signature": "byte getValidFileContent(String,byte,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          781,
          788
        ],
        "code": "\tpublic byte[] getValidFileContent(String context, byte[] input, int maxBytes, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidFileContent(context, input, maxBytes, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\t\t// return empty byte array on error\n\t\treturn new byte[0];\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          781,
          789
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidInput",
        "signature": "String getValidInput(String,String,String,int,boolean,boolean)",
        "lines_hint_csv": [
          209,
          221
        ],
        "code": "\tpublic String getValidInput(String context, String input, String type, int maxLength, boolean allowNull, boolean canonicalize) throws ValidationException {\n\t\tStringValidationRule rvr = new StringValidationRule( type, encoder );\n\t\tPattern p = ESAPI.securityConfiguration().getValidationPattern( type );\n\t\tif ( p != null ) {\n\t\t\trvr.addWhitelistPattern( p );\n\t\t} else {\n            // Issue 232 - Specify requested type in exception message - CS\n\t\t\tthrow new IllegalArgumentException(\"The selected type [\" + type + \"] was not set via the ESAPI validation configuration\");\n\t\t}\n\t\trvr.setMaximumLength(maxLength);\n\t\trvr.setAllowNull(allowNull);\n\t\trvr.setCanonicalize(canonicalize);\n\t\treturn rvr.getValid(context, input);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          209,
          222
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidPrintable",
        "signature": "char getValidPrintable(String,char,int,boolean)",
        "lines_hint_csv": [
          995,
          1010
        ],
        "code": "\tpublic char[] getValidPrintable(String context, char[] input, int maxLength, boolean allowNull) throws ValidationException, IntrusionException {\n\t\tif (isEmpty(input)) {\n\t\t\tif (allowNull) return null;\n   \t\t\tthrow new ValidationException(context + \": Input bytes required\", \"Input bytes required: HTTP request is null\", context );\n\t\t}\n\n\t\tif (input.length > maxLength) {\n\t\t\tthrow new ValidationException(context + \": Input bytes can not exceed \" + maxLength + \" bytes\", \"Input exceeds maximum allowed length of \" + maxLength + \" by \" + (input.length-maxLength) + \" bytes: context=\" + context + \", input=\" + new String( input ), context);\n\t\t}\n\n\t\tfor (int i = 0; i < input.length; i++) {\n\t\t\tif (input[i] <= 0x20 || input[i] >= 0x7E ) {\n\t\t\t\tthrow new ValidationException(context + \": Invalid input bytes: context=\" + context, \"Invalid non-ASCII input bytes, context=\" + context + \", input=\" + new String( input ), context);\n\t\t\t}\n\t\t}\n\t\treturn input;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          995,
          1011
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidInteger",
        "signature": "Integer getValidInteger(String,String,int,int,boolean)",
        "lines_hint_csv": [
          718,
          721
        ],
        "code": "\tpublic Integer getValidInteger(String context, String input, int minValue, int maxValue, boolean allowNull) throws ValidationException, IntrusionException {\n\t\tIntegerValidationRule ivr = new IntegerValidationRule( \"number\", encoder, minValue, maxValue );\n\t\tivr.setAllowNull(allowNull);\n\t\treturn ivr.getValid(context, input);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          718,
          722
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidListItem",
        "signature": "String getValidListItem(String,String,List,ValidationErrorList)",
        "lines_hint_csv": [
          883,
          890
        ],
        "code": "\tpublic String getValidListItem(String context, String input, List<String> list, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidListItem(context, input, list);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\t\t// error has been added to list, so return original input\n\t\treturn input;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          883,
          891
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidInput",
        "signature": "boolean isValidInput(String,String,String,int,boolean,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          166,
          172
        ],
        "code": "        public boolean isValidInput(String context, String input, String type, int maxLength, boolean allowNull, boolean canonicalize, ValidationErrorList errors) throws IntrusionException  {\n\t\ttry {\n\t\t\tgetValidInput( context, input, type, maxLength, allowNull, canonicalize);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n\t\t\terrors.addError( context, e );\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          166,
          174
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidSafeHTML",
        "signature": "boolean isValidSafeHTML(String,String,int,boolean)",
        "lines_hint_csv": [
          319,
          324
        ],
        "code": "\tpublic boolean isValidSafeHTML(String context, String input, int maxLength, boolean allowNull) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidSafeHTML( context, input, maxLength, allowNull);\n\t\t\treturn true;\n\t\t} catch( Exception e ) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          319,
          326
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidHTTPRequestParameterSet",
        "signature": "boolean isValidHTTPRequestParameterSet(String,HttpServletRequest,Set,Set)",
        "lines_hint_csv": [
          896,
          901
        ],
        "code": "\tpublic boolean isValidHTTPRequestParameterSet(String context, HttpServletRequest request, Set<String> requiredNames, Set<String> optionalNames) {\n\t\ttry {\n\t\t\tassertValidHTTPRequestParameterSet( context, request, requiredNames, optionalNames);\n\t\t\treturn true;\n\t\t} catch( Exception e ) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          896,
          903
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "assertValidFileUpload",
        "signature": "void assertValidFileUpload(String,String,String,File,byte,int,List,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          829,
          834
        ],
        "code": "\tpublic void assertValidFileUpload(String context, String filepath, String filename, File parent, byte[] content, int maxBytes, List<String> allowedExtensions, boolean allowNull, ValidationErrorList errors)\n\t\tthrows IntrusionException {\n\t\ttry {\n\t\t\tassertValidFileUpload(context, filepath, filename, parent, content, maxBytes, allowedExtensions, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          829,
          836
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidListItem",
        "signature": "String getValidListItem(String,String,List)",
        "lines_hint_csv": [
          872,
          874
        ],
        "code": "\tpublic String getValidListItem(String context, String input, List<String> list) throws ValidationException, IntrusionException {\n\t\tif (list.contains(input)) return input;\n\t\tthrow new ValidationException( context + \": Invalid list item\", \"Invalid list item: context=\" + context + \", input=\" + input, context );\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          872,
          875
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidInteger",
        "signature": "boolean isValidInteger(String,String,int,int,boolean)",
        "lines_hint_csv": [
          693,
          698
        ],
        "code": "\tpublic boolean isValidInteger(String context, String input, int minValue, int maxValue, boolean allowNull) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidInteger( context, input, minValue, maxValue, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          693,
          700
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidURI",
        "signature": "boolean isValidURI(String,String,boolean)",
        "lines_hint_csv": [
          1210,
          1247
        ],
        "code": "\tpublic boolean isValidURI(String context, String input, boolean allowNull) {\n\t\tboolean isValid = false;\n\t\tboolean inputIsNullOrEmpty = input == null || \"\".equals(input);\n\t\tEncoder encoder = ESAPI.encoder();\n\t\ttry{\n\t\t\tURI compliantURI = null == input ? new URI(\"\") :  this.getRfcCompliantURI(input);\n\t\t\tif(null != compliantURI && input != null){\n\t\t\t\tString canonicalizedURI = encoder.getCanonicalizedURI(compliantURI);\n\t\t\t\t//if getCanonicalizedURI doesn't throw an IntrusionException, then the URI contains no mixed or \n\t\t\t\t//double-encoding attacks.  \n\t\t\t\tlogger.debug(Logger.SECURITY_SUCCESS, \"We did not detect any mixed or multiple encoding in the uri:[\" + input + \"]\");\n\t\t\t\tValidator v = ESAPI.validator();\n\t\t\t\t//This part will use the regex from validation.properties.  This regex should be super-simple, and \n\t\t\t\t//used mainly to restrict certain parts of a URL.  \n\t\t\t\tPattern p = ESAPI.securityConfiguration().getValidationPattern( \"URL\" );\n\t\t\t\tif(p != null){\n\t\t\t\t\t//We're doing this instead of using the normal validator API, because it will canonicalize the input again\n\t\t\t\t\t//and if the URI has any queries that also happen to match HTML entities, like &para;\n\t\t\t\t\t//it will cease conforming to the regex we now specify for a URL.\n\t\t\t\t\tisValid = p.matcher(canonicalizedURI).matches();\n\t\t\t\t}else{\n\t\t\t\t\tlogger.error(Logger.EVENT_FAILURE, \"Invalid regex pulled from configuration.  Check the regex for URL and correct.\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(allowNull && inputIsNullOrEmpty ){\n\t\t\t\t\tisValid = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}catch (IntrusionException e){\n\t\t\tlogger.error(Logger.SECURITY_FAILURE, e.getMessage());\n\t\t\tisValid = false;\n\t\t} catch (URISyntaxException e) {\n\t\t\tlogger.error(Logger.EVENT_FAILURE, e.getMessage());\n\t\t}\n\t\t\n\t\t\n\t\treturn isValid;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1210,
          1248
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidFileName",
        "signature": "String getValidFileName(String,String,List,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          586,
          593
        ],
        "code": "\tpublic String getValidFileName(String context, String input, List<String> allowedParameters, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidFileName(context, input, allowedParameters, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\n\t\treturn \"\";\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          586,
          594
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidFileContent",
        "signature": "byte getValidFileContent(String,byte,int,boolean)",
        "lines_hint_csv": [
          765,
          775
        ],
        "code": "\tpublic byte[] getValidFileContent(String context, byte[] input, int maxBytes, boolean allowNull) throws ValidationException, IntrusionException {\n\t\tif (isEmpty(input)) {\n\t\t\tif (allowNull) return null;\n   \t\t\tthrow new ValidationException( context + \": Input required\", \"Input required: context=\" + context + \", input=\" + Arrays.toString(input), context );\n\t\t}\n\n\t\tlong esapiMaxBytes = ESAPI.securityConfiguration().getAllowedFileUploadSize();\n\t\tif (input.length > esapiMaxBytes ) throw new ValidationException( context + \": Invalid file content can not exceed \" + esapiMaxBytes + \" bytes\", \"Exceeded ESAPI max length\", context );\n\t\tif (input.length > maxBytes ) throw new ValidationException( context + \": Invalid file content can not exceed \" + maxBytes + \" bytes\", \"Exceeded maxBytes ( \" + input.length + \")\", context );\n\n\t\treturn input;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          765,
          776
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidFileContent",
        "signature": "boolean isValidFileContent(String,byte,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          752,
          758
        ],
        "code": "\tpublic boolean isValidFileContent(String context, byte[] input, int maxBytes, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidFileContent( context, input, maxBytes, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          752,
          760
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidFileName",
        "signature": "String getValidFileName(String,String,List,boolean)",
        "lines_hint_csv": [
          541,
          580
        ],
        "code": "\tpublic String getValidFileName(String context, String input, List<String> allowedExtensions, boolean allowNull) throws ValidationException, IntrusionException {\n\t\tif ((allowedExtensions == null) || (allowedExtensions.isEmpty())) {\n\t\t\tthrow new ValidationException( \"Internal Error\", \"getValidFileName called with an empty or null list of allowed Extensions, therefore no files can be uploaded\" );\n\t\t}\n\n\t\tString canonical = \"\";\n\t\t// detect path manipulation\n\t\ttry {\n\t\t\tif (isEmpty(input)) {\n\t\t\t\tif (allowNull) return null;\n\t   \t\t\tthrow new ValidationException( context + \": Input file name required\", \"Input required: context=\" + context + \", input=\" + input, context );\n\t\t\t}\n\n\t\t\t// do basic validation\n\t        canonical = new File(input).getCanonicalFile().getName();\n\t        getValidInput( context, input, \"FileName\", 255, true );\n\n\t\t\tFile f = new File(canonical);\n\t\t\tString c = f.getCanonicalPath();\n\t\t\tString cpath = c.substring(c.lastIndexOf(File.separator) + 1);\n\n\n\t\t\t// the path is valid if the input matches the canonical path\n\t\t\tif (!input.equals(cpath)) {\n\t\t\t\tthrow new ValidationException( context + \": Invalid file name\", \"Invalid directory name does not match the canonical path: context=\" + context + \", input=\" + input + \", canonical=\" + canonical, context );\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tthrow new ValidationException( context + \": Invalid file name\", \"Invalid file name does not exist: context=\" + context + \", canonical=\" + canonical, e, context );\n\t\t}\n\n\t\t// verify extensions\n\t\tIterator<String> i = allowedExtensions.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tString ext = i.next();\n\t\t\tif (input.toLowerCase().endsWith(ext.toLowerCase())) {\n\t\t\t\treturn canonical;\n\t\t\t}\n\t\t}\n\t\tthrow new ValidationException( context + \": Invalid file name does not have valid extension ( \"+allowedExtensions+\")\", \"Invalid file name does not have valid extension ( \"+allowedExtensions+\"): context=\" + context+\", input=\" + input, context );\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          541,
          581
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidPrintable",
        "signature": "boolean isValidPrintable(String,char,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          979,
          985
        ],
        "code": "\tpublic boolean isValidPrintable(String context, char[] input, int maxLength, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidPrintable( context, input, maxLength, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          979,
          987
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidSafeHTML",
        "signature": "String getValidSafeHTML(String,String,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          356,
          363
        ],
        "code": "\tpublic String getValidSafeHTML(String context, String input, int maxLength, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidSafeHTML(context, input, maxLength, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\n\t\treturn \"\";\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          356,
          364
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidDouble",
        "signature": "Double getValidDouble(String,String,double,double,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          680,
          687
        ],
        "code": "\tpublic Double getValidDouble(String context, String input, double minValue, double maxValue, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidDouble(context, input, minValue, maxValue, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\n\t\treturn new Double(Double.NaN);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          680,
          688
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidFileName",
        "signature": "boolean isValidFileName(String,String,boolean)",
        "lines_hint_csv": [
          503,
          504
        ],
        "code": "\tpublic boolean isValidFileName(String context, String input, boolean allowNull) throws IntrusionException {\n\t\treturn isValidFileName( context, input, ESAPI.securityConfiguration().getAllowedFileExtensions(), allowNull );\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          503,
          505
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidPrintable",
        "signature": "boolean isValidPrintable(String,String,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          1050,
          1056
        ],
        "code": "\tpublic boolean isValidPrintable(String context, String input, int maxLength, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidPrintable( context, input, maxLength, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1050,
          1058
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidDate",
        "signature": "Date getValidDate(String,String,DateFormat,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          304,
          313
        ],
        "code": "\tpublic Date getValidDate(String context, String input, DateFormat format, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t    Date safeDate = null;\n\t    DateValidationRule dvr = new DateValidationRule( \"SimpleDate\", encoder, format);\n\t    dvr.setAllowNull(allowNull);\n\t    safeDate = dvr.sanitize(context, input, errors);\n\t    if (!errors.isEmpty()) {\n\t        safeDate = null;\n\t    }\n\t    // error has been added to list, so return null\n\t    return safeDate;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          304,
          314
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidNumber",
        "signature": "Double getValidNumber(String,String,long,long,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          633,
          640
        ],
        "code": "\tpublic Double getValidNumber(String context, String input, long minValue, long maxValue, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidNumber(context, input, minValue, maxValue, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\n\t\treturn null;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          633,
          641
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidPrintable",
        "signature": "String getValidPrintable(String,String,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          1082,
          1089
        ],
        "code": "\tpublic String getValidPrintable(String context, String input,int maxLength, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidPrintable(context, input, maxLength, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\t\t// error has been added to list, so return original input\n\t\treturn input;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1082,
          1090
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidPrintable",
        "signature": "String getValidPrintable(String,String,int,boolean)",
        "lines_hint_csv": [
          1066,
          1073
        ],
        "code": "\tpublic String getValidPrintable(String context, String input, int maxLength, boolean allowNull) throws ValidationException, IntrusionException {\n\t\ttry {\n    \t\tString canonical = encoder.canonicalize(input);\n    \t\treturn new String( getValidPrintable( context, canonical.toCharArray(), maxLength, allowNull) );\n\t    //TODO - changed this to base Exception since we no longer need EncodingException\n    \t//TODO - this is a bit lame: we need to re-think this function.\n\t\t} catch (Exception e) {\n\t        throw new ValidationException( context + \": Invalid printable input\", \"Invalid encoding of printable input, context=\" + context + \", input=\" + input, e, context);\n\t    }\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1066,
          1075
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "assertValidHTTPRequestParameterSet",
        "signature": "void assertValidHTTPRequestParameterSet(String,HttpServletRequest,Set,Set,ValidationErrorList)",
        "lines_hint_csv": [
          950,
          954
        ],
        "code": "\tpublic void assertValidHTTPRequestParameterSet(String context, HttpServletRequest request, Set<String> required, Set<String> optional, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tassertValidHTTPRequestParameterSet(context, request, required, optional);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          950,
          956
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidNumber",
        "signature": "boolean isValidNumber(String,String,long,long,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          611,
          617
        ],
        "code": "\tpublic boolean isValidNumber(String context, String input, long minValue, long maxValue, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidNumber(context, input, minValue, maxValue, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          611,
          619
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "assertValidHTTPRequestParameterSet",
        "signature": "void assertValidHTTPRequestParameterSet(String,HttpServletRequest,Set,Set)",
        "lines_hint_csv": [
          925,
          940
        ],
        "code": "\tpublic void assertValidHTTPRequestParameterSet(String context, HttpServletRequest request, Set<String> required, Set<String> optional) throws ValidationException, IntrusionException {\n\t\tSet<String> actualNames = request.getParameterMap().keySet();\n\n\t\t// verify ALL required parameters are present\n\t\tSet<String> missing = new HashSet<String>(required);\n\t\tmissing.removeAll(actualNames);\n\t\tif (missing.size() > 0) {\n\t\t\tthrow new ValidationException( context + \": Invalid HTTP request missing parameters\", \"Invalid HTTP request missing parameters \" + missing + \": context=\" + context, context );\n\t\t}\n\n\t\t// verify ONLY optional + required parameters are present\n\t\tSet<String> extra = new HashSet<String>(actualNames);\n\t\textra.removeAll(required);\n\t\textra.removeAll(optional);\n\t\tif (extra.size() > 0) {\n\t\t\tthrow new ValidationException( context + \": Invalid HTTP request extra parameters \" + extra, \"Invalid HTTP request extra parameters \" + extra + \": context=\" + context, context );\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          925,
          942
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidCreditCard",
        "signature": "String getValidCreditCard(String,String,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          402,
          409
        ],
        "code": "\tpublic String getValidCreditCard(String context, String input, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidCreditCard(context, input, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\n\t\treturn \"\";\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          402,
          410
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidPrintable",
        "signature": "boolean isValidPrintable(String,char,int,boolean)",
        "lines_hint_csv": [
          964,
          969
        ],
        "code": "\tpublic boolean isValidPrintable(String context, char[] input, int maxLength, boolean allowNull) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidPrintable( context, input, maxLength, allowNull);\n\t\t\treturn true;\n\t\t} catch( Exception e ) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          964,
          971
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidDate",
        "signature": "Date getValidDate(String,String,DateFormat,boolean)",
        "lines_hint_csv": [
          289,
          298
        ],
        "code": "\tpublic Date getValidDate(String context, String input, DateFormat format, boolean allowNull) throws ValidationException, IntrusionException {\n\t\t\n\t\tValidationErrorList vel = new ValidationErrorList();\n\t\tDate validDate =  getValidDate(context, input, format, allowNull, vel);\n\t\t\n\t\tif (vel.isEmpty()) {\n\t\t    return validDate;\n\t\t}\n\t\t\n\t\tthrow vel.errors().get(0);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          289,
          299
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidInteger",
        "signature": "Integer getValidInteger(String,String,int,int,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          727,
          734
        ],
        "code": "\tpublic Integer getValidInteger(String context, String input, int minValue, int maxValue, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\treturn getValidInteger(context, input, minValue, maxValue, allowNull);\n\t\t} catch (ValidationException e) {\n\t\t\terrors.addError(context, e);\n\t\t}\n\t\t// error has been added to list, so return original input\n\t\treturn null;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          727,
          735
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "isValidDirectoryPath",
        "signature": "boolean isValidDirectoryPath(String,String,File,boolean,ValidationErrorList)",
        "lines_hint_csv": [
          435,
          441
        ],
        "code": "\tpublic boolean isValidDirectoryPath(String context, String input, File parent, boolean allowNull, ValidationErrorList errors) throws IntrusionException {\n\t\ttry {\n\t\t\tgetValidDirectoryPath( context, input, parent, allowNull);\n\t\t\treturn true;\n\t\t} catch( ValidationException e ) {\n            errors.addError(context, e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          435,
          443
        ]
      },
      {
        "file_path": "src/main/java/org/owasp/esapi/reference/DefaultValidator.java",
        "class_name": "DefaultValidator",
        "method_name": "getValidSafeHTML",
        "signature": "String getValidSafeHTML(String,String,int,boolean)",
        "lines_hint_csv": [
          346,
          350
        ],
        "code": "\tpublic String getValidSafeHTML( String context, String input, int maxLength, boolean allowNull ) throws ValidationException, IntrusionException {\n\t\tHTMLValidationRule hvr = new HTMLValidationRule( \"safehtml\", encoder );\n\t\thvr.setMaximumLength(maxLength);\n\t\thvr.setAllowNull(allowNull);\n\t\treturn hvr.getValid(context, input);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          346,
          351
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-29577",
    "project_slug": "nahsra__antisamy_CVE-2022-29577_1.6.6.1",
    "buggy_commit_id": "b6e76de85a07549f2c97941437dd73430d7287a8",
    "github_url": "https://github.com/nahsra/antisamy",
    "nvd_metadata": {
      "description": "OWASP AntiSamy before 1.6.7 allows XSS via HTML tag smuggling on STYLE content with crafted input. The output serializer does not properly encode the supposed Cascading Style Sheets (CSS) content. NOTE: this issue exists because of an incomplete fix for CVE-2022-28367.",
      "published_date": "2022-04-21T23:15:10.467",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/owasp/validator/html/scan/AntiSamyDOMScanner.java",
        "class_name": "AntiSamyDOMScanner",
        "method_name": "processStyleTag",
        "signature": "boolean processStyleTag(Element,Node)",
        "lines_hint_csv": [
          403,
          458
        ],
        "code": "    private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            if (ele.getChildNodes().getLength() > 0) {\n                StringBuffer toScan = new StringBuffer();\n\n                for (int i = 0; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    if (toScan.length() > 0) {\n                        toScan.append(\"\\n\");\n                    }\n                    toScan.append(childNode.getTextContent());\n                }\n\n                CleanResults cr = styleScanner.scanStyleSheet(toScan.toString(), policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                String cleanHTML = cr.getCleanHTML();\n                cleanHTML = cleanHTML == null || cleanHTML.equals(\"\") ? \"/* */\" : cleanHTML;\n\n                ele.getFirstChild().setNodeValue(cleanHTML);\n                /*\n                 * Remove every other node after cleaning CSS, there will\n                 * be only one node in the end, as it always should have.\n                 */\n                for (int i = 1; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    ele.removeChild(childNode);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          403,
          459
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "testSmuggledTagsInStyleContent",
        "signature": "void testSmuggledTagsInStyleContent()",
        "lines_hint_csv": [
          1709,
          1719
        ],
        "code": "    public void testSmuggledTagsInStyleContent() throws ScanException, PolicyException {\n        // HTML tags may be smuggled into a style tag after parsing input to an internal representation.\n        // If that happens, they should be treated as text content and not as children nodes.\n\n        Policy revised = policy.cloneWithDirective(Policy.USE_XHTML,\"true\");\n        assertThat(as.scan(\"<style/>b<![cdata[</style><a href=javascript:alert(1)>test\", revised, AntiSamy.DOM).getCleanHTML(), not(containsString(\"javascript\")));\n        assertThat(as.scan(\"<style/>b<![cdata[</style><a href=javascript:alert(1)>test\", revised, AntiSamy.SAX).getCleanHTML(), not(containsString(\"javascript\")));\n\n        Policy revised2 = policy.cloneWithDirective(Policy.USE_XHTML,\"false\");\n        assertThat(as.scan(\"<select<style/>W<xmp<script>alert(1)</script>\", revised2, AntiSamy.DOM).getCleanHTML(), not(containsString(\"script\")));\n        assertThat(as.scan(\"<select<style/>W<xmp<script>alert(1)</script>\", revised2, AntiSamy.SAX).getCleanHTML(), not(containsString(\"script\")));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1709,
          1720
        ]
      },
      {
        "file_path": "src/test/java/org/owasp/validator/html/test/AntiSamyTest.java",
        "class_name": "AntiSamyTest",
        "method_name": "testMalformedPIScan",
        "signature": "void testMalformedPIScan()",
        "lines_hint_csv": [
          1723,
          1731
        ],
        "code": "    public void testMalformedPIScan() {\n        // Certain malformed input including a malformed processing instruction may lead the parser to an internal memory error.\n        try {\n            as.scan(\"<!--><?a/\", policy, AntiSamy.DOM).getCleanHTML();\n            as.scan(\"<!--><?a/\", policy, AntiSamy.SAX).getCleanHTML();\n        } catch (ScanException ex) {\n            // It is OK, internal parser should fail.\n        } catch (Exception ex) {\n            fail(\"Parser should not throw a non-ScanException\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1723,
          1733
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-1000129",
    "project_slug": "rhuss__jolokia_CVE-2018-1000129_1.4.0",
    "buggy_commit_id": "10727cab59a8fc2ae053bec6b2f26f48f1c4245c",
    "github_url": "https://github.com/rhuss/jolokia",
    "nvd_metadata": {
      "description": "An XSS vulnerability exists in the Jolokia agent version 1.3.7 in the HTTP servlet that allows an attacker to execute malicious javascript in the victim's browser.",
      "published_date": "2018-03-14T13:29:00.237",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
        "class_name": "AgentServlet",
        "method_name": "sendStreamingResponse",
        "signature": "void sendStreamingResponse(HttpServletResponse,String,JSONStreamAware)",
        "lines_hint_csv": [
          490,
          492
        ],
        "code": "    private void sendStreamingResponse(HttpServletResponse pResp, String pCallback, JSONStreamAware pJson) throws IOException {\n        Writer writer = new OutputStreamWriter(pResp.getOutputStream(), \"UTF-8\");\n        IoUtil.streamResponseAndClose(writer, pJson, pCallback);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          490,
          493
        ]
      },
      {
        "file_path": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
        "class_name": "AgentServlet",
        "method_name": "getMimeType",
        "signature": "String getMimeType(HttpServletRequest)",
        "lines_hint_csv": [
          384,
          389
        ],
        "code": "    private String getMimeType(HttpServletRequest pReq) {\n        String requestMimeType = pReq.getParameter(ConfigKey.MIME_TYPE.getKeyValue());\n        if (requestMimeType != null) {\n            return requestMimeType;\n        }\n        return configMimeType;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          384,
          390
        ]
      },
      {
        "file_path": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
        "class_name": "AgentServlet",
        "method_name": "sendResponse",
        "signature": "void sendResponse(HttpServletResponse,HttpServletRequest,JSONAware)",
        "lines_hint_csv": [
          471,
          485
        ],
        "code": "    private void sendResponse(HttpServletResponse pResp, HttpServletRequest pReq, JSONAware pJson) throws IOException {\n        String callback = pReq.getParameter(ConfigKey.CALLBACK.getKeyValue());\n        setContentType(pResp, callback != null ? \"text/javascript\" : getMimeType(pReq));\n\n        pResp.setStatus(HttpServletResponse.SC_OK);\n        setNoCacheHeaders(pResp);\n        if (pJson == null) {\n            pResp.setContentLength(-1);\n        } else {\n            if (isStreamingEnabled(pReq)) {\n                sendStreamingResponse(pResp, callback, (JSONStreamAware) pJson);\n            } else {\n                // Fallback, send as one object\n                // TODO: Remove for 2.0 where should support only streaming\n                sendAllJSON(pResp, callback, pJson);\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          471,
          488
        ]
      },
      {
        "file_path": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
        "class_name": "AgentServlet",
        "method_name": "sendAllJSON",
        "signature": "void sendAllJSON(HttpServletResponse,String,JSONAware)",
        "lines_hint_csv": [
          495,
          508
        ],
        "code": "    private void sendAllJSON(HttpServletResponse pResp, String callback, JSONAware pJson) throws IOException {\n        OutputStream out = null;\n        try {\n            String json = pJson.toJSONString();\n            String content = callback == null ? json : callback + \"(\" + json + \");\";\n            byte[] response = content.getBytes(\"UTF8\");\n            pResp.setContentLength(response.length);\n            out = pResp.getOutputStream();\n            out.write(response);\n        } finally {\n            if (out != null) {\n                // Always close in order to finish the request.\n                // Otherwise the thread blocks.\n                out.close();\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          495,
          511
        ]
      },
      {
        "file_path": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
        "class_name": "AgentServlet",
        "method_name": "isStreamingEnabled",
        "signature": "boolean isStreamingEnabled(HttpServletRequest)",
        "lines_hint_csv": [
          392,
          397
        ],
        "code": "    private boolean isStreamingEnabled(HttpServletRequest pReq) {\n        String streamingFromReq = pReq.getParameter(ConfigKey.STREAMING.getKeyValue());\n        if (streamingFromReq != null) {\n            return Boolean.parseBoolean(streamingFromReq);\n        }\n        return streamingEnabled;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          392,
          398
        ]
      },
      {
        "file_path": "agent/core/src/main/java/org/jolokia/http/AgentServlet.java",
        "class_name": "AgentServlet",
        "method_name": "handleSecurely",
        "signature": "JSONAware handleSecurely(ServletRequestHandler,HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          292,
          301
        ],
        "code": "    private JSONAware handleSecurely(final ServletRequestHandler pReqHandler, final HttpServletRequest pReq, final HttpServletResponse pResp) throws IOException, PrivilegedActionException {\n        Subject subject = (Subject) pReq.getAttribute(ConfigKey.JAAS_SUBJECT_REQUEST_ATTRIBUTE);\n        if (subject != null) {\n            return Subject.doAs(subject, new PrivilegedExceptionAction<JSONAware>() {\n                    public JSONAware run() throws IOException {\n                        return pReqHandler.handleRequest(pReq, pResp);\n                    }\n            });\n        } else {\n            return pReqHandler.handleRequest(pReq, pResp);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          292,
          303
        ]
      },
      {
        "file_path": "agent/core/src/test/java/org/jolokia/http/AgentServletTest.java",
        "class_name": "AgentServletTest",
        "method_name": "debug",
        "signature": "void debug()",
        "lines_hint_csv": [
          526,
          549
        ],
        "code": "    public void debug() throws IOException, ServletException {\n        servlet = new AgentServlet();\n        initConfigMocks(new String[]{ConfigKey.DEBUG.getKeyValue(), \"true\"},null,\"No access restrictor found\",null);\n        context.log(find(\"URI:\"));\n        context.log(find(\"Path-Info:\"));\n        context.log(find(\"Request:\"));\n        context.log(find(\"time:\"));\n        context.log(find(\"Response:\"));\n        context.log(find(\"TestDetector\"),isA(RuntimeException.class));\n        expectLastCall().asStub();\n        replay(config, context);\n\n        servlet.init(config);\n\n        ByteArrayOutputStream sw = initRequestResponseMocks();\n        expect(request.getPathInfo()).andReturn(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n        expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(null);\n        expect(request.getAttribute(\"subject\")).andReturn(null);\n        replay(request, response);\n\n        servlet.doGet(request, response);\n\n        assertTrue(sw.toString().contains(\"used\"));\n        servlet.destroy();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          526,
          550
        ]
      },
      {
        "file_path": "agent/core/src/test/java/org/jolokia/http/AgentServletTest.java",
        "class_name": "NoDnsLookupRestrictorChecker",
        "method_name": "isRemoteAccessAllowed",
        "signature": "boolean isRemoteAccessAllowed(String)",
        "lines_hint_csv": [
          293,
          302
        ],
        "code": "        public boolean isRemoteAccessAllowed(String... pHostOrAddress) {\n            if (expectedHosts.length != pHostOrAddress.length) {\n                return false;\n            }\n            for (int i = 0; i < expectedHosts.length; i++) {\n                if (!expectedHosts[i].equals(pHostOrAddress[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          293,
          303
        ]
      },
      {
        "file_path": "agent/core/src/test/java/org/jolokia/http/AgentServletTest.java",
        "class_name": "AgentServletTest",
        "method_name": "setupAgentDetailsInitExpectations",
        "signature": "void setupAgentDetailsInitExpectations()",
        "lines_hint_csv": [
          674,
          678
        ],
        "code": "    private void setupAgentDetailsInitExpectations() {\n        expect(request.getRequestURI()).andReturn(\"/jolokia/\");\n        expect(request.getRequestURL()).andReturn(new StringBuffer(\"http://localhost/jolokia\"));\n        expect(request.getContextPath()).andReturn(\"/jolokia/\");\n        expect(request.getAuthType()).andReturn(null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          674,
          679
        ]
      },
      {
        "file_path": "agent/core/src/test/java/org/jolokia/http/AgentServletTest.java",
        "class_name": "AgentServletTest",
        "method_name": "simpleGet",
        "signature": "void simpleGet()",
        "lines_hint_csv": [
          239,
          251
        ],
        "code": "    public void simpleGet() throws ServletException, IOException {\n        prepareStandardInitialisation();\n\n        ByteArrayOutputStream sw = initRequestResponseMocks();\n        expect(request.getPathInfo()).andReturn(HttpTestUtil.HEAP_MEMORY_GET_REQUEST);\n        expect(request.getParameter(ConfigKey.MIME_TYPE.getKeyValue())).andReturn(\"text/plain\");\n        expect(request.getAttribute(\"subject\")).andReturn(null);\n        replay(request, response);\n\n        servlet.doGet(request, response);\n\n        assertTrue(sw.toString().contains(\"used\"));\n        servlet.destroy();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          239,
          252
        ]
      },
      {
        "file_path": "agent/jvm/src/main/java/org/jolokia/jvmagent/handler/JolokiaHttpHandler.java",
        "class_name": "JolokiaHttpHandler",
        "method_name": "doHandle",
        "signature": "void doHandle(HttpExchange)",
        "lines_hint_csv": [
          211,
          243
        ],
        "code": "    public void doHandle(HttpExchange pExchange) throws IOException {\n        if (requestHandler == null) {\n            throw new IllegalStateException(\"Handler not yet started\");\n        }\n\n        JSONAware json = null;\n        URI uri = pExchange.getRequestURI();\n        ParsedUri parsedUri = new ParsedUri(uri, context);\n        try {\n            // Check access policy\n            InetSocketAddress address = pExchange.getRemoteAddress();\n            requestHandler.checkAccess(getHostName(address),\n                                       address.getAddress().getHostAddress(),\n                                       extractOriginOrReferer(pExchange));\n            String method = pExchange.getRequestMethod();\n\n            // Dispatch for the proper HTTP request method\n            if (\"GET\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executeGetRequest(parsedUri);\n            } else if (\"POST\".equalsIgnoreCase(method)) {\n                setHeaders(pExchange);\n                json = executePostRequest(pExchange, parsedUri);\n            } else if (\"OPTIONS\".equalsIgnoreCase(method)) {\n                performCorsPreflightCheck(pExchange);\n            } else {\n                throw new IllegalArgumentException(\"HTTP Method \" + method + \" is not supported.\");\n            }\n        } catch (Throwable exp) {\n            json = requestHandler.handleThrowable(\n                    exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);\n        } finally {\n            sendResponse(pExchange, parsedUri, json);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          211,
          245
        ]
      },
      {
        "file_path": "agent/jvm/src/main/java/org/jolokia/jvmagent/handler/JolokiaHttpHandler.java",
        "class_name": "JolokiaHttpHandler",
        "method_name": "sendAllJSON",
        "signature": "void sendAllJSON(HttpExchange,ParsedUri,JSONAware)",
        "lines_hint_csv": [
          355,
          376
        ],
        "code": "    private void sendAllJSON(HttpExchange pExchange, ParsedUri pParsedUri, JSONAware pJson) throws IOException {\n        OutputStream out = null;\n        try {\n            Headers headers = pExchange.getResponseHeaders();\n            if (pJson != null) {\n                headers.set(\"Content-Type\", getMimeType(pParsedUri) + \"; charset=utf-8\");\n                String json = pJson.toJSONString();\n                String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());\n                String content = callback == null ? json : callback + \"(\" + json + \");\";\n                byte[] response = content.getBytes(\"UTF8\");\n                pExchange.sendResponseHeaders(200,response.length);\n                out = pExchange.getResponseBody();\n                out.write(response);\n            } else {\n                headers.set(\"Content-Type\", \"text/plain\");\n                pExchange.sendResponseHeaders(200,-1);\n            }\n        } finally {\n            if (out != null) {\n                // Always close in order to finish the request.\n                // Otherwise the thread blocks.\n                out.close();\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          355,
          379
        ]
      },
      {
        "file_path": "agent/jvm/src/main/java/org/jolokia/jvmagent/handler/JolokiaHttpHandler.java",
        "class_name": "JolokiaHttpHandler",
        "method_name": "createLogHandler",
        "signature": "LogHandler createLogHandler(String,String)",
        "lines_hint_csv": [
          397,
          402
        ],
        "code": "    private LogHandler createLogHandler(String pLogHandlerClass, String pDebug) {\n        if (pLogHandlerClass != null) {\n            return ClassUtil.newInstance(pLogHandlerClass);\n        } else {\n            final boolean debug = Boolean.valueOf(pDebug);\n            return new LogHandler.StdoutLogHandler(debug);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          397,
          404
        ]
      },
      {
        "file_path": "agent/jvm/src/main/java/org/jolokia/jvmagent/handler/JolokiaHttpHandler.java",
        "class_name": "JolokiaHttpHandler",
        "method_name": "getHostName",
        "signature": "String getHostName(InetSocketAddress)",
        "lines_hint_csv": [
          260,
          261
        ],
        "code": "    private String getHostName(InetSocketAddress address) {\n        return configuration.getAsBoolean(ConfigKey.ALLOW_DNS_REVERSE_LOOKUP) ? address.getHostName() : null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          260,
          262
        ]
      },
      {
        "file_path": "agent/jvm/src/test/java/org/jolokia/jvmagent/handler/JolokiaHttpHandlerTest.java",
        "class_name": "JolokiaHttpHandlerTest",
        "method_name": "customRestrictor",
        "signature": "void customRestrictor()",
        "lines_hint_csv": [
          136,
          148
        ],
        "code": "    public void customRestrictor() throws URISyntaxException, IOException, ParseException {\n        System.setProperty(\"jolokia.test1.policy.location\",\"access-restrictor.xml\");\n        System.setProperty(\"jolokia.test2.policy.location\",\"access-restrictor\");\n        for (String[] params : new String[][] {\n                {\"classpath:/access-restrictor.xml\",\"not allowed\"},\n                {\"file:///not-existing.xml\",\"No access\"},\n                {\"classpath:/${prop:jolokia.test1.policy.location}\", \"not allowed\"},\n                {\"classpath:/${prop:jolokia.test2.policy.location}.xml\", \"not allowed\"}\n        }) {\n            Configuration config = getConfig(ConfigKey.POLICY_LOCATION,params[0]);\n            JSONObject resp = simpleMemoryGetReadRequest(config);\n            assertTrue(resp.containsKey(\"error\"));\n            assertTrue(((String) resp.get(\"error\")).contains(params[1]));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          136,
          150
        ]
      },
      {
        "file_path": "agent/jvm/src/test/java/org/jolokia/jvmagent/handler/JolokiaHttpHandlerTest.java",
        "class_name": "JolokiaHttpHandlerTest",
        "method_name": "testCallbackGet",
        "signature": "void testCallbackGet()",
        "lines_hint_csv": [
          60,
          74
        ],
        "code": "    public void testCallbackGet() throws IOException, URISyntaxException {\n        HttpExchange exchange = prepareExchange(\"http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage?callback=data\");\n\n        // Simple GET method\n        expect(exchange.getRequestMethod()).andReturn(\"GET\");\n\n        Headers header = new Headers();\n        ByteArrayOutputStream out = prepareResponse(handler, exchange, header);\n\n        handler.doHandle(exchange);\n\n        assertEquals(header.getFirst(\"content-type\"),\"text/javascript; charset=utf-8\");\n        String result = out.toString(\"utf-8\");\n        assertTrue(result.endsWith(\"});\"));\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          60,
          73
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2014-3656",
    "project_slug": "keycloak__keycloak_CVE-2014-3656_1.0.5.Final",
    "buggy_commit_id": "3b071b83aa0444749eba851fdbe0f2ed47932410",
    "github_url": "https://github.com/keycloak/keycloak",
    "nvd_metadata": {
      "description": "JBoss KeyCloak: XSS in login-status-iframe.html",
      "published_date": "2019-12-10T14:15:11.250",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "core/src/main/java/org/keycloak/util/UriUtils.java",
        "class_name": "UriUtils",
        "method_name": "getOrigin",
        "signature": "String getOrigin(String)",
        "lines_hint_csv": [
          14,
          16
        ],
        "code": "    public static String getOrigin(URI uri) {\n        return getOrigin(uri.toString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          13,
          15
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/OpenIDConnectService.java",
        "class_name": "OpenIDConnectService",
        "method_name": "getLoginStatusIframe",
        "signature": "Response getLoginStatusIframe(String,String)",
        "lines_hint_csv": [
          189,
          233
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2016-6812",
    "project_slug": "asf__cxf_CVE-2016-6812_3.0.11",
    "buggy_commit_id": "6c7df35913ce3fc6ec8f5dc6c6074b187f751aa6",
    "github_url": "https://github.com/apache/cxf",
    "nvd_metadata": {
      "description": "The HTTP transport module in Apache CXF prior to 3.0.12 and 3.1.x prior to 3.1.9 uses FormattedServiceListWriter to provide an HTML page which lists the names and absolute URL addresses of the available service endpoints. The module calculates the base URL using the current HttpServletRequest. The calculated base URL is used by FormattedServiceListWriter to build the service endpoint absolute URLs. If the unexpected matrix parameters have been injected into the request URL then these matrix parameters will find their way back to the client in the services list page which represents an XSS risk to the client.",
      "published_date": "2017-08-10T16:29:00.657",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/BaseUrlHelper.java",
        "class_name": "BaseUrlHelper",
        "method_name": "setAddress",
        "signature": "void setAddress(AbstractDestination,String)",
        "lines_hint_csv": [
          63,
          66
        ],
        "code": "    public static void setAddress(AbstractDestination dest, String absAddress) {\n        dest.getEndpointInfo().setAddress(absAddress);\n        if (dest.getEndpointInfo().getExtensor(AddressType.class) != null) {\n            dest.getEndpointInfo().getExtensor(AddressType.class).setLocation(absAddress);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          63,
          68
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/BaseUrlHelper.java",
        "class_name": "BaseUrlHelper",
        "method_name": "getBaseURL",
        "signature": "String getBaseURL(HttpServletRequest)",
        "lines_hint_csv": [
          37,
          59
        ],
        "code": "    public static String getBaseURL(HttpServletRequest request) {\n        String reqPrefix = request.getRequestURL().toString();        \n        String pathInfo = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n        //fix for CXF-898\n        if (!\"/\".equals(pathInfo) || reqPrefix.endsWith(\"/\")) {\n            StringBuilder sb = new StringBuilder();\n            // request.getScheme(), request.getLocalName() and request.getLocalPort()\n            // should be marginally cheaper - provided request.getLocalName() does \n            // return the actual name used in request URI as opposed to localhost\n            // consistently across the Servlet stacks\n            \n            URI uri = URI.create(reqPrefix);\n            sb.append(uri.getScheme()).append(\"://\").append(uri.getRawAuthority());\n            if (request.getContextPath() != null) {\n                sb.append(request.getContextPath());\n            }\n            if (request.getServletPath() != null) {\n                sb.append(request.getServletPath());\n            }\n            \n            reqPrefix = sb.toString();\n        }\n        return reqPrefix;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          37,
          60
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "getAbsoluteAddress",
        "signature": "String getAbsoluteAddress(String,AbstractDestination)",
        "lines_hint_csv": [
          123,
          136
        ],
        "code": "    private String getAbsoluteAddress(String basePath, AbstractDestination d) {\n        String endpointAddress = (String)d.getEndpointInfo().getProperty(\"publishedEndpointUrl\");\n        if (endpointAddress != null) {\n            return endpointAddress;\n        }\n        endpointAddress = d.getEndpointInfo().getAddress();\n        if (endpointAddress.startsWith(\"http://\") || endpointAddress.startsWith(\"https://\")) {\n            if (endpointAddress.startsWith(basePath) || showForeignContexts) {\n                return endpointAddress;\n            } else {\n                return null;\n            }\n        } else {\n            return basePath + endpointAddress;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          123,
          138
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "writeRESTfulEndpoints",
        "signature": "void writeRESTfulEndpoints(PrintWriter,String,AbstractDestination)",
        "lines_hint_csv": [
          140,
          150
        ],
        "code": "    private void writeRESTfulEndpoints(PrintWriter writer, \n                                       String basePath, \n                                       AbstractDestination[] restfulDests)\n        throws IOException {\n        writer.write(\"<span class=\\\"heading\\\">Available RESTful services:</span><br/>\");\n        writer.write(\"<table \" + (styleSheetPath.endsWith(\"stylesheet=1\")\n            ? \"cellpadding=\\\"1\\\" cellspacing=\\\"1\\\" border=\\\"1\\\" width=\\\"100%\\\"\" : \"\") + \">\");\n        for (AbstractDestination sd : restfulDests) {\n            writeRESTfulEndpoint(writer, basePath, sd);\n        }\n        writer.write(\"</table>\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          140,
          151
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/ServiceListGeneratorServlet.java",
        "class_name": "ServiceListGeneratorServlet",
        "method_name": "service",
        "signature": "void service(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          68,
          126
        ],
        "code": "    public void service(HttpServletRequest request, \n                        HttpServletResponse response) throws ServletException, IOException {\n        Object obj = request.getAttribute(ServletController.AUTH_SERVICE_LIST);\n        boolean isAuthServiceList = false;\n        if (obj != null) {\n            isAuthServiceList = Boolean.valueOf(obj.toString());\n        }\n        if (isAuthServiceList) {\n            String authServiceListRealm = (String)request.getAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n            ServiceListJAASAuthenticator authenticator = new ServiceListJAASAuthenticator();\n            authenticator.setRealm(authServiceListRealm);\n            if (!authenticator.authenticate(request, response)) {\n                return;\n            }\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST);\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n        }\n        AbstractDestination[] destinations = destinationRegistry.getSortedDestinations();\n        if (request.getParameter(\"stylesheet\") != null) {\n            renderStyleSheet(request, response);\n            return;\n        }\n        List<String> privateEndpoints;\n        Map<String, String> atomMap;\n        \n        if (bus != null) {\n            privateEndpoints = (List<String>)bus.getProperty(\"org.apache.cxf.private.endpoints\");\n            // TODO : we may introduce a bus extension instead\n\n            atomMap = (Map<String, String>)bus\n                .getProperty(\"org.apache.cxf.extensions.logging.atom.pull\");\n        } else {\n            privateEndpoints = new ArrayList<String>();\n            atomMap = new HashMap<String, String>();\n        }\n        \n        AbstractDestination[] soapEndpoints = getSOAPEndpoints(destinations, privateEndpoints);\n        AbstractDestination[] restEndpoints = getRestEndpoints(destinations, privateEndpoints);\n        ServiceListWriter serviceListWriter;\n        if (\"false\".equals(request.getParameter(\"formatted\"))) {\n            boolean renderWsdlList = \"true\".equals(request.getParameter(\"wsdlList\"));\n            serviceListWriter = new UnformattedServiceListWriter(renderWsdlList);\n        } else {\n            String styleSheetPath;\n            if (serviceListStyleSheet != null) {\n                styleSheetPath = request.getContextPath() + \"/\" + serviceListStyleSheet;\n                \n            } else {\n                styleSheetPath = request.getRequestURI() + \"/?stylesheet=1\";\n            }\n            serviceListWriter = \n                new FormattedServiceListWriter(styleSheetPath, title, showForeignContexts, atomMap);\n            \n        }\n        response.setContentType(serviceListWriter.getContentType());\n        Object basePath = request.getAttribute(Message.BASE_PATH);\n        serviceListWriter.writeServiceList(response.getWriter(),\n                                           basePath == null ? null : basePath.toString(),\n                                           soapEndpoints, restEndpoints);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          68,
          127
        ]
      },
      {
        "file_path": "systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerSpringBookTest.java",
        "class_name": "JAXRSClientServerSpringBookTest",
        "method_name": "testGetGenericBook",
        "signature": "void testGetGenericBook()",
        "lines_hint_csv": [
          85,
          92
        ],
        "code": "    public void testGetGenericBook() throws Exception {\n        String baseAddress = \"http://localhost:\" + PORT + \"/the/thebooks8/books\"; \n        WebClient wc = WebClient.create(baseAddress);\n        WebClient.getConfig(wc).getHttpConduit().getClient().setReceiveTimeout(10000000);\n        Long id = wc.type(\"application/xml\").accept(\"text/plain\").post(new Book(\"CXF\", 1L), Long.class);\n        assertEquals(new Long(1), id);\n        Book book = wc.replaceHeader(\"Accept\", \"application/xml\").query(\"id\", 1L).get(Book.class);\n        assertEquals(\"CXF\", book.getName());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          85,
          93
        ]
      },
      {
        "file_path": "distribution/src/main/release/samples/jax_rs/spring_boot/src/main/java/sample/rs/service/SampleRestApplication.java",
        "class_name": "SampleRestApplication",
        "method_name": "rsServer",
        "signature": "Server rsServer()",
        "lines_hint_csv": [
          44,
          50
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/BaseUrlHelper.java",
        "class_name": "BaseUrlHelper",
        "method_name": "getBaseURL",
        "signature": "String getBaseURL(HttpServletRequest)",
        "lines_hint_csv": [
          37,
          64
        ],
        "code": "    public static String getBaseURL(HttpServletRequest request) {\n        String reqPrefix = request.getRequestURL().toString();        \n        String pathInfo = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n        //fix for CXF-898\n        if (!\"/\".equals(pathInfo) || reqPrefix.endsWith(\"/\")) {\n            StringBuilder sb = new StringBuilder();\n            // request.getScheme(), request.getLocalName() and request.getLocalPort()\n            // should be marginally cheaper - provided request.getLocalName() does \n            // return the actual name used in request URI as opposed to localhost\n            // consistently across the Servlet stacks\n            \n            URI uri = URI.create(reqPrefix);\n            sb.append(uri.getScheme()).append(\"://\").append(uri.getRawAuthority());\n            if (request.getContextPath() != null) {\n                sb.append(request.getContextPath());\n            }\n            if (request.getServletPath() != null) {\n                sb.append(request.getServletPath());\n            }\n            \n            reqPrefix = sb.toString();\n        }\n        return reqPrefix;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          37,
          60
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/ServiceListGeneratorServlet.java",
        "class_name": "ServiceListGeneratorServlet",
        "method_name": "service",
        "signature": "void service(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          66,
          125
        ],
        "code": "    public void service(HttpServletRequest request, \n                        HttpServletResponse response) throws ServletException, IOException {\n        Object obj = request.getAttribute(ServletController.AUTH_SERVICE_LIST);\n        boolean isAuthServiceList = false;\n        if (obj != null) {\n            isAuthServiceList = Boolean.valueOf(obj.toString());\n        }\n        if (isAuthServiceList) {\n            String authServiceListRealm = (String)request.getAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n            ServiceListJAASAuthenticator authenticator = new ServiceListJAASAuthenticator();\n            authenticator.setRealm(authServiceListRealm);\n            if (!authenticator.authenticate(request, response)) {\n                return;\n            }\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST);\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n        }\n        AbstractDestination[] destinations = destinationRegistry.getSortedDestinations();\n        if (request.getParameter(\"stylesheet\") != null) {\n            renderStyleSheet(request, response);\n            return;\n        }\n        List<String> privateEndpoints;\n        Map<String, String> atomMap;\n        \n        if (bus != null) {\n            privateEndpoints = (List<String>)bus.getProperty(\"org.apache.cxf.private.endpoints\");\n            // TODO : we may introduce a bus extension instead\n\n            atomMap = (Map<String, String>)bus\n                .getProperty(\"org.apache.cxf.extensions.logging.atom.pull\");\n        } else {\n            privateEndpoints = new ArrayList<String>();\n            atomMap = new HashMap<String, String>();\n        }\n        \n        AbstractDestination[] soapEndpoints = getSOAPEndpoints(destinations, privateEndpoints);\n        AbstractDestination[] restEndpoints = getRestEndpoints(destinations, privateEndpoints);\n        ServiceListWriter serviceListWriter;\n        if (\"false\".equals(request.getParameter(\"formatted\"))) {\n            boolean renderWsdlList = \"true\".equals(request.getParameter(\"wsdlList\"));\n            serviceListWriter = new UnformattedServiceListWriter(renderWsdlList);\n        } else {\n            String styleSheetPath;\n            if (serviceListStyleSheet != null) {\n                styleSheetPath = request.getContextPath() + \"/\" + serviceListStyleSheet;\n                \n            } else {\n                styleSheetPath = request.getRequestURI() + \"/?stylesheet=1\";\n            }\n            serviceListWriter = \n                new FormattedServiceListWriter(styleSheetPath, title, showForeignContexts, atomMap);\n            \n        }\n        response.setContentType(serviceListWriter.getContentType());\n        Object basePath = request.getAttribute(Message.BASE_PATH);\n        serviceListWriter.writeServiceList(response.getWriter(),\n                                           basePath == null ? null : basePath.toString(),\n                                           soapEndpoints, restEndpoints);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          68,
          127
        ]
      },
      {
        "file_path": "systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerSpringBookTest.java",
        "class_name": "JAXRSClientServerSpringBookTest",
        "method_name": "testEchoBookForm3",
        "signature": "void testEchoBookForm3()",
        "lines_hint_csv": [
          148,
          150
        ],
        "code": "    public void testEchoBookForm3() throws Exception {\n        String address = \"http://localhost:\" + PORT + \"/bus/thebooksform/bookform3\";\n        doTestEchoBookForm(address);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          124
        ]
      },
      {
        "file_path": "systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerSpringBookTest.java",
        "class_name": "JAXRSClientServerSpringBookTest",
        "method_name": "testGetServicesPageWithServletPatternMatchOnly",
        "signature": "void testGetServicesPageWithServletPatternMatchOnly()",
        "lines_hint_csv": [
          127,
          134
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/BaseUrlHelper.java",
        "class_name": "BaseUrlHelper",
        "method_name": "getBaseURL",
        "signature": "String getBaseURL(HttpServletRequest)",
        "lines_hint_csv": [
          37,
          59
        ],
        "code": "    public static String getBaseURL(HttpServletRequest request) {\n        String reqPrefix = request.getRequestURL().toString();        \n        String pathInfo = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n        //fix for CXF-898\n        if (!\"/\".equals(pathInfo) || reqPrefix.endsWith(\"/\")) {\n            StringBuilder sb = new StringBuilder();\n            // request.getScheme(), request.getLocalName() and request.getLocalPort()\n            // should be marginally cheaper - provided request.getLocalName() does \n            // return the actual name used in request URI as opposed to localhost\n            // consistently across the Servlet stacks\n            \n            URI uri = URI.create(reqPrefix);\n            sb.append(uri.getScheme()).append(\"://\").append(uri.getRawAuthority());\n            if (request.getContextPath() != null) {\n                sb.append(request.getContextPath());\n            }\n            if (request.getServletPath() != null) {\n                sb.append(request.getServletPath());\n            }\n            \n            reqPrefix = sb.toString();\n        }\n        return reqPrefix;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          37,
          60
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/BaseUrlHelper.java",
        "class_name": "BaseUrlHelper",
        "method_name": "setAddress",
        "signature": "void setAddress(AbstractDestination,String)",
        "lines_hint_csv": [
          63,
          66
        ],
        "code": "    public static void setAddress(AbstractDestination dest, String absAddress) {\n        dest.getEndpointInfo().setAddress(absAddress);\n        if (dest.getEndpointInfo().getExtensor(AddressType.class) != null) {\n            dest.getEndpointInfo().getExtensor(AddressType.class).setLocation(absAddress);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          63,
          68
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "getAbsoluteAddress",
        "signature": "String getAbsoluteAddress(String,AbstractDestination)",
        "lines_hint_csv": [
          136,
          149
        ],
        "code": "    private String getAbsoluteAddress(String basePath, AbstractDestination d) {\n        String endpointAddress = (String)d.getEndpointInfo().getProperty(\"publishedEndpointUrl\");\n        if (endpointAddress != null) {\n            return endpointAddress;\n        }\n        endpointAddress = d.getEndpointInfo().getAddress();\n        if (endpointAddress.startsWith(\"http://\") || endpointAddress.startsWith(\"https://\")) {\n            if (endpointAddress.startsWith(basePath) || showForeignContexts) {\n                return endpointAddress;\n            } else {\n                return null;\n            }\n        } else {\n            return basePath + endpointAddress;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          123,
          138
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/FormattedServiceListWriter.java",
        "class_name": "FormattedServiceListWriter",
        "method_name": "writeRESTfulEndpoints",
        "signature": "void writeRESTfulEndpoints(PrintWriter,String,AbstractDestination)",
        "lines_hint_csv": [
          153,
          163
        ],
        "code": "    private void writeRESTfulEndpoints(PrintWriter writer, \n                                       String basePath, \n                                       AbstractDestination[] restfulDests)\n        throws IOException {\n        writer.write(\"<span class=\\\"heading\\\">Available RESTful services:</span><br/>\");\n        writer.write(\"<table \" + (styleSheetPath.endsWith(\"stylesheet=1\")\n            ? \"cellpadding=\\\"1\\\" cellspacing=\\\"1\\\" border=\\\"1\\\" width=\\\"100%\\\"\" : \"\") + \">\");\n        for (AbstractDestination sd : restfulDests) {\n            writeRESTfulEndpoint(writer, basePath, sd);\n        }\n        writer.write(\"</table>\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          140,
          151
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/ServiceListGeneratorServlet.java",
        "class_name": "ServiceListGeneratorServlet",
        "method_name": "service",
        "signature": "void service(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          66,
          117
        ],
        "code": "    public void service(HttpServletRequest request, \n                        HttpServletResponse response) throws ServletException, IOException {\n        Object obj = request.getAttribute(ServletController.AUTH_SERVICE_LIST);\n        boolean isAuthServiceList = false;\n        if (obj != null) {\n            isAuthServiceList = Boolean.valueOf(obj.toString());\n        }\n        if (isAuthServiceList) {\n            String authServiceListRealm = (String)request.getAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n            ServiceListJAASAuthenticator authenticator = new ServiceListJAASAuthenticator();\n            authenticator.setRealm(authServiceListRealm);\n            if (!authenticator.authenticate(request, response)) {\n                return;\n            }\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST);\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n        }\n        AbstractDestination[] destinations = destinationRegistry.getSortedDestinations();\n        if (request.getParameter(\"stylesheet\") != null) {\n            renderStyleSheet(request, response);\n            return;\n        }\n        List<String> privateEndpoints;\n        Map<String, String> atomMap;\n        \n        if (bus != null) {\n            privateEndpoints = (List<String>)bus.getProperty(\"org.apache.cxf.private.endpoints\");\n            // TODO : we may introduce a bus extension instead\n\n            atomMap = (Map<String, String>)bus\n                .getProperty(\"org.apache.cxf.extensions.logging.atom.pull\");\n        } else {\n            privateEndpoints = new ArrayList<String>();\n            atomMap = new HashMap<String, String>();\n        }\n        \n        AbstractDestination[] soapEndpoints = getSOAPEndpoints(destinations, privateEndpoints);\n        AbstractDestination[] restEndpoints = getRestEndpoints(destinations, privateEndpoints);\n        ServiceListWriter serviceListWriter;\n        if (\"false\".equals(request.getParameter(\"formatted\"))) {\n            boolean renderWsdlList = \"true\".equals(request.getParameter(\"wsdlList\"));\n            serviceListWriter = new UnformattedServiceListWriter(renderWsdlList);\n        } else {\n            String styleSheetPath;\n            if (serviceListStyleSheet != null) {\n                styleSheetPath = request.getContextPath() + \"/\" + serviceListStyleSheet;\n                \n            } else {\n                styleSheetPath = request.getRequestURI() + \"/?stylesheet=1\";\n            }\n            serviceListWriter = \n                new FormattedServiceListWriter(styleSheetPath, title, showForeignContexts, atomMap);\n            \n        }\n        response.setContentType(serviceListWriter.getContentType());\n        Object basePath = request.getAttribute(Message.BASE_PATH);\n        serviceListWriter.writeServiceList(response.getWriter(),\n                                           basePath == null ? null : basePath.toString(),\n                                           soapEndpoints, restEndpoints);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          68,
          127
        ]
      },
      {
        "file_path": "systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerSpringBookTest.java",
        "class_name": "JAXRSClientServerSpringBookTest",
        "method_name": "testGetGenericBook",
        "signature": "void testGetGenericBook()",
        "lines_hint_csv": [
          85,
          92
        ],
        "code": "    public void testGetGenericBook() throws Exception {\n        String baseAddress = \"http://localhost:\" + PORT + \"/the/thebooks8/books\"; \n        WebClient wc = WebClient.create(baseAddress);\n        WebClient.getConfig(wc).getHttpConduit().getClient().setReceiveTimeout(10000000);\n        Long id = wc.type(\"application/xml\").accept(\"text/plain\").post(new Book(\"CXF\", 1L), Long.class);\n        assertEquals(new Long(1), id);\n        Book book = wc.replaceHeader(\"Accept\", \"application/xml\").query(\"id\", 1L).get(Book.class);\n        assertEquals(\"CXF\", book.getName());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          85,
          93
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/BaseUrlHelper.java",
        "class_name": "BaseUrlHelper",
        "method_name": "getBaseURL",
        "signature": "String getBaseURL(HttpServletRequest)",
        "lines_hint_csv": [
          37,
          64
        ],
        "code": "    public static String getBaseURL(HttpServletRequest request) {\n        String reqPrefix = request.getRequestURL().toString();        \n        String pathInfo = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n        //fix for CXF-898\n        if (!\"/\".equals(pathInfo) || reqPrefix.endsWith(\"/\")) {\n            StringBuilder sb = new StringBuilder();\n            // request.getScheme(), request.getLocalName() and request.getLocalPort()\n            // should be marginally cheaper - provided request.getLocalName() does \n            // return the actual name used in request URI as opposed to localhost\n            // consistently across the Servlet stacks\n            \n            URI uri = URI.create(reqPrefix);\n            sb.append(uri.getScheme()).append(\"://\").append(uri.getRawAuthority());\n            if (request.getContextPath() != null) {\n                sb.append(request.getContextPath());\n            }\n            if (request.getServletPath() != null) {\n                sb.append(request.getServletPath());\n            }\n            \n            reqPrefix = sb.toString();\n        }\n        return reqPrefix;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          37,
          60
        ]
      },
      {
        "file_path": "rt/transports/http/src/main/java/org/apache/cxf/transport/servlet/servicelist/ServiceListGeneratorServlet.java",
        "class_name": "ServiceListGeneratorServlet",
        "method_name": "service",
        "signature": "void service(HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          68,
          134
        ],
        "code": "    public void service(HttpServletRequest request, \n                        HttpServletResponse response) throws ServletException, IOException {\n        Object obj = request.getAttribute(ServletController.AUTH_SERVICE_LIST);\n        boolean isAuthServiceList = false;\n        if (obj != null) {\n            isAuthServiceList = Boolean.valueOf(obj.toString());\n        }\n        if (isAuthServiceList) {\n            String authServiceListRealm = (String)request.getAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n            ServiceListJAASAuthenticator authenticator = new ServiceListJAASAuthenticator();\n            authenticator.setRealm(authServiceListRealm);\n            if (!authenticator.authenticate(request, response)) {\n                return;\n            }\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST);\n            request.removeAttribute(ServletController.AUTH_SERVICE_LIST_REALM);\n        }\n        AbstractDestination[] destinations = destinationRegistry.getSortedDestinations();\n        if (request.getParameter(\"stylesheet\") != null) {\n            renderStyleSheet(request, response);\n            return;\n        }\n        List<String> privateEndpoints;\n        Map<String, String> atomMap;\n        \n        if (bus != null) {\n            privateEndpoints = (List<String>)bus.getProperty(\"org.apache.cxf.private.endpoints\");\n            // TODO : we may introduce a bus extension instead\n\n            atomMap = (Map<String, String>)bus\n                .getProperty(\"org.apache.cxf.extensions.logging.atom.pull\");\n        } else {\n            privateEndpoints = new ArrayList<String>();\n            atomMap = new HashMap<String, String>();\n        }\n        \n        AbstractDestination[] soapEndpoints = getSOAPEndpoints(destinations, privateEndpoints);\n        AbstractDestination[] restEndpoints = getRestEndpoints(destinations, privateEndpoints);\n        ServiceListWriter serviceListWriter;\n        if (\"false\".equals(request.getParameter(\"formatted\"))) {\n            boolean renderWsdlList = \"true\".equals(request.getParameter(\"wsdlList\"));\n            serviceListWriter = new UnformattedServiceListWriter(renderWsdlList);\n        } else {\n            String styleSheetPath;\n            if (serviceListStyleSheet != null) {\n                styleSheetPath = request.getContextPath() + \"/\" + serviceListStyleSheet;\n                \n            } else {\n                styleSheetPath = request.getRequestURI() + \"/?stylesheet=1\";\n            }\n            serviceListWriter = \n                new FormattedServiceListWriter(styleSheetPath, title, showForeignContexts, atomMap);\n            \n        }\n        response.setContentType(serviceListWriter.getContentType());\n        Object basePath = request.getAttribute(Message.BASE_PATH);\n        serviceListWriter.writeServiceList(response.getWriter(),\n                                           basePath == null ? null : basePath.toString(),\n                                           soapEndpoints, restEndpoints);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          68,
          127
        ]
      },
      {
        "file_path": "systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerSpringBookTest.java",
        "class_name": "JAXRSClientServerSpringBookTest",
        "method_name": "testEchoBookForm3",
        "signature": "void testEchoBookForm3()",
        "lines_hint_csv": [
          148,
          150
        ],
        "code": "    public void testEchoBookForm3() throws Exception {\n        String address = \"http://localhost:\" + PORT + \"/bus/thebooksform/bookform3\";\n        doTestEchoBookForm(address);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          124
        ]
      },
      {
        "file_path": "systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerSpringBookTest.java",
        "class_name": "JAXRSClientServerSpringBookTest",
        "method_name": "testGetServicesPageWithServletPatternMatchOnly",
        "signature": "void testGetServicesPageWithServletPatternMatchOnly()",
        "lines_hint_csv": [
          127,
          134
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2016-5394",
    "project_slug": "apache__sling-org-apache-sling-xss_CVE-2016-5394_1.0.8",
    "buggy_commit_id": "e23ca68878dd6504066015601b6b76e8fe19b752",
    "github_url": "https://github.com/apache/sling-org-apache-sling-xss",
    "nvd_metadata": {
      "description": "In the XSS Protection API module before 1.0.12 in Apache Sling, the encoding done by the XSSAPI.encodeForJSString() method is not restrictive enough and for some input patterns allows script tags to pass through unencoded, leading to potential XSS vulnerabilities.",
      "published_date": "2017-07-19T15:29:00.180",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
        "class_name": "XSSAPIImpl",
        "method_name": "getValidDimension",
        "signature": "String getValidDimension(String,String)",
        "lines_hint_csv": [
          120,
          134
        ],
        "code": "    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        // fall through to default if empty, null, or validation failure\n        return defaultValue;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          120,
          135
        ]
      },
      {
        "file_path": "src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
        "class_name": "XSSAPIImpl",
        "method_name": "activate",
        "signature": null,
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          64,
          68
        ]
      },
      {
        "file_path": "src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
        "class_name": "XSSAPIImpl",
        "method_name": "encodeForJSString",
        "signature": null,
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "     * @see org.apache.sling.xss.XSSAPI#encodeForJSString(String)\n     */\n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScriptSource(source);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          411,
          416
        ]
      },
      {
        "file_path": "src/main/java/org/apache/sling/xss/impl/XSSFilterImpl.java",
        "class_name": "XSSFilterImpl",
        "method_name": "handleEvent",
        "signature": "void handleEvent(Event)",
        "lines_hint_csv": [
          84,
          88
        ],
        "code": "    public void handleEvent(final Event event) {\n        final String path = (String) event.getProperty(SlingConstants.PROPERTY_PATH);\n        if (path.endsWith(\"/\" + DEFAULT_POLICY_PATH)) {\n            LOGGER.debug(\"Detected policy file change at {}. Updating default handler.\", path);\n            updateDefaultHandler();\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          84,
          90
        ]
      },
      {
        "file_path": "src/main/java/org/apache/sling/xss/impl/XSSFilterImpl.java",
        "class_name": "XSSFilterImpl",
        "method_name": "getFilterRule",
        "signature": "XSSFilterRule getFilterRule(ProtectionContext)",
        "lines_hint_csv": [
          163,
          170
        ],
        "code": "    private XSSFilterRule getFilterRule(final ProtectionContext context) {\n        if (context == null) {\n            throw new NullPointerException(\"context\");\n        }\n        if (context == ProtectionContext.HTML_HTML_CONTENT) {\n            return this.htmlHtmlContext;\n        }\n        return this.plainHtmlContext;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          163,
          171
        ]
      },
      {
        "file_path": "src/main/java/org/apache/sling/xss/impl/XSSFilterImpl.java",
        "class_name": "XSSFilterImpl",
        "method_name": "updateDefaultHandler",
        "signature": "void updateDefaultHandler()",
        "lines_hint_csv": [
          114,
          154
        ],
        "code": "    private void updateDefaultHandler() {\n        ResourceResolver adminResolver = null;\n        try {\n            adminResolver = resourceResolverFactory.getAdministrativeResourceResolver(null);\n            Resource policyResource = adminResolver.getResource(DEFAULT_POLICY_PATH);\n            if (policyResource != null) {\n                InputStream policyStream = policyResource.adaptTo(InputStream.class);\n                if (policyStream != null) {\n                    try {\n                        if (defaultHandler == null) {\n                            setDefaultHandler(new PolicyHandler(policyStream));\n                            policyStream.close();\n                        }\n                    } catch (Exception e) {\n                        LOGGER.error(\"Unable to load policy from \" + policyResource.getPath(), e);\n                    }\n                }\n            } else {\n                // the content was not installed but the service is active; let's use the embedded file for the default handler\n                LOGGER.debug(\"Could not find a policy file at the default location {}. Attempting to use the default resource embedded in\" +\n                        \" the bundle.\", DEFAULT_POLICY_PATH);\n                InputStream policyStream = this.getClass().getClassLoader().getResourceAsStream(\"SLING-INF/content/config.xml\");\n                if (policyStream != null) {\n                    try {\n                        if (defaultHandler == null) {\n                            setDefaultHandler(new PolicyHandler(policyStream));\n                            policyStream.close();\n                        }\n                    } catch (Exception e) {\n                        LOGGER.error(\"Unable to load policy from embedded policy file.\", e);\n                    }\n                }\n            }\n            if (defaultHandler == null) {\n                throw new IllegalStateException(\"Cannot load a default policy handler.\");\n            }\n        } catch (LoginException e) {\n            LOGGER.error(\"Unable to load the default policy file.\", e);\n        } finally {\n            if (adminResolver != null) {\n                adminResolver.close();\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          114,
          157
        ]
      },
      {
        "file_path": "src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
        "class_name": "XSSAPIImplTest",
        "method_name": "testGetValidJSToken",
        "signature": "void testGetValidJSToken()",
        "lines_hint_csv": [
          396,
          423
        ],
        "code": "    public void testGetValidJSToken() {\n        String[][] testData = {\n                //         Source                            Expected Result\n                //\n                {null, RUBBISH},\n                {\"\", RUBBISH},\n                {\"simple\", \"simple\"},\n                {\"clickstreamcloud.thingy\", \"clickstreamcloud.thingy\"},\n\n                {\"break out\", RUBBISH},\n                {\"break,out\", RUBBISH},\n\n                {\"\\\"literal string\\\"\", \"\\\"literal string\\\"\"},\n                {\"'literal string'\", \"'literal string'\"},\n                {\"\\\"bad literal'\", RUBBISH},\n                {\"'literal'); junk'\", \"'literal\\\\'); junk'\"},\n\n                {\"1200\", \"1200\"},\n                {\"3.14\", \"3.14\"},\n                {\"1,200\", RUBBISH},\n                {\"1200 + 1\", RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating Javascript token '\" + source + \"'\", expected, xssAPI.getValidJSToken(source, RUBBISH));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          396,
          425
        ]
      },
      {
        "file_path": "src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
        "class_name": "XSSAPIImplTest",
        "method_name": "testGetValidDimension",
        "signature": "void testGetValidDimension()",
        "lines_hint_csv": [
          344,
          369
        ],
        "code": "    public void testGetValidDimension() {\n        String[][] testData = {\n                //         Source                                        Expected Result\n                //\n                {null, \"123\"},\n                {\"\", \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"},\n\n                {\"\\\"auto\\\"\", \"\\\"auto\\\"\"},\n                {\"'auto'\", \"\\\"auto\\\"\"},\n                {\"auto\", \"\\\"auto\\\"\"},\n\n                {\"autox\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating dimension '\" + source + \"'\", expected, xssAPI.getValidDimension(source, \"123\"));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          344,
          371
        ]
      },
      {
        "file_path": "src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
        "class_name": "XSSAPIImplTest",
        "method_name": "testGetValidHref",
        "signature": "void testGetValidHref()",
        "lines_hint_csv": [
          219,
          280
        ],
        "code": "    public void testGetValidHref() {\n        String[][] testData = {\n                //         Href                                        Expected Result\n                //\n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"../parent\", \"../parent\"},\n                {\"repo/gnter\", \"repo/gnter\"},\n\n                // JCR namespaces:\n                {\"my/page/jcr:content.feed\", \"my/page/_jcr_content.feed\"},\n                {\"my/jcr:content/page/jcr:content\", \"my/_jcr_content/page/_jcr_content\"},\n\n                {\"\\\" onClick=ugly\", \"%22%20onClick=ugly\"},\n                {\"javascript:ugly\", \"\"},\n                {\"http://localhost:4502\", \"http://localhost:4502\"},\n                {\"http://localhost:4502/test\", \"http://localhost:4502/test\"},\n                {\"http://localhost:4502/jcr:content/test\", \"http://localhost:4502/_jcr_content/test\"},\n                {\"http://localhost:4502/test.html?a=b&b=c\", \"http://localhost:4502/test.html?a=b&b=c\"},\n\n                // space\n                {\"/test/ab cd\", \"/test/ab%20cd\"},\n                {\"http://localhost:4502/test/ab cd\", \"http://localhost:4502/test/ab%20cd\"},\n                {\"/test/ab attr=c\", \"/test/ab%20attr=c\"},\n                {\"http://localhost:4502/test/ab attr=c\", \"http://localhost:4502/test/ab%20attr=c\"},\n                // \"\n                {\"/test/ab\\\"cd\", \"/test/ab%22cd\"},\n                {\"http://localhost:4502/test/ab\\\"cd\", \"http://localhost:4502/test/ab%22cd\"},\n                // '\n                {\"/test/ab'cd\", \"/test/ab%27cd\"},\n                {\"http://localhost:4502/test/ab'cd\", \"http://localhost:4502/test/ab%27cd\"},\n                // =\n                {\"/test/ab=cd\", \"/test/ab=cd\"},\n                {\"http://localhost:4502/test/ab=cd\", \"http://localhost:4502/test/ab=cd\"},\n                // >\n                {\"/test/ab>cd\", \"/test/ab%3Ecd\"},\n                {\"http://localhost:4502/test/ab>cd\", \"http://localhost:4502/test/ab%3Ecd\"},\n                // <\n                {\"/test/ab<cd\", \"/test/ab%3Ccd\"},\n                {\"http://localhost:4502/test/ab<cd\", \"http://localhost:4502/test/ab%3Ccd\"},\n                // `\n                {\"/test/ab`cd\", \"/test/ab%60cd\"},\n                {\"http://localhost:4502/test/ab`cd\", \"http://localhost:4502/test/ab%60cd\"},\n                // colons in query string\n                {\"/test/search.html?0_tag:id=test\", \"/test/search.html?0_tag%3Aid=test\"},\n                { // JCR namespaces and colons in query string\n                        \"/test/jcr:content/search.html?0_tag:id=test\",\n                        \"/test/_jcr_content/search.html?0_tag%3Aid=test\"\n                },\n                { // ? in query string\n                        \"/test/search.html?0_tag:id=test?ing&1_tag:id=abc\",\n                        \"/test/search.html?0_tag%3Aid=test?ing&1_tag%3Aid=abc\",\n                }\n        };\n\n        for (String[] aTestData : testData) {\n            String href = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Requested '\" + href + \"'\", expected, xssAPI.getValidHref(href));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          219,
          282
        ]
      },
      {
        "file_path": "src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
        "class_name": "XSSAPIImplTest",
        "method_name": "testFilterHTML",
        "signature": "void testFilterHTML()",
        "lines_hint_csv": [
          184,
          214
        ],
        "code": "    public void testFilterHTML() {\n        String[][] testData = {\n                //         Source                            Expected Result\n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"<script>ugly</script>\", \"\"},\n                {\"<b>wow!</b>\", \"<b>wow!</b>\"},\n\n                {\"<p onmouseover='ugly'>nice</p>\", \"<p>nice</p>\"},\n\n                {\"<img src='javascript:ugly'/>\", \"\"},\n                {\"<img src='nice.jpg'/>\", \"<img src=\\\"nice.jpg\\\" />\"},\n\n                {\"<ul><li>1</li><li>2</li></ul>\", \"<ul><li>1</li><li>2</li></ul>\"},\n\n                {\"gnter\", \"gnter\"},\n\n\n                {\"<strike>strike</strike>\", \"<strike>strike</strike>\"},\n                {\"<s>s</s>\", \"<s>s</s>\"},\n\n                {\"<a href=\\\"\\\">empty href</a>\", \"<a href=\\\"\\\">empty href</a>\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Filtering '\" + source + \"'\", expected, xssAPI.filterHTML(source));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          184,
          216
        ]
      },
      {
        "file_path": "src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
        "class_name": "XSSAPIImplTest",
        "method_name": "testEncodeForCSSString",
        "signature": "void testEncodeForCSSString()",
        "lines_hint_csv": [
          428,
          443
        ],
        "code": "    public void testEncodeForCSSString() {\n        String[][] testData = {\n                // Source   Expected result\n                {null, null},\n                {\"test\"   , \"test\"},\n                {\"\\\\\"     , \"\\\\5c\"},\n                {\"'\"      , \"\\\\27\"},\n                {\"\\\"\"     , \"\\\\22\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.encodeForCSSString(source);\n            TestCase.assertEquals(\"Encoding '\" + source + \"'\", expected, result);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          428,
          445
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-31192",
    "project_slug": "DSpace__DSpace_CVE-2022-31192_5.10",
    "buggy_commit_id": "eca7968be7d6b9f8f5f302c9fc09f8186ed4809e",
    "github_url": "https://github.com/DSpace/DSpace",
    "nvd_metadata": {
      "description": "DSpace open source software is a repository application which provides durable access to digital resources. dspace-jspui is a UI component for DSpace. The JSPUI \"Request a Copy\" feature does not properly escape values submitted and stored from the \"Request a Copy\" form. This means that item requests could be vulnerable to XSS attacks. This vulnerability only impacts the JSPUI. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
      "published_date": "2022-08-01T21:15:13.347",
      "cvss_v3_score": 7.1,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/RequestItemServlet.java",
        "class_name": "RequestItemServlet",
        "method_name": "processForm",
        "signature": "void processForm(Context,HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          117,
          268
        ],
        "code": "    private void processForm (Context context,\n        HttpServletRequest request,\n        HttpServletResponse response)\n        throws ServletException, IOException, SQLException, AuthorizeException\n    {\n    \tboolean showRequestCopy = false;\n\t\tif (\"all\".equalsIgnoreCase(ConfigurationManager.getProperty(\"request.item.type\")) || \n\t\t\t\t(\"logged\".equalsIgnoreCase(ConfigurationManager.getProperty(\"request.item.type\")) &&\n\t\t\t\t\t\tcontext.getCurrentUser() != null))\n\t\t{\n\t\t\tshowRequestCopy = true;\n\t\t}\n\t\t\n\t\tif (!showRequestCopy)\n\t\t{\n\t\t\tthrow new AuthorizeException(\"The request copy feature is disabled\");\n\t\t}\n\t\t\n        // handle\n        String handle = request.getParameter(\"handle\");\n        \n        String bitstream_id=request.getParameter(\"bitstream-id\");\n        \n        // Title\n        String title = null;\n        Item item = null;\n        if (StringUtils.isNotBlank(handle))\n        {\n            item = (Item) HandleManager.resolveToObject(context, handle);\n            \n        }\n        if (item == null)\n        {   \n        \tJSPManager.showInvalidIDError(request, response, handle, -1);\n        }\n        Metadatum[] titleDC = item.getDC(\"title\", null, Item.ANY);\n        if (titleDC != null || titleDC.length > 0)\n        {\n            title = titleDC[0].value;\n        }\n        else\n\t\t{\n\t\t\ttitle = I18nUtil.getMessage(\"jsp.general.untitled\", context);\n\t\t}\n          \n        // User email from context\n        String requesterEmail = request.getParameter(\"email\");\n        EPerson currentUser = context.getCurrentUser();\n        String userName = null;\n        \n        if (currentUser != null)\n        {\n            requesterEmail = currentUser.getEmail();\n            userName = currentUser.getFullName();\n        }\n        \n        if (request.getParameter(\"submit\") != null)\n        {\n            String reqname = request.getParameter(\"reqname\");\n            String coment = request.getParameter(\"coment\");\n            if (coment == null || coment.equals(\"\"))\n                coment = \"\";\n            boolean allfiles = \"true\".equals(request.getParameter(\"allfiles\"));\n            \n            // Check all data is there\n            if (requesterEmail == null || requesterEmail.equals(\"\") ||\n                reqname == null || reqname.equals(\"\")) \n            {\n                request.setAttribute(\"handle\",handle);\n                request.setAttribute(\"bitstream-id\", bitstream_id);\n                request.setAttribute(\"reqname\", reqname);\n                request.setAttribute(\"email\", requesterEmail);\n                request.setAttribute(\"coment\", coment);\n                request.setAttribute(\"title\", title); \n                request.setAttribute(\"allfiles\", allfiles?\"true\":null); \n                \n                request.setAttribute(\"requestItem.problem\", new Boolean(true));\n                JSPManager.showJSP(request, response, \"/requestItem/request-form.jsp\");\n                return;\n            }\n\n            try\n            {\n                // All data is there, send the email\n\t\t\t\tEmail email = Email.getEmail(I18nUtil.getEmailFilename(\n\t\t\t\t\t\tcontext.getCurrentLocale(), \"request_item.author\"));\n\t\t\t\t\n\t\t\t\tRequestItemAuthor author = new DSpace()\n\t\t\t\t\t\t.getServiceManager()\n\t\t\t\t\t\t.getServiceByName(\n\t\t\t\t\t\t\t\tRequestItemAuthorExtractor.class.getName(),\n\t\t\t\t\t\t\t\tRequestItemAuthorExtractor.class)\n\t\t\t\t\t\t.getRequestItemAuthor(context, item);\n\t\t\t\t\n\t\t\t\tString authorEmail = author.getEmail();\n\t\t\t\tString authorName = author.getFullName();\n\t\t\t\t\n\t\t\t\temail.addRecipient(authorEmail);\n\n\t\t\t\temail.addArgument(reqname);\n\t\t\t\temail.addArgument(requesterEmail);\n\t\t\t\temail.addArgument(allfiles ? I18nUtil\n\t\t\t\t\t\t.getMessage(\"itemRequest.all\") : Bitstream.find(\n\t\t\t\t\t\tcontext, Integer.parseInt(bitstream_id)).getName());\n\t\t\t\temail.addArgument(HandleManager.getCanonicalForm(item\n\t\t\t\t\t\t.getHandle()));\n\t\t\t\temail.addArgument(title); // request item title\n\t\t\t\temail.addArgument(coment); // message\n\t\t\t\temail.addArgument(RequestItemManager.getLinkTokenEmail(context,\n\t\t\t\t\t\tbitstream_id, item.getID(), requesterEmail, reqname,\n\t\t\t\t\t\tallfiles));\n\t\t\t\t\n\t\t\t\temail.addArgument(authorName); // corresponding author name\n\t\t\t\temail.addArgument(authorEmail); // corresponding author email\n\t\t\t\temail.addArgument(ConfigurationManager\n\t\t\t\t\t\t.getProperty(\"dspace.name\"));\n\t\t\t\temail.addArgument(ConfigurationManager\n\t\t\t\t\t\t.getProperty(\"mail.helpdesk\"));\n\t\t\t\temail.setReplyTo(requesterEmail);\n\t\t\t\temail.send();\n\n                log.info(LogManager.getHeader(context,\n                    \"sent_email_requestItem\",\n                    \"submitter_id=\" + requesterEmail\n                        + \",bitstream_id=\"+bitstream_id\n                        + \",requestEmail=\"+requesterEmail));\n\n                request.setAttribute(\"handle\", handle);\n                JSPManager.showJSP(request, response,\n                    \"/requestItem/request-send.jsp\");\n            }\n            catch (MessagingException me)\n            {\n                log.warn(LogManager.getHeader(context,\n                    \"error_mailing_requestItem\",\n                    \"\"), me);\n               JSPManager.showInternalError(request, response);\n            }\n        }\n        else\n        {\n            // Display request copy form\n            log.info(LogManager.getHeader(context,\n                \"show_requestItem_form\",\n                \"problem=false\"));\n            request.setAttribute(\"handle\", handle);\n            request.setAttribute(\"bitstream-id\", bitstream_id);\n            request.setAttribute(\"email\", requesterEmail);\n            request.setAttribute(\"reqname\", userName);\n            request.setAttribute(\"title\", title);\n            request.setAttribute(\"allfiles\", \"true\");\n            JSPManager.showJSP(request, response, \"/requestItem/request-form.jsp\"); \n        }\n   }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          117,
          270
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/util/RequestItemManager.java",
        "class_name": "RequestItemManager",
        "method_name": "getLinkTokenEmail",
        "signature": "String getLinkTokenEmail(Context,String,int,String,String,boolean)",
        "lines_hint_csv": [
          121,
          134
        ],
        "code": "    public static String getLinkTokenEmail(Context context, String bitstreamId\n            , int itemID, String reqEmail, String reqName, boolean allfiles)\n            throws SQLException\n    {\n        String base = ConfigurationManager.getProperty(\"dspace.url\");\n\n        String specialLink = (new StringBuffer()).append(base).append(\n                base.endsWith(\"/\") ? \"\" : \"/\").append(\n                \"request-item\").append(\"?step=\" + RequestItemServlet.ENTER_TOKEN)\n                .append(\"&token=\")\n                .append(getNewToken(context, Integer.parseInt(bitstreamId), itemID, reqEmail, reqName, allfiles))\n                .toString();\n        \n        return specialLink;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          135
        ]
      },
      {
        "file_path": "dspace-jspui/src/main/java/org/dspace/app/webui/servlet/ControlledVocabularyServlet.java",
        "class_name": "ControlledVocabularyServlet",
        "method_name": "doDSGet",
        "signature": "void doDSGet(Context,HttpServletRequest,HttpServletResponse)",
        "lines_hint_csv": [
          31,
          53
        ],
        "code": "    protected void doDSGet(Context context, HttpServletRequest request,\n            HttpServletResponse response) throws ServletException, IOException,\n            SQLException, AuthorizeException\n    {\n\n        String ID = \"\";\n        String filter = \"\";\n        String callerUrl = request.getParameter(\"callerUrl\");\n\n        if (request.getParameter(\"ID\") != null)\n        {\n            ID = request.getParameter(\"ID\");\n        }\n\n        if (request.getParameter(\"filter\") != null)\n        {\n            filter = request.getParameter(\"filter\");\n        }\n\n        request.getSession()\n                .setAttribute(\"controlledvocabulary.filter\", filter);\n        request.getSession().setAttribute(\"controlledvocabulary.ID\", ID);\n        response.sendRedirect(callerUrl);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          31,
          54
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-4137",
    "project_slug": "keycloak__keycloak_CVE-2022-4137_20.0.3",
    "buggy_commit_id": "02d113ab71de67817890b655ae792580a4fb8ee2",
    "github_url": "https://github.com/keycloak/keycloak",
    "nvd_metadata": {
      "description": "A reflected cross-site scripting (XSS) vulnerability was found in the 'oob' OAuth endpoint due to incorrect null-byte handling. This issue allows a malicious link to insert an arbitrary URI into a Keycloak error page. This flaw requires a user or administrator to interact with a link in order to be vulnerable. This may compromise user details, allowing it to be changed or collected by an attacker.",
      "published_date": "2023-09-25T20:15:09.897",
      "cvss_v3_score": 8.1,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java",
        "class_name": "FreeMarkerLoginFormsProvider",
        "method_name": "createResponse",
        "signature": "Response createResponse(LoginFormsPages)",
        "lines_hint_csv": [
          205,
          303
        ],
        "code": "    protected Response createResponse(LoginFormsPages page) {\n\n        Theme theme;\n        try {\n            theme = getTheme();\n        } catch (IOException e) {\n            logger.error(\"Failed to create theme\", e);\n            return Response.serverError().build();\n        }\n\n        Locale locale = session.getContext().resolveLocale(user);\n        Properties messagesBundle = handleThemeResources(theme, locale);\n\n        handleMessages(locale, messagesBundle);\n\n        // for some reason Resteasy 2.3.7 doesn't like query params and form params with the same name and will null out the code form param\n        UriBuilder uriBuilder = prepareBaseUriBuilder(page == LoginFormsPages.OAUTH_GRANT);\n        createCommonAttributes(theme, locale, messagesBundle, uriBuilder, page);\n\n        attributes.put(\"login\", new LoginBean(formData));\n        if (status != null) {\n            attributes.put(\"statusCode\", status.getStatusCode());\n        }\n\n        switch (page) {\n            case LOGIN_CONFIG_TOTP:\n                attributes.put(\"totp\", new TotpBean(session, realm, user, uriInfo.getRequestUriBuilder()));\n                break;\n            case LOGIN_RECOVERY_AUTHN_CODES_CONFIG:\n                attributes.put(\"recoveryAuthnCodesConfigBean\", new RecoveryAuthnCodesBean());\n                break;\n            case LOGIN_RECOVERY_AUTHN_CODES_INPUT:\n                attributes.put(\"recoveryAuthnCodesInputBean\", new RecoveryAuthnCodeInputLoginBean(session, realm, user));\n                break;\n            case LOGIN_UPDATE_PROFILE:\n                UpdateProfileContext userCtx = (UpdateProfileContext) attributes.get(LoginFormsProvider.UPDATE_PROFILE_CONTEXT_ATTR);\n                attributes.put(\"user\", new ProfileBean(userCtx, formData));\n                break;\n            case UPDATE_EMAIL:\n                attributes.put(\"email\", new EmailBean(user, formData));\n                break;\n            case LOGIN_IDP_LINK_CONFIRM:\n            case LOGIN_IDP_LINK_EMAIL:\n                BrokeredIdentityContext brokerContext = (BrokeredIdentityContext) this.attributes.get(IDENTITY_PROVIDER_BROKER_CONTEXT);\n                String idpAlias = brokerContext.getIdpConfig().getAlias();\n                idpAlias = ObjectUtil.capitalize(idpAlias);\n                String displayName = idpAlias;\n                if (!ObjectUtil.isBlank(brokerContext.getIdpConfig().getDisplayName())) {\n                    displayName = brokerContext.getIdpConfig().getDisplayName();\n                }\n\n                attributes.put(\"brokerContext\", brokerContext);\n                attributes.put(\"idpAlias\", idpAlias);\n                attributes.put(\"idpDisplayName\", displayName);\n                break;\n            case LOGIN_TOTP:\n                attributes.put(\"otpLogin\", new TotpLoginBean(session, realm, user, (String) this.attributes.get(OTPFormAuthenticator.SELECTED_OTP_CREDENTIAL_ID)));\n                break;\n            case REGISTER:\n                if(isDynamicUserProfile()) {\n                    page = LoginFormsPages.REGISTER_USER_PROFILE;\n                }\n                RegisterBean rb = new RegisterBean(formData,session);\n                //legacy bean for static template\n                attributes.put(\"register\", rb);\n                //bean for dynamic template\n                attributes.put(\"profile\", rb);\n                break;\n            case OAUTH_GRANT:\n                attributes.put(\"oauth\",\n                        new OAuthGrantBean(accessCode, client, clientScopesRequested));\n                break;\n            case CODE:\n                attributes.put(OAuth2Constants.CODE, new CodeBean(accessCode, messageType == MessageType.ERROR ? getFirstMessageUnformatted() : null));\n                break;\n            case X509_CONFIRM:\n                attributes.put(\"x509\", new X509ConfirmBean(formData));\n                break;\n            case SAML_POST_FORM:\n                attributes.put(\"samlPost\", new SAMLPostFormBean(formData));\n                break;\n            case UPDATE_USER_PROFILE:\n                attributes.put(\"profile\", new VerifyProfileBean(user, formData, session));\n                break;\n            case IDP_REVIEW_USER_PROFILE:\n                UpdateProfileContext idpCtx = (UpdateProfileContext) attributes.get(LoginFormsProvider.UPDATE_PROFILE_CONTEXT_ATTR);\n                attributes.put(\"profile\", new IdpReviewProfileBean(idpCtx, formData, session));\n                break;\n            case FRONTCHANNEL_LOGOUT:\n                attributes.put(\"logout\", new FrontChannelLogoutBean(session));\n                break;\n            case LOGOUT_CONFIRM:\n                attributes.put(\"logoutConfirm\", new LogoutConfirmBean(accessCode, authenticationSession));\n                break;\n        }\n\n        return processTemplate(theme, Templates.getTemplate(page), locale);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          205,
          302
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/theme/KeycloakSanitizerMethod.java",
        "class_name": "KeycloakSanitizerMethod",
        "method_name": "exec",
        "signature": "Object exec(List)",
        "lines_hint_csv": [
          38,
          50
        ],
        "code": "    public Object exec(List list) throws TemplateModelException {\n        if ((list.isEmpty()) || (list.get(0) == null)) {\n            throw new NullPointerException(\"Can not escape null value.\");\n        }\n        \n        String html = list.get(0).toString();\n        String sanitized = KeycloakSanitizerPolicy.POLICY_DEFINITION.sanitize(html);\n        \n        return fixURLs(sanitized);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          37,
          46
        ]
      },
      {
        "file_path": "services/src/test/java/org/keycloak/theme/KeycloakSanitizerTest.java",
        "class_name": "KeycloakSanitizerTest",
        "method_name": "testUrls",
        "signature": "void testUrls()",
        "lines_hint_csv": [
          64,
          97
        ],
        "code": "    public void testUrls() throws Exception {\n        List<String> html = new ArrayList<>();\n\n        html.add(\"<p><a href='https://localhost'>link</a></p>\");\n        assertResult(\"<p><a href=\\\"https://localhost\\\" rel=\\\"nofollow\\\">link</a></p>\", html);\n\n        html.set(0, \"<p><a href=\\\"\\\">link</a></p>\");\n        assertResult(\"<p>link</p>\", html);\n\n        html.set(0, \"<p><a href=\\\"javascript:alert('hello!');\\\">link</a></p>\");\n        assertResult(\"<p>link</p>\", html);\n\n        html.set(0, \"<p><a href=\\\"https://localhost?key=123&msg=abc\\\">link</a></p>\");\n        assertResult(\"<p><a href=\\\"https://localhost?key=123&msg=abc\\\" rel=\\\"nofollow\\\">link</a></p>\", html);\n\n        html.set(0, \"<p><a href='https://localhost?key=123&msg=abc'>link1</a><a href=\\\"https://localhost?key=abc&msg=123\\\">link2</a></p>\");\n        assertResult(\"<p><a href=\\\"https://localhost?key=123&msg=abc\\\" rel=\\\"nofollow\\\">link1</a><a href=\\\"https://localhost?key=abc&msg=123\\\" rel=\\\"nofollow\\\">link2</a></p>\", html);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          64,
          81
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/error/EscapeErrorPageTest.java",
        "class_name": "EscapeErrorPageTest",
        "method_name": "ampersandEscape",
        "signature": "void ampersandEscape()",
        "lines_hint_csv": [
          58,
          60
        ],
        "code": "    public void ampersandEscape() {\n        checkMessage(\"&lt;img src=&quot;something&quot;&gt;\", \"<img src=\\\"something\\\">\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          58,
          60
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/error/EscapeErrorPageTest.java",
        "class_name": "EscapeErrorPageTest",
        "method_name": "hexEscape",
        "signature": "void hexEscape()",
        "lines_hint_csv": [
          63,
          65
        ],
        "code": "    public void hexEscape() {\n        checkMessage(\"&#x3C;img src&#61;something&#x2F;&#x3E;\", \"<img src=something/>\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          63,
          65
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/AuthorizationCodeTest.java",
        "class_name": "AuthorizationCodeTest",
        "method_name": "authorizationRequestInstalledApp",
        "signature": "void authorizationRequestInstalledApp()",
        "lines_hint_csv": [
          92,
          103
        ],
        "code": "    public void authorizationRequestInstalledApp() throws IOException {\n        ClientManager.realm(adminClient.realm(\"test\")).clientId(\"test-app\").addRedirectUris(Constants.INSTALLED_APP_URN);\n        oauth.redirectUri(Constants.INSTALLED_APP_URN);\n\n        oauth.doLogin(\"test-user@localhost\", \"password\");\n\n        String title = PageUtils.getPageTitle(driver);\n        Assert.assertEquals(\"Success code\", title);\n\n        driver.findElement(By.id(OAuth2Constants.CODE)).getAttribute(\"value\");\n\n        events.expectLogin().detail(Details.REDIRECT_URI, oauth.AUTH_SERVER_ROOT + \"/realms/test/protocol/openid-connect/oauth/oob\").assertEvent().getDetails().get(Details.CODE_ID);\n\n        ClientManager.realm(adminClient.realm(\"test\")).clientId(\"test-app\").removeRedirectUris(Constants.INSTALLED_APP_URN);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          89,
          103
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-1274",
    "project_slug": "keycloak__keycloak_CVE-2022-1274_20.0.3",
    "buggy_commit_id": "02d113ab71de67817890b655ae792580a4fb8ee2",
    "github_url": "https://github.com/keycloak/keycloak",
    "nvd_metadata": {
      "description": "A flaw was found in Keycloak in the execute-actions-email endpoint. This issue allows arbitrary HTML to be injected into emails sent to Keycloak users and can be misused to perform phishing or other attacks against users.",
      "published_date": "2023-03-29T21:15:07.853",
      "cvss_v3_score": 5.4,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "services/src/main/java/org/keycloak/authentication/actiontoken/execactions/ExecuteActionsActionTokenHandler.java",
        "class_name": "ExecuteActionsActionTokenHandler",
        "method_name": "getVerifiers",
        "signature": "Predicate getVerifiers(ActionTokenContext)",
        "lines_hint_csv": [
          58,
          72
        ],
        "code": "    public Predicate<? super ExecuteActionsActionToken>[] getVerifiers(ActionTokenContext<ExecuteActionsActionToken> tokenContext) {\n        return TokenUtils.predicates(\n          TokenUtils.checkThat(\n            // either redirect URI is not specified or must be valid for the client\n            t -> t.getRedirectUri() == null\n                 || RedirectUtils.verifyRedirectUri(tokenContext.getSession(), t.getRedirectUri(),\n                      tokenContext.getAuthenticationSession().getClient()) != null,\n            Errors.INVALID_REDIRECT_URI,\n            Messages.INVALID_REDIRECT_URI\n          ),\n\n          verifyEmail(tokenContext)\n        );\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          56,
          69
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java",
        "class_name": "UserResource",
        "method_name": "executeActionsEmail",
        "signature": "Response executeActionsEmail(String,String,Integer,List)",
        "lines_hint_csv": [
          784,
          861
        ],
        "code": "    public Response executeActionsEmail(@QueryParam(OIDCLoginProtocol.REDIRECT_URI_PARAM) String redirectUri,\n                                        @QueryParam(OIDCLoginProtocol.CLIENT_ID_PARAM) String clientId,\n                                        @QueryParam(\"lifespan\") Integer lifespan,\n                                        List<String> actions) {\n        auth.users().requireManage(user);\n\n        if (user.getEmail() == null) {\n            return ErrorResponse.error(\"User email missing\", Status.BAD_REQUEST);\n        }\n\n        if (!user.isEnabled()) {\n            throw new WebApplicationException(\n                ErrorResponse.error(\"User is disabled\", Status.BAD_REQUEST));\n        }\n\n        if (redirectUri != null && clientId == null) {\n            throw new WebApplicationException(\n                ErrorResponse.error(\"Client id missing\", Status.BAD_REQUEST));\n        }\n\n        if (clientId == null) {\n            clientId = Constants.ACCOUNT_MANAGEMENT_CLIENT_ID;\n        }\n\n        ClientModel client = realm.getClientByClientId(clientId);\n        if (client == null) {\n            logger.debugf(\"Client %s doesn't exist\", clientId);\n            throw new WebApplicationException(\n                ErrorResponse.error(\"Client doesn't exist\", Status.BAD_REQUEST));\n        }\n        if (!client.isEnabled()) {\n            logger.debugf(\"Client %s is not enabled\", clientId);\n            throw new WebApplicationException(\n                    ErrorResponse.error(\"Client is not enabled\", Status.BAD_REQUEST));\n        }\n\n        String redirect;\n        if (redirectUri != null) {\n            redirect = RedirectUtils.verifyRedirectUri(session, redirectUri, client);\n            if (redirect == null) {\n                throw new WebApplicationException(\n                    ErrorResponse.error(\"Invalid redirect uri.\", Status.BAD_REQUEST));\n            }\n        }\n\n        if (lifespan == null) {\n            lifespan = realm.getActionTokenGeneratedByAdminLifespan();\n        }\n        int expiration = Time.currentTime() + lifespan;\n        ExecuteActionsActionToken token = new ExecuteActionsActionToken(user.getId(), user.getEmail(), expiration, actions, redirectUri, clientId);\n\n        try {\n            UriBuilder builder = LoginActionsService.actionTokenProcessor(session.getContext().getUri());\n            builder.queryParam(\"key\", token.serialize(session, realm, session.getContext().getUri()));\n\n            String link = builder.build(realm.getName()).toString();\n\n            this.session.getProvider(EmailTemplateProvider.class)\n              .setAttribute(Constants.TEMPLATE_ATTR_REQUIRED_ACTIONS, token.getRequiredActions())\n              .setRealm(realm)\n              .setUser(user)\n              .sendExecuteActions(link, TimeUnit.SECONDS.toMinutes(lifespan));\n\n            //audit.user(user).detail(Details.EMAIL, user.getEmail()).detail(Details.CODE_ID, accessCode.getCodeId()).success();\n\n            adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();\n\n            return Response.noContent().build();\n        } catch (EmailException e) {\n            ServicesLogger.LOGGER.failedToSendActionsEmail(e);\n            return ErrorResponse.error(\"Failed to send execute actions email\", Status.INTERNAL_SERVER_ERROR);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          782,
          854
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java",
        "class_name": "UserTest",
        "method_name": "sendResetPasswordEmail",
        "signature": "void sendResetPasswordEmail()",
        "lines_hint_csv": [
          1519,
          1583
        ],
        "code": "    public void sendResetPasswordEmail() {\n        UserRepresentation userRep = new UserRepresentation();\n        userRep.setUsername(\"user1\");\n\n        String id = createUser(userRep);\n\n        UserResource user = realm.users().get(id);\n        List<String> actions = new LinkedList<>();\n        try {\n            user.executeActionsEmail(actions);\n            fail(\"Expected failure\");\n        } catch (ClientErrorException e) {\n            assertEquals(400, e.getResponse().getStatus());\n\n            ErrorRepresentation error = e.getResponse().readEntity(ErrorRepresentation.class);\n            Assert.assertEquals(\"User email missing\", error.getErrorMessage());\n            assertAdminEvents.assertEmpty();\n        }\n        try {\n            userRep = user.toRepresentation();\n            userRep.setEmail(\"user1@localhost\");\n            userRep.setEnabled(false);\n            updateUser(user, userRep);\n\n            user.executeActionsEmail(actions);\n            fail(\"Expected failure\");\n        } catch (ClientErrorException e) {\n            assertEquals(400, e.getResponse().getStatus());\n\n            ErrorRepresentation error = e.getResponse().readEntity(ErrorRepresentation.class);\n            Assert.assertEquals(\"User is disabled\", error.getErrorMessage());\n            assertAdminEvents.assertEmpty();\n        }\n        try {\n            userRep.setEnabled(true);\n            updateUser(user, userRep);\n\n            user.executeActionsEmail(\"invalidClientId\", \"invalidUri\", actions);\n            fail(\"Expected failure\");\n        } catch (ClientErrorException e) {\n            assertEquals(400, e.getResponse().getStatus());\n\n            ErrorRepresentation error = e.getResponse().readEntity(ErrorRepresentation.class);\n            Assert.assertEquals(\"Client doesn't exist\", error.getErrorMessage());\n            assertAdminEvents.assertEmpty();\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1519,
          1565
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-29201",
    "project_slug": "xwiki__xwiki-commons_CVE-2023-29201_14.5",
    "buggy_commit_id": "3780c8f6836c7d380f649562e9718a0868112945",
    "github_url": "https://github.com/xwiki/xwiki-commons",
    "nvd_metadata": {
      "description": "XWiki Commons are technical libraries common to several other top level XWiki projects. The \"restricted\" mode of the HTML cleaner in XWiki, introduced in version 4.2-milestone-1, only escaped `<script>` and `<style>`-tags but neither attributes that can be used to inject scripts nor other dangerous HTML tags like `<iframe>`. As a consequence, any code relying on this \"restricted\" mode for security is vulnerable to JavaScript injection (\"cross-site scripting\"/XSS). When a privileged user with programming rights visits such a comment in XWiki, the malicious JavaScript code is executed in the context of the user session. This allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. This problem has been patched in XWiki 14.6 RC1 with the introduction of a filter with allowed HTML elements and attributes that is enabled in restricted mode. There are no known workarounds apart from upgrading to a version including the fix.",
      "published_date": "2023-04-15T15:15:08.273",
      "cvss_v3_score": 9.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/DefaultHTMLCleaner.java",
        "class_name": "DefaultHTMLCleaner",
        "method_name": "getDefaultConfiguration",
        "signature": "HTMLCleanerConfiguration getDefaultConfiguration()",
        "lines_hint_csv": [
          198,
          211
        ],
        "code": "    public HTMLCleanerConfiguration getDefaultConfiguration()\n    {\n        HTMLCleanerConfiguration configuration = new DefaultHTMLCleanerConfiguration();\n        configuration.setFilters(Arrays.asList(\n            this.controlFilter,\n            this.bodyFilter,\n            this.listItemFilter,\n            this.listFilter,\n            this.fontFilter,\n            this.attributeFilter,\n            this.linkFilter));\n        return configuration;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          194,
          206
        ]
      },
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/test/java/org/xwiki/xml/internal/html/DefaultHTMLCleanerTest.java",
        "class_name": "DefaultHTMLCleanerTest",
        "method_name": "cleanTitleWithNamespace",
        "signature": "void cleanTitleWithNamespace()",
        "lines_hint_csv": [
          405,
          422
        ],
        "code": "    void cleanTitleWithNamespace()\n    {\n        // Test with TITLE in HEAD\n        String input =\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">\\n\"\n                + \"  <head>\\n\"\n                + \"    <title>Title test</title>\\n\"\n                + \"  </head>\\n\"\n                + \"  <body>\\n\"\n                + \"    <p>before</p>\\n\"\n                + \"    <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                + \"      <g>\\n\"\n                + \"        <title>SVG Title Demo example</title>\\n\"\n                + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg>\\n\" + \"    <p>after</p>\\n\";\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          371,
          388
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-29528",
    "project_slug": "xwiki__xwiki-commons_CVE-2023-29528_14.9-rc-1",
    "buggy_commit_id": "7796f76096a3e94b7a0a96bf12b3b026922e3573",
    "github_url": "https://github.com/xwiki/xwiki-commons",
    "nvd_metadata": {
      "description": "XWiki Commons are technical libraries common to several other top level XWiki projects. The \"restricted\" mode of the HTML cleaner in XWiki, introduced in version 4.2-milestone-1 and massively improved in version 14.6-rc-1, allowed the injection of arbitrary HTML code and thus cross-site scripting via invalid HTML comments. As a consequence, any code relying on this \"restricted\" mode for security is vulnerable to JavaScript injection (\"cross-site scripting\"/XSS). When a privileged user with programming rights visits such a comment in XWiki, the malicious JavaScript code is executed in the context of the user session. This allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. This problem has been patched in XWiki 14.10, HTML comments are now removed in restricted mode and a check has been introduced that ensures that comments don't start with `>`. There are no known workarounds apart from upgrading to a version including the fix.\n",
      "published_date": "2023-04-20T18:15:07.307",
      "cvss_v3_score": 9.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/DefaultHTMLCleaner.java",
        "class_name": "DefaultHTMLCleaner",
        "method_name": "getDefaultCleanerTransformations",
        "signature": "TrimAttributeCleanerTransformations getDefaultCleanerTransformations(HTMLCleanerConfiguration)",
        "lines_hint_csv": [
          278,
          327
        ],
        "code": "    private TrimAttributeCleanerTransformations getDefaultCleanerTransformations(HTMLCleanerConfiguration configuration)\n    {\n        TrimAttributeCleanerTransformations defaultTransformations = new TrimAttributeCleanerTransformations();\n\n        TagTransformation tt;\n\n        // note that we do not care here to use a TrimAttributeTagTransformation, since the attributes are not preserved\n        if (!isHTML5(configuration)) {\n            // These tags are not obsolete in HTML5.\n            tt = new TagTransformation(HTMLConstants.TAG_B, HTMLConstants.TAG_STRONG, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_I, HTMLConstants.TAG_EM, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_U, HTMLConstants.TAG_INS, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_S, HTMLConstants.TAG_DEL, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        tt = new TagTransformation(HTMLConstants.TAG_STRIKE, HTMLConstants.TAG_DEL, false);\n        defaultTransformations.addTransformation(tt);\n\n        tt = new TagTransformation(HTMLConstants.TAG_CENTER, HTMLConstants.TAG_P, false);\n        tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_STYLE, \"text-align:center\");\n        defaultTransformations.addTransformation(tt);\n\n        if (isHTML5(configuration)) {\n            // Font tags are removed before the filters are applied in HTML5, we thus need a transformation here.\n            defaultTransformations.addTransformation(new FontTagTransformation());\n\n            // The tt-tag is obsolete in HTML5\n            tt = new TrimAttributeTagTransformation(HTMLConstants.TAG_TT, HTMLConstants.TAG_SPAN);\n            tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_CLASS, \"${class} monospace\");\n            defaultTransformations.addTransformation(tt);\n        }\n\n        String restricted = configuration.getParameters().get(HTMLCleanerConfiguration.RESTRICTED);\n        if (\"true\".equalsIgnoreCase(restricted)) {\n\n            tt = new TagTransformation(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_STYLE, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        return defaultTransformations;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          278,
          328
        ]
      },
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/DefaultHTMLCleaner.java",
        "class_name": "DefaultHTMLCleaner",
        "method_name": "getDefaultCleanerProperties",
        "signature": "CleanerProperties getDefaultCleanerProperties(HTMLCleanerConfiguration)",
        "lines_hint_csv": [
          217,
          270
        ],
        "code": "    private CleanerProperties getDefaultCleanerProperties(HTMLCleanerConfiguration configuration)\n    {\n        CleanerProperties defaultProperties = new CleanerProperties();\n        defaultProperties.setOmitUnknownTags(true);\n\n        // HTML Cleaner uses the compact notation by default but we don't want that since:\n        // - it's more work and not required since not compact notation is valid XHTML\n        // - expanded elements can also be rendered fine in browsers that only support HTML.\n        defaultProperties.setUseEmptyElementTags(false);\n\n        // Wrap script and style content in CDATA blocks\n        defaultProperties.setUseCdataForScriptAndStyle(true);\n\n        // We need this for example to ignore CDATA sections not inside script or style elements.\n        defaultProperties.setIgnoreQuestAndExclam(true);\n\n        // Remove CDATA outside of script and style since according to the spec it has no effect there.\n        defaultProperties.setOmitCdataOutsideScriptAndStyle(true);\n\n        // If the caller has defined NAMESPACE_AWARE configuration property then use it, otherwise use our default.\n        String param = configuration.getParameters().get(HTMLCleanerConfiguration.NAMESPACES_AWARE);\n        boolean namespacesAware = (param == null) || Boolean.parseBoolean(param);\n        defaultProperties.setNamespacesAware(namespacesAware);\n\n        // Set Cleaner transformations\n        defaultProperties.setCleanerTransformations(getDefaultCleanerTransformations(configuration));\n\n        // Don't convert special HTML entities (i.e. &ocirc;, &permil;, &times;) with unicode characters they represent.\n        defaultProperties.setTranslateSpecialEntities(false);\n\n        // Use character references rather than entity references if needed (for instance if you need to parse the\n        // output as XML)\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.USE_CHARACTER_REFERENCES);\n        boolean useCharacterReferences = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTransResCharsToNCR(useCharacterReferences);\n\n        // Sets the HTML version from the configuration (by default 4).\n        defaultProperties.setHtmlVersion(getHTMLVersion(configuration));\n\n        // We trim values by default for all attributes but the input value attribute.\n        // The only way to currently do that is to switch off this flag, and to create a dedicated TagTransformation.\n        // See TrimAttributeCleanerTransformation for more information.\n        defaultProperties.setTrimAttributeValues(false);\n\n        // This flag should be set to true once https://sourceforge.net/p/htmlcleaner/bugs/221/ is fixed.\n        defaultProperties.setRecognizeUnicodeChars(false);\n\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.TRANSLATE_SPECIAL_ENTITIES);\n        boolean translateSpecialEntities = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTranslateSpecialEntities(translateSpecialEntities);\n\n        defaultProperties.setDeserializeEntities(true);\n\n        return defaultProperties;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          217,
          271
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-32070",
    "project_slug": "xwiki__xwiki-rendering_CVE-2023-32070_14.5",
    "buggy_commit_id": "0057b2db748674446ceeacf3a540d42b7295a524",
    "github_url": "https://github.com/xwiki/xwiki-rendering",
    "nvd_metadata": {
      "description": "XWiki Platform is a generic wiki platform. Prior to version 14.6-rc-1, HTML rendering didn't check for dangerous attributes/attribute values. This allowed cross-site scripting (XSS) attacks via attributes and link URLs, e.g., supported in XWiki syntax. This has been patched in XWiki 14.6-rc-1. There are no known workarounds apart from upgrading to a fixed version.",
      "published_date": "2023-05-10T18:15:10.003",
      "cvss_v3_score": 9.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "xwiki-rendering-macros/xwiki-rendering-macro-html/src/main/java/org/xwiki/rendering/internal/macro/html/HTMLMacroXHTMLRenderer.java",
        "class_name": "HTMLMacroXHTMLRenderer",
        "method_name": "getSyntaxRenderer",
        "signature": "AbstractChainingPrintRenderer getSyntaxRenderer()",
        "lines_hint_csv": [
          65,
          69
        ],
        "code": "    protected AbstractChainingPrintRenderer getSyntaxRenderer()\n    {\n        return new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, getListenerChain());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          61,
          64
        ]
      },
      {
        "file_path": "xwiki-rendering-macros/xwiki-rendering-macro-html/src/main/java/org/xwiki/rendering/internal/macro/html/renderers/annotatedhtml5/HTMLMacroAnnotatedHTML5Renderer.java",
        "class_name": "HTMLMacroAnnotatedHTML5Renderer",
        "method_name": "getSyntaxRenderer",
        "signature": "AbstractChainingPrintRenderer getSyntaxRenderer()",
        "lines_hint_csv": [
          67,
          71
        ],
        "code": "    protected AbstractChainingPrintRenderer getSyntaxRenderer()\n    {\n        return new AnnotatedHTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, getListenerChain());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          63,
          66
        ]
      },
      {
        "file_path": "xwiki-rendering-macros/xwiki-rendering-macro-html/src/main/java/org/xwiki/rendering/internal/macro/html/renderers/annotatedxhtml/HTMLMacroAnnotatedXHTMLRenderer.java",
        "class_name": "HTMLMacroAnnotatedXHTMLRenderer",
        "method_name": "getSyntaxRenderer",
        "signature": "AbstractChainingPrintRenderer getSyntaxRenderer()",
        "lines_hint_csv": [
          69,
          73
        ],
        "code": "    protected AbstractChainingPrintRenderer getSyntaxRenderer()\n    {\n        return new AnnotatedXHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, getListenerChain());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          65,
          68
        ]
      },
      {
        "file_path": "xwiki-rendering-macros/xwiki-rendering-macro-html/src/main/java/org/xwiki/rendering/internal/macro/html/renderers/html5/HTMLMacroHTML5Renderer.java",
        "class_name": "HTMLMacroHTML5Renderer",
        "method_name": "getSyntaxRenderer",
        "signature": "AbstractChainingPrintRenderer getSyntaxRenderer()",
        "lines_hint_csv": [
          67,
          71
        ],
        "code": "    protected AbstractChainingPrintRenderer getSyntaxRenderer()\n    {\n        return new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, getListenerChain());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          63,
          66
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-annotatedhtml5/src/main/java/org/xwiki/rendering/internal/renderer/html5/AnnotatedHTML5ChainingRenderer.java",
        "class_name": "AnnotatedHTML5ChainingRenderer",
        "method_name": "AnnotatedHTML5ChainingRenderer",
        "signature": "AnnotatedHTML5ChainingRenderer(XHTMLLinkRenderer,XHTMLImageRenderer,HTMLElementSanitizer,ListenerChain)",
        "lines_hint_csv": [
          62,
          70
        ],
        "code": "    public AnnotatedHTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n            XHTMLImageRenderer imageRenderer, ListenerChain listenerChain)\n    {\n        super(linkRenderer, imageRenderer, listenerChain);\n\n        this.macroRenderer = new XHTMLMacroRenderer();\n\n        this.metaDataRenderer = new XHTMLMetaDataRenderer();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          60,
          68
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-annotatedhtml5/src/main/java/org/xwiki/rendering/internal/renderer/html5/AnnotatedHTML5Renderer.java",
        "class_name": "AnnotatedHTML5Renderer",
        "method_name": "initialize",
        "signature": "void initialize()",
        "lines_hint_csv": [
          75,
          88
        ],
        "code": "    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new AnnotatedHTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          71,
          83
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-annotatedxhtml/src/main/java/org/xwiki/rendering/internal/renderer/xhtml/AnnotatedXHTMLChainingRenderer.java",
        "class_name": "AnnotatedXHTMLChainingRenderer",
        "method_name": "AnnotatedXHTMLChainingRenderer",
        "signature": "AnnotatedXHTMLChainingRenderer(XHTMLLinkRenderer,XHTMLImageRenderer,HTMLElementSanitizer,ListenerChain)",
        "lines_hint_csv": [
          59,
          67
        ],
        "code": "    public AnnotatedXHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer,\n        XHTMLImageRenderer imageRenderer, ListenerChain listenerChain)\n    {\n        super(linkRenderer, imageRenderer, listenerChain);\n\n        this.macroRenderer = new XHTMLMacroRenderer();\n\n        this.metaDataRenderer = new XHTMLMetaDataRenderer();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          57,
          65
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-annotatedxhtml/src/main/java/org/xwiki/rendering/internal/renderer/xhtml/AnnotatedXHTMLRenderer.java",
        "class_name": "AnnotatedXHTMLRenderer",
        "method_name": "initialize",
        "signature": "void initialize()",
        "lines_hint_csv": [
          75,
          88
        ],
        "code": "    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new AnnotatedXHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          71,
          83
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-html5/src/main/java/org/xwiki/rendering/internal/renderer/html5/HTML5ChainingRenderer.java",
        "class_name": "HTML5ChainingRenderer",
        "method_name": "HTML5ChainingRenderer",
        "signature": "HTML5ChainingRenderer(XHTMLLinkRenderer,XHTMLImageRenderer,HTMLElementSanitizer,ListenerChain)",
        "lines_hint_csv": [
          61,
          66
        ],
        "code": "    public HTML5ChainingRenderer(XHTMLLinkRenderer linkRenderer,\n            XHTMLImageRenderer imageRenderer,\n            ListenerChain listenerChain)\n    {\n        super(linkRenderer, imageRenderer, listenerChain);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          58,
          63
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-html5/src/main/java/org/xwiki/rendering/internal/renderer/html5/HTML5ChainingRenderer.java",
        "class_name": "HTML5ChainingRenderer",
        "method_name": "beginFormat",
        "signature": "void beginFormat(Format,Map<String, String>)",
        "lines_hint_csv": [
          69,
          86
        ],
        "code": "    public void beginFormat(Format format, Map<String, String> parameters)\n    {\n        // Right now, the only difference with the super class is about the \"monospace\" format\n        if (format == Format.MONOSPACE) {\n            Map<String, String> attributes = new HashMap<>();\n            attributes.putAll(parameters);\n            String cssClass = \"monospace\";\n            // The element may already have a class\n            if (attributes.containsKey(PROP_CLASS)) {\n                cssClass = String.format(\"%s %s\", cssClass, attributes.get(PROP_CLASS));\n            }\n            attributes.put(PROP_CLASS, cssClass);\n            getXHTMLWikiPrinter().printXMLStartElement(ELEM_SPAN, attributes);\n        } else {\n            // Call the super class\n            super.beginFormat(format, parameters);\n        }\n\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          66,
          84
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-html5/src/main/java/org/xwiki/rendering/internal/renderer/html5/HTML5Renderer.java",
        "class_name": "HTML5Renderer",
        "method_name": "initialize",
        "signature": "void initialize()",
        "lines_hint_csv": [
          70,
          83
        ],
        "code": "    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          66,
          78
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-html5/src/test/java/org/xwiki/rendering/internal/html5/HTML5ChainingRendererTest.java",
        "class_name": "HTML5ChainingRendererTest",
        "method_name": "setUp",
        "signature": "void setUp()",
        "lines_hint_csv": [
          56,
          64
        ],
        "code": "    public void setUp() throws Exception\n    {\n        linkRenderer = mock(XHTMLLinkRenderer.class);\n        imageRenderer = mock(XHTMLImageRenderer.class);\n        listenerChain = new ListenerChain();\n        chainingRenderer = new HTML5ChainingRenderer(linkRenderer, imageRenderer, listenerChain);\n        printer = new DefaultWikiPrinter();\n        chainingRenderer.setPrinter(printer);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          56,
          64
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-xhtml/src/main/java/org/xwiki/rendering/internal/parser/xhtml/wikimodel/XHTMLXWikiGeneratorListener.java",
        "class_name": "XHTMLXWikiGeneratorListener",
        "method_name": "cleanParametersFromMetadata",
        "signature": "WikiParameters cleanParametersFromMetadata(WikiParameters)",
        "lines_hint_csv": [
          203,
          218
        ],
        "code": "    private static WikiParameters cleanParametersFromMetadata(WikiParameters parameters)\n    {\n        WikiParameters wikiParameters = new WikiParameters();\n\n        for (WikiParameter parameter : parameters) {\n            boolean acceptParameter = !(parameter.getKey().startsWith(METADATA_ATTRIBUTE_PREFIX)\n                || (\n                    parameter.getKey().equals(CLASS_ATTRIBUTE) && parameter.getValue().equals(METADATA_CONTAINER_CLASS)\n            ));\n            if (acceptParameter) {\n                wikiParameters = wikiParameters.addParameter(parameter.getKey(), parameter.getValue());\n            }\n        }\n\n        return wikiParameters;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          200,
          215
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-xhtml/src/main/java/org/xwiki/rendering/internal/renderer/xhtml/XHTMLChainingRenderer.java",
        "class_name": "XHTMLChainingRenderer",
        "method_name": "XHTMLChainingRenderer",
        "signature": "XHTMLChainingRenderer(XHTMLLinkRenderer,XHTMLImageRenderer,HTMLElementSanitizer,ListenerChain)",
        "lines_hint_csv": [
          83,
          91
        ],
        "code": "    public XHTMLChainingRenderer(XHTMLLinkRenderer linkRenderer, XHTMLImageRenderer imageRenderer,\n        ListenerChain listenerChain)\n    {\n        setListenerChain(listenerChain);\n\n        this.linkRenderer = linkRenderer;\n        this.imageRenderer = imageRenderer;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          79,
          86
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-xhtml/src/main/java/org/xwiki/rendering/internal/renderer/xhtml/XHTMLChainingRenderer.java",
        "class_name": "XHTMLChainingRenderer",
        "method_name": "getXHTMLWikiPrinter",
        "signature": "XHTMLWikiPrinter getXHTMLWikiPrinter()",
        "lines_hint_csv": [
          126,
          132
        ],
        "code": "    protected XHTMLWikiPrinter getXHTMLWikiPrinter()\n    {\n        if (this.xhtmlWikiPrinter == null) {\n            this.xhtmlWikiPrinter = new XHTMLWikiPrinter(getPrinter());\n        }\n        return this.xhtmlWikiPrinter;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          127
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-xhtml/src/main/java/org/xwiki/rendering/internal/renderer/xhtml/XHTMLRenderer.java",
        "class_name": "XHTMLRenderer",
        "method_name": "initialize",
        "signature": "void initialize()",
        "lines_hint_csv": [
          70,
          83
        ],
        "code": "    public void initialize() throws InitializationException\n    {\n        ListenerChain chain = new ListenerChain();\n        setListenerChain(chain);\n\n        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners\n        // placed later in the chain.\n        chain.addListener(this);\n        chain.addListener(new BlockStateChainingListener(chain));\n        chain.addListener(new EmptyBlockChainingListener(chain));\n        chain.addListener(new MetaDataStateChainingListener(chain));\n        chain.addListener(new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, chain));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          66,
          78
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-xhtml/src/test/java/org/xwiki/rendering/internal/renderer/xhtml/XHTMLChainingRendererTest.java",
        "class_name": "XHTMLChainingRendererTest",
        "method_name": "outputFigureCaptionEvents",
        "signature": "void outputFigureCaptionEvents()",
        "lines_hint_csv": [
          45,
          55
        ],
        "code": "    void outputFigureCaptionEvents()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.beginFigureCaption(Collections.emptyMap());\n        renderer.onWord(\"caption\");\n        renderer.endFigureCaption(Collections.emptyMap());\n\n        assertEquals(\"<div class=\\\"figcaption\\\">caption</div>\", wikiPrinter.toString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          45,
          55
        ]
      },
      {
        "file_path": "xwiki-rendering-syntaxes/xwiki-rendering-syntax-xhtml/src/test/java/org/xwiki/rendering/internal/renderer/xhtml/XHTMLChainingRendererTest.java",
        "class_name": "XHTMLChainingRendererTest",
        "method_name": "onRawText",
        "signature": "void onRawText()",
        "lines_hint_csv": [
          58,
          71
        ],
        "code": "    void onRawText()\n    {\n        XHTMLChainingRenderer renderer = new XHTMLChainingRenderer(null, null, new ListenerChain());\n        WikiPrinter wikiPrinter = new DefaultWikiPrinter();\n        renderer.setPrinter(wikiPrinter);\n        renderer.onRawText(\"xhtml/1.0\", Syntax.XHTML_1_0);\n        renderer.onRawText(\"html/4.01\", Syntax.HTML_4_01);\n        renderer.onRawText(\"html/5.0\", Syntax.HTML_5_0);\n        renderer.onRawText(\"annotatedxhtml/1.0\", Syntax.ANNOTATED_XHTML_1_0);\n        renderer.onRawText(\"annotatedhtml/5.0\", Syntax.ANNOTATED_HTML_5_0);\n        renderer.onRawText(\"plain/1.0\", Syntax.PLAIN_1_0);\n\n        assertEquals(\"xhtml/1.0html/4.01html/5.0annotatedxhtml/1.0annotatedhtml/5.0\", wikiPrinter.toString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          58,
          71
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "XHTMLWikiPrinter",
        "signature": "XHTMLWikiPrinter(WikiPrinter)",
        "lines_hint_csv": [
          72,
          75
        ],
        "code": "    public XHTMLWikiPrinter(WikiPrinter printer)\n    {\n        super(printer);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          52,
          55
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLElement",
        "signature": "void printXMLElement(String)",
        "lines_hint_csv": [
          109,
          115
        ],
        "code": "    public void printXMLElement(String name, Map<String, String> attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLElement(name, attributes);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          93,
          97
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLElement",
        "signature": "void printXMLElement(String,String[][])",
        "lines_hint_csv": [
          118,
          124
        ],
        "code": "    public void printXMLElement(String name, Map<String, String> attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLElement(name, attributes);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          93,
          97
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLElement",
        "signature": "void printXMLElement(String,Map<String, String>)",
        "lines_hint_csv": [
          127,
          133
        ],
        "code": "    public void printXMLElement(String name, Map<String, String> attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLElement(name, attributes);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          93,
          97
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLStartElement",
        "signature": "void printXMLStartElement(String)",
        "lines_hint_csv": [
          136,
          142
        ],
        "code": "    public void printXMLStartElement(String name, Attributes attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name, attributes);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          125
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLStartElement",
        "signature": "void printXMLStartElement(String,String[][])",
        "lines_hint_csv": [
          145,
          151
        ],
        "code": "    public void printXMLStartElement(String name, Attributes attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name, attributes);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          125
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLStartElement",
        "signature": "void printXMLStartElement(String,Map<String, String>)",
        "lines_hint_csv": [
          154,
          160
        ],
        "code": "    public void printXMLStartElement(String name, Map<String, String> attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name, attributes);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          114,
          118
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLStartElement",
        "signature": "void printXMLStartElement(String,Attributes)",
        "lines_hint_csv": [
          163,
          169
        ],
        "code": "    public void printXMLStartElement(String name, Attributes attributes)\n    {\n        handleSpaceWhenStartElement();\n        super.printXMLStartElement(name, attributes);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          121,
          125
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "printXMLEndElement",
        "signature": "void printXMLEndElement(String)",
        "lines_hint_csv": [
          172,
          179
        ],
        "code": "    public void printXMLEndElement(String name)\n    {\n        handleSpaceWhenEndlement();\n        super.printXMLEndElement(name);\n        this.elementEnded = true;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          128,
          133
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-31126",
    "project_slug": "xwiki__xwiki-commons_CVE-2023-31126_14.10.3",
    "buggy_commit_id": "011dee864805aec0b24151f69f230a42e40087da",
    "github_url": "https://github.com/xwiki/xwiki-commons",
    "nvd_metadata": {
      "description": "`org.xwiki.commons:xwiki-commons-xml` is an XML library used by the open-source wiki platform XWiki. The HTML sanitizer, introduced in version 14.6-rc-1, allows the injection of arbitrary HTML code and thus cross-site scripting via invalid data attributes. This vulnerability does not affect restricted cleaning in HTMLCleaner as there attributes are cleaned and thus characters like `/` and `>` are removed in all attribute names. This problem has been patched in XWiki 14.10.4 and 15.0 RC1 by making sure that data attributes only contain allowed characters. There are no known workarounds apart from upgrading to a version including the fix.",
      "published_date": "2023-05-09T13:15:18.427",
      "cvss_v3_score": 9.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizer.java",
        "class_name": "SecureHTMLElementSanitizer",
        "method_name": "isAllowedValue",
        "signature": "boolean isAllowedValue(String,String,String)",
        "lines_hint_csv": [
          196,
          208
        ],
        "code": "    private boolean isAllowedValue(String lowercaseElementName, String lowercaseAttributeName, String attributeValue)\n    {\n        // Break into several statements to avoid too long boolean expression.\n        boolean result = StringUtils.isBlank(attributeValue);\n        if (!result) {\n            String valueNoWhitespace = ATTR_WHITESPACE.matcher(attributeValue).replaceAll(\"\");\n            result = this.uriSafeAttributes.contains(lowercaseAttributeName);\n            result = result || IS_NO_URI.matcher(valueNoWhitespace).find();\n            result = result || this.allowedUriPattern.matcher(valueNoWhitespace).find();\n            result = result || isAllowedDataValue(lowercaseElementName, lowercaseAttributeName, attributeValue);\n            result = result || (this.allowUnknownProtocols && !isScriptOrData(attributeValue));\n        }\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          196,
          209
        ]
      },
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizer.java",
        "class_name": "SecureHTMLElementSanitizer",
        "method_name": "isAttributeAllowed",
        "signature": "boolean isAttributeAllowed(String,String,String)",
        "lines_hint_csv": [
          178,
          193
        ],
        "code": "    public boolean isAttributeAllowed(String elementName, String attributeName, String attributeValue)\n    {\n        boolean result = false;\n\n        String lowerElement = elementName.toLowerCase();\n        String lowerAttribute = attributeName.toLowerCase();\n\n        if ((DATA_ATTR.matcher(lowerAttribute).find() || ARIA_ATTR.matcher(lowerAttribute).find())\n            && !this.forbidAttributes.contains(lowerAttribute))\n        {\n            result = true;\n        } else if (isAttributeAllowed(lowerAttribute) && !this.forbidAttributes.contains(lowerAttribute)) {\n            result = isAllowedValue(lowerElement, lowerAttribute, attributeValue);\n        }\n\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          178,
          194
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-46907",
    "project_slug": "apache__jspwiki_CVE-2022-46907_2.11.3",
    "buggy_commit_id": "515dff39c66c43318056fa76a20117662d2a0e8d",
    "github_url": "https://github.com/apache/jspwiki",
    "nvd_metadata": {
      "description": "A carefully crafted request on several JSPWiki plugins could trigger an XSS vulnerability on Apache JSPWiki, which could allow the attacker to execute javascript in the victim's browser and get some sensitive information about the victim.  Apache JSPWiki users should upgrade to 2.12.0 or later.",
      "published_date": "2023-05-25T07:15:08.620",
      "cvss_v3_score": 6.1,
      "severity": "MEDIUM"
    },
    "code_snippets": [
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/plugin/BugReportHandler.java",
        "class_name": "BugReportHandler",
        "method_name": "execute",
        "signature": "String execute(Context,Map)",
        "lines_hint_csv": [
          79,
          160
        ],
        "code": "    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final String title = params.get( PARAM_TITLE );\n        String description = params.get( PARAM_DESCRIPTION );\n        String version = params.get( PARAM_VERSION );\n        String submitter = null;\n        final SimpleDateFormat format = new SimpleDateFormat( DEFAULT_DATEFORMAT );\n        final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );\n        final Principal wup = context.getCurrentUser();\n\n        if( wup != null ) {\n            submitter = wup.getName();\n        }\n\n        if( title == null ) {\n            throw new PluginException(rb.getString(\"bugreporthandler.titlerequired\"));\n        }\n        if( title.isEmpty() ) {\n            return \"\";\n        }\n\n        if( description == null ) {\n            description = \"\";\n        }\n        if( version == null ) {\n            version = \"unknown\";\n        }\n\n        final Properties mappings = parseMappings( params.get( PARAM_MAPPINGS ) );\n\n        //  Start things\n        try {\n            final StringWriter str = new StringWriter();\n            final PrintWriter out = new PrintWriter( str );\n            final Date d = new Date();\n\n            //  Outputting of basic data\n            out.println( \"|\" + mappings.getProperty(PARAM_TITLE,\"Title\" ) + \"|\" + title );\n            out.println( \"|\" + mappings.getProperty(\"date\",\"Date\" ) + \"|\" + format.format( d ) );\n            out.println( \"|\" + mappings.getProperty(PARAM_VERSION,\"Version\" ) + \"|\" + version );\n            if( submitter != null ) {\n                out.println(\"|\"+mappings.getProperty(\"submitter\",\"Submitter\") + \"|\" + submitter );\n            }\n\n            //  Outputting the other parameters added to this.\n            for( final Map.Entry< String, String > entry : params.entrySet() ) {\n                if( !( entry.getKey().equals( PARAM_TITLE ) ||\n                       entry.getKey().equals( PARAM_DESCRIPTION ) ||\n                       entry.getKey().equals( PARAM_VERSION ) ||\n                       entry.getKey().equals( PARAM_MAPPINGS ) ||\n                       entry.getKey().equals( PARAM_PAGE ) ||\n                       entry.getKey().startsWith( \"_\" )\n                     ) ) {\n                    //  If no mapping has been defined, just ignore it.\n                    final String head = mappings.getProperty( entry.getKey(), entry.getKey() );\n                    if( !head.isEmpty() ) {\n                        out.println( \"|\" + head + \"|\" + entry.getValue() );\n                    }\n                }\n            }\n\n            out.println();\n            out.println( description );\n            out.close();\n\n            //  Now create a new page for this bug report\n            final String pageName = findNextPage( context, title, params.get( PARAM_PAGE ) );\n            final Page newPage = Wiki.contents().page( context.getEngine(), pageName );\n            final Context newContext = context.clone();\n            newContext.setPage( newPage );\n            context.getEngine().getManager( PageManager.class ).saveText( newContext, str.toString() );\n\n            final MessageFormat formatter = new MessageFormat(\"\");\n            formatter.applyPattern( rb.getString(\"bugreporthandler.new\") );\n            final String[] args = { \"<a href=\\\"\"+context.getViewURL(pageName)+\"\\\">\"+pageName+\"</a>\" };\n\n            return formatter.format( args );\n        } catch( final RedirectException e ) {\n            LOG.info(\"Saving not allowed, reason: '\"+e.getMessage()+\"', can't redirect to \"+e.getRedirect());\n            throw new PluginException(\"Saving not allowed, reason: \"+e.getMessage());\n        } catch( final WikiException e ) {\n            LOG.error( \"Unable to save page!\", e );\n            return rb.getString(\"bugreporthandler.unable\" );\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          79,
          162
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/plugin/InsertPage.java",
        "class_name": "InsertPage",
        "method_name": "execute",
        "signature": "String execute(Context,Map)",
        "lines_hint_csv": [
          85,
          212
        ],
        "code": "    public String execute( final Context context, final Map<String, String> params ) throws PluginException {\n        final Engine engine = context.getEngine();\n\n        final StringBuilder res = new StringBuilder();\n\n        final String clazz        = params.get( PARAM_CLASS );\n        final String includedPage = params.get( PARAM_PAGENAME );\n        String style              = params.get( PARAM_STYLE );\n        final boolean showOnce    = \"once\".equals( params.get( PARAM_SHOW ) );\n        final String defaultstr   = params.get( PARAM_DEFAULT );\n        final int section         = TextUtil.parseIntParameter(params.get( PARAM_SECTION ), -1 );\n        int maxlen                = TextUtil.parseIntParameter(params.get( PARAM_MAXLENGTH ), -1 );\n\n        final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );\n\n        if( style == null ) {\n            style = DEFAULT_STYLE;\n        }\n\n        if( maxlen == -1 ) {\n            maxlen = Integer.MAX_VALUE;\n        }\n\n        if( includedPage != null ) {\n            final Page page;\n            try {\n                final String pageName = engine.getFinalPageName( includedPage );\n                if( pageName != null ) {\n                    page = engine.getManager( PageManager.class ).getPage( pageName );\n                } else {\n                    page = engine.getManager( PageManager.class ).getPage( includedPage );\n                }\n            } catch( final ProviderException e ) {\n                res.append( \"<span class=\\\"error\\\">Page could not be found by the page provider.</span>\" );\n                return res.toString();\n            }\n\n            if( page != null ) {\n                //  Check for recursivity\n                List<String> previousIncludes = context.getVariable( ATTR_RECURSE );\n\n                if( previousIncludes != null ) {\n                    if( previousIncludes.contains( page.getName() ) ) {\n                        return \"<span class=\\\"error\\\">Error: Circular reference - you can't include a page in itself!</span>\";\n                    }\n                } else {\n                    previousIncludes = new ArrayList<>();\n                }\n\n                // Check for permissions\n                final AuthorizationManager mgr = engine.getManager( AuthorizationManager.class );\n\n                if( !mgr.checkPermission( context.getWikiSession(), PermissionFactory.getPagePermission( page, \"view\") ) ) {\n                    res.append(\"<span class=\\\"error\\\">You do not have permission to view this included page.</span>\");\n                    return res.toString();\n                }\n\n                // Show Once\n                // Check for page-cookie, only include page if cookie is not yet set\n                String cookieName = \"\";\n\n                if( showOnce ) {\n                    cookieName = ONCE_COOKIE + TextUtil.urlEncodeUTF8( page.getName() ).replaceAll( \"\\\\+\", \"%20\" );\n\n                    if( HttpUtil.retrieveCookieValue( context.getHttpRequest(), cookieName ) != null ) {\n                        return \"\";  //silent exit\n                    }\n\n                }\n\n                // move here, after premature exit points (permissions, page-cookie)\n                previousIncludes.add( page.getName() );\n                context.setVariable( ATTR_RECURSE, previousIncludes );\n\n                /**\n                 *  We want inclusion to occur within the context of\n                 *  its own page, because we need the links to be correct.\n                 */\n\n                final Context includedContext = context.clone();\n                includedContext.setPage( page );\n\n                String pageData = engine.getManager( PageManager.class ).getPureText( page );\n                String moreLink = \"\";\n\n                if( section != -1 ) {\n                    try {\n                        pageData = TextUtil.getSection( pageData, section );\n                    } catch( final IllegalArgumentException e ) {\n                        throw new PluginException( e.getMessage() );\n                    }\n                }\n\n                if( pageData.length() > maxlen ) {\n                    pageData = pageData.substring( 0, maxlen )+\" ...\";\n                    moreLink = \"<p><a href=\\\"\"+context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(),includedPage)+\"\\\">\"+rb.getString(\"insertpage.more\")+\"</a></p>\";\n                }\n\n                res.append(\"<div class=\\\"inserted-page \");\n                if( clazz != null ) res.append( clazz );\n                if( !style.equals(DEFAULT_STYLE) ) res.append( \"\\\" style=\\\"\" ).append( style );\n                if( showOnce ) res.append( \"\\\" data-once=\\\"\" ).append( cookieName );\n                res.append(\"\\\" >\");\n\n                res.append( engine.getManager( RenderingManager.class ).textToHTML( includedContext, pageData ) );\n                res.append( moreLink );\n\n                res.append(\"</div>\");\n\n                //\n                //  Remove the name from the stack; we're now done with this.\n                //\n                previousIncludes.remove( page.getName() );\n                context.setVariable( ATTR_RECURSE, previousIncludes );\n            } else {\n                if( defaultstr != null ) {\n                    res.append( defaultstr );\n                } else {\n                    res.append( \"There is no page called '\" ).append( includedPage ).append( \"'.  Would you like to \" );\n                    res.append( \"<a href=\\\"\" ).append( context.getURL( ContextEnum.PAGE_EDIT.getRequestContext(), includedPage ) ).append( \"\\\">create it?</a>\" );\n                }\n            }\n        } else {\n            res.append( \"<span class=\\\"error\\\">\" );\n            res.append( \"You have to define a page!\" );\n            res.append( \"</span>\" );\n        }\n        return res.toString();\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          85,
          213
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/forms/FormOutput.java",
        "class_name": "FormOutput",
        "method_name": "execute",
        "signature": "String execute(Context,Map)",
        "lines_hint_csv": [
          58,
          134
        ],
        "code": "    public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {\n        //  If there is no HTTP request, returns immediately.\n        if( ctx.getHttpRequest() == null ) {\n            return \"\";\n        }\n        final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );\n        \n        // If we are NOT here due to this form being submitted, we do nothing.\n        // The submitted form MUST have parameter 'formname' equal to the name\n        // parameter of this Form plugin.\n\n        final String formName   = params.get( PARAM_FORM );\n        final String submitForm = ctx.getHttpParameter( PARAM_FORMNAMEHIDDEN );\n        final String populator  = params.get( PARAM_POPULATE );\n\n        if( formName == null || !formName.equals( submitForm ) ) {\n            // No submitForm -> this was not a submission from the\n            // generated form.  If populate is specified, we'll go\n            // ahead and let the handler (populator) put stuff into\n            // the context, otherwise we'll just hide.\n            if( !PARAM_HANDLER.equals( populator ) )\n                return \"\";\n            // If population was allowed, we should first  \n        }\n\n        final String handler = params.get( PARAM_HANDLER );\n        if( handler == null || handler.isEmpty() ) {\n            // Need to print out an error here as this form is misconfigured\n            return \"<p class=\\\"error\\\">\" + MessageFormat.format( rb.getString( \"formoutput.missingargument\" ), PARAM_HANDLER ) + \"</p>\";\n        }\n\n        final String sourcePage = ctx.getPage().getName();\n        final String submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );\n\n        // If there is previous FormInfo available - say, from a\n        // FormSet plugin - use it.\n        FormInfo info = getFormInfo( ctx );\n        if( info == null ) {\n            // Reconstruct the form info from post data\n            info = new FormInfo();\n            info.setName( formName );\n        }\n        // Force override of handler and submit.\n        info.setHandler( handler );\n        info.setAction( submitServlet );\n\n        // Sift out all extra parameters, leaving only those submitted in the HTML FORM.\n        final Map< String, String > handlerParams = FormUtil.requestToMap( ctx.getHttpRequest(), HANDLERPARAM_PREFIX );\n        // Previous submission info may be available from FormSet\n        // plugin - add, don't replace.\n        info.addSubmission( handlerParams );\n\n        // Pass the _body parameter from FormOutput on to the handler\n        info.getSubmission().put( DefaultPluginManager.PARAM_BODY, params.get(DefaultPluginManager.PARAM_BODY ) );\n\n        String handlerOutput = null;\n        String error = null;\n        try {\n            // The plugin _can_ modify the parameters, so we make sure they stay with us.\n            final PluginManager pm = ctx.getEngine().getManager( PluginManager.class );\n            handlerOutput = pm.execute( ctx, handler, info.getSubmission() );\n            info.setResult( handlerOutput );\n            info.setStatus( FormInfo.EXECUTED );\n        } catch( final PluginException pe ) {\n            error = \"<p class=\\\"error\\\">\" + pe.getMessage() + \"</p>\";\n            info.setError( error );\n            info.setStatus( FormInfo.ERROR );\n        }\n\n        // We store the forminfo, so following Form plugin invocations on this\n        // page can decide what to do based on its values.\n        storeFormInfo( ctx, info );\n\n        if( error != null )\n            return error;\n\n        return handlerOutput != null ? handlerOutput : \"\";\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          58,
          135
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/forms/FormOpen.java",
        "class_name": "FormOpen",
        "method_name": "execute",
        "signature": "String execute(Context,Map)",
        "lines_hint_csv": [
          81,
          132
        ],
        "code": "    public String execute( final Context ctx, final Map< String, String > params ) throws PluginException {\n        final ResourceBundle rb = Preferences.getBundle( ctx, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );\n        final String formName = params.get( PARAM_FORM );\n        if( formName == null ) {\n            throw new PluginException( MessageFormat.format( rb.getString( \"formopen.missingparam\" ), PARAM_FORM ) );\n        }\n        final String hide     = params.get( PARAM_HIDEFORM );\n        final String sourcePage = ctx.getPage().getName();\n        String submitServlet = params.get( PARAM_SUBMITHANDLER );\n        if( submitServlet == null )\n            submitServlet = ctx.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), sourcePage );\n\n        String method = params.get( PARAM_METHOD );\n        if( method == null ) {\n            method=\"post\";\n        }\n\n        if( !( method.equalsIgnoreCase( \"get\" ) || method.equalsIgnoreCase( \"post\" ) ) ) {\n            throw new PluginException( rb.getString( \"formopen.postorgetonly\" ) );\n        }\n\n        FormInfo info = getFormInfo( ctx );\n        if( info != null ) {\n            // Previous information may be the result of submitting\n            // this form, or of a FormSet plugin, or both. If it\n            // exists and is for this form, fine.\n            if( formName.equals( info.getName() ) ) {\n                LOG.debug( \"Previous FormInfo for this form was found in context.\" );\n                // If the FormInfo exists, and if we're supposed to display on error only, we need to exit now.\n                if( HIDE_SUCCESS.equals( hide ) && info.getStatus() == FormInfo.EXECUTED ) {\n                    info.setHide( true );\n                    return \"<p>\" + rb.getString( \"formopen.noneedtoshow\" ) + \"</p>\";\n                }\n            } else {\n                // This would mean that a new form was started without closing an old one.  Get rid of the garbage.\n                info = new FormInfo();\n            }\n        } else {\n            // No previous FormInfo available; store now, so it'll be available for upcoming Form input elements.\n            info = new FormInfo();\n            storeFormInfo( ctx, info );\n        }\n\n        info.setName( formName );\n        info.setAction( submitServlet );\n\n        return \"<div class=\\\"wikiform\\\">\\n\" +\n                  \"<form action=\\\"\" + submitServlet + \"\\\" name=\\\"\" + formName + \"\\\" \" +\n                        \"accept-charset=\\\"\" + ctx.getEngine().getContentEncoding() + \"\\\" \" +\n                        \"method=\\\"\" + method + \"\\\" enctype=\\\"application/x-www-form-urlencoded\\\">\\n\" +\n                  \"  <input type=\\\"hidden\\\" name=\\\"\" + PARAM_FORMNAMEHIDDEN + \"\\\" value=\\\"\" + formName + \"\\\"/>\\n\" +\n                  \"  <input type=\\\"hidden\\\" name=\\\"\" + CsrfProtectionFilter.ANTICSRF_PARAM + \"\\\" value=\\\"\" + ctx.getWikiSession().antiCsrfToken() + \"\\\"/>\\n\";\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          81,
          133
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/plugin/CurrentTimePlugin.java",
        "class_name": "CurrentTimePlugin",
        "method_name": "execute",
        "signature": "String execute(Context,Map)",
        "lines_hint_csv": [
          49,
          65
        ],
        "code": "    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final String formatString = params.get( \"format\" );\n\n        try {\n            final SimpleDateFormat fmt;\n            if( formatString != null ) {\n                fmt = new SimpleDateFormat( formatString );\n            } else {\n                fmt = Preferences.getDateFormat( context, TimeFormat.DATETIME );\n            }\n\n            final Date d = new Date();  // Now.\n\n            return fmt.format( d );\n        } catch( final IllegalArgumentException e ) {\n            final ResourceBundle rb = Preferences.getBundle( context, Plugin.CORE_PLUGINS_RESOURCEBUNDLE );\n            throw new PluginException( rb.getString( \"currenttimeplugin.badformat\" ) + e.getMessage() );\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          49,
          67
        ]
      },
      {
        "file_path": "jspwiki-main/src/main/java/org/apache/wiki/plugin/Search.java",
        "class_name": "Search",
        "method_name": "execute",
        "signature": "String execute(Context,Map)",
        "lines_hint_csv": [
          73,
          101
        ],
        "code": "    public String execute( final Context context, final Map<String, String> params ) throws PluginException {\n        int maxItems = Integer.MAX_VALUE;\n        final Collection< SearchResult > results;\n\n        final String queryString = params.get( PARAM_QUERY );\n        String set               = params.get( PARAM_SET );\n        final String max         = params.get( PARAM_MAX );\n\n        if ( set == null ) set = DEFAULT_SETNAME;\n        if ( max != null ) maxItems = Integer.parseInt( max );\n\n        if ( queryString == null ) {\n            results = context.getVariable( set );\n        } else {\n            try {\n                results = doBasicQuery( context, queryString );\n                context.setVariable( set, results );\n            } catch( final Exception e ) {\n                return \"<div class='error'>\" + e.getMessage() + \"</div>\\n\";\n            }\n        }\n\n        String res = \"\";\n\n        if ( results != null ) {\n            res = renderResults(results,context,maxItems);\n        }\n\n        return res;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          73,
          102
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-4361",
    "project_slug": "keycloak__keycloak_CVE-2022-4361_21.1.1",
    "buggy_commit_id": "0ca0a5fa4459d97c4d769fec15b4ba99c3824314",
    "github_url": "https://github.com/keycloak/keycloak",
    "nvd_metadata": {
      "description": "Keycloak, an open-source identity and access management solution, has a cross-site scripting (XSS) vulnerability in the SAML or OIDC providers. The vulnerability can allow an attacker to execute malicious scripts by setting the AssertionConsumerServiceURL value or the redirect_uri.",
      "published_date": "2023-07-07T20:15:09.813",
      "cvss_v3_score": 10.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "decodeRedirectUri",
        "signature": "String decodeRedirectUri(String)",
        "lines_hint_csv": [
          175,
          206
        ],
        "code": "    private static String decodeRedirectUri(String redirectUri) {\n        if (redirectUri == null) return null;\n        int MAX_DECODING_COUNT = 5; // Max count of attempts for decoding URL (in case it was encoded multiple times)\n\n        try {\n            KeycloakUriBuilder uriBuilder = KeycloakUriBuilder.fromUri(redirectUri).preserveDefaultPort();\n            String origQuery = uriBuilder.getQuery();\n            String origFragment = uriBuilder.getFragment();\n            String encodedRedirectUri = uriBuilder\n                    .replaceQuery(null)\n                    .fragment(null)\n                    .buildAsString();\n            String decodedRedirectUri = null;\n\n            for (int i = 0; i < MAX_DECODING_COUNT; i++) {\n                decodedRedirectUri = Encode.decode(encodedRedirectUri);\n                if (decodedRedirectUri.equals(encodedRedirectUri)) {\n                    // URL is decoded. We can return it (after attach original query and fragment)\n                    return KeycloakUriBuilder.fromUri(decodedRedirectUri).preserveDefaultPort()\n                            .replaceQuery(origQuery)\n                            .fragment(origFragment)\n                            .buildAsString();\n                } else {\n                    // Next attempt\n                    encodedRedirectUri = decodedRedirectUri;\n                }\n            }\n        } catch (IllegalArgumentException iae) {\n            logger.debugf(\"Illegal redirect URI used: %s, Details: %s\", redirectUri, iae.getMessage());\n        }\n        logger.debugf(\"Was not able to decode redirect URI: %s\", redirectUri);\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          175,
          207
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "validateRedirectUriWildcard",
        "signature": "String validateRedirectUriWildcard(String)",
        "lines_hint_csv": [
          257,
          265
        ],
        "code": "    public static String validateRedirectUriWildcard(String redirectUri) {\n        if (redirectUri == null)\n            return null;\n\n        int idx = redirectUri.indexOf(\"/*\");\n        if (idx > -1) {\n            redirectUri = redirectUri.substring(0, idx);\n        }\n        return redirectUri;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          257,
          266
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "matchesRedirects",
        "signature": "boolean matchesRedirects(Set,String,boolean)",
        "lines_hint_csv": [
          232,
          248
        ],
        "code": "    private static boolean matchesRedirects(Set<String> validRedirects, String redirect, boolean allowWildcards) {\n        logger.tracef(\"matchesRedirects: redirect URL to check: %s, allow wildcards: %b, Configured valid redirect URLs: %s\", redirect, allowWildcards, validRedirects);\n        for (String validRedirect : validRedirects) {\n            if (validRedirect.endsWith(\"*\") && !validRedirect.contains(\"?\") && allowWildcards) {\n                // strip off the query component - we don't check them when wildcards are effective\n                String r = redirect.contains(\"?\") ? redirect.substring(0, redirect.indexOf(\"?\")) : redirect;\n                // strip off *\n                int length = validRedirect.length() - 1;\n                validRedirect = validRedirect.substring(0, length);\n                if (r.startsWith(validRedirect)) return true;\n                // strip off trailing '/'\n                if (length - 1 > 0 && validRedirect.charAt(length - 1) == '/') length--;\n                validRedirect = validRedirect.substring(0, length);\n                if (validRedirect.equals(r)) return true;\n            } else if (validRedirect.equals(redirect)) return true;\n        }\n        return false;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          232,
          249
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "verifyRedirectUri",
        "signature": "String verifyRedirectUri(KeycloakSession,String,String,Set,boolean)",
        "lines_hint_csv": [
          92,
          152
        ],
        "code": "    public static String verifyRedirectUri(KeycloakSession session, String rootUrl, String redirectUri, Set<String> validRedirects, boolean requireRedirectUri) {\n        KeycloakUriInfo uriInfo = session.getContext().getUri();\n        RealmModel realm = session.getContext().getRealm();\n\n        if (redirectUri == null) {\n            if (!requireRedirectUri) {\n                redirectUri = getSingleValidRedirectUri(validRedirects);\n            }\n\n            if (redirectUri == null) {\n                logger.debug(\"No Redirect URI parameter specified\");\n                return null;\n            }\n        } else if (validRedirects.isEmpty()) {\n            logger.debug(\"No Redirect URIs supplied\");\n            redirectUri = null;\n        } else {\n            // Make the validations against fully decoded and normalized redirect-url. This also allows wildcards (case when client configured \"Valid redirect-urls\" contain wildcards)\n            String decodedRedirectUri = decodeRedirectUri(redirectUri);\n            decodedRedirectUri = getNormalizedRedirectUri(decodedRedirectUri);\n            if (decodedRedirectUri == null) return null;\n\n            String r = decodedRedirectUri;\n            Set<String> resolveValidRedirects = resolveValidRedirects(session, rootUrl, validRedirects);\n\n            boolean valid = matchesRedirects(resolveValidRedirects, r, true);\n\n            if (!valid && (r.startsWith(Constants.INSTALLED_APP_URL) || r.startsWith(Constants.INSTALLED_APP_LOOPBACK)) && r.indexOf(':', Constants.INSTALLED_APP_URL.length()) >= 0) {\n                int i = r.indexOf(':', Constants.INSTALLED_APP_URL.length());\n\n                StringBuilder sb = new StringBuilder();\n                sb.append(r.substring(0, i));\n\n                i = r.indexOf('/', i);\n                if (i >= 0) {\n                    sb.append(r.substring(i));\n                }\n\n                r = sb.toString();\n\n                valid = matchesRedirects(resolveValidRedirects, r, true);\n            }\n\n            // Return the original redirectUri, which can be partially encoded - for example http://localhost:8280/foo/bar%20bar%2092%2F72/3 . Just make sure it is normalized\n            redirectUri = getNormalizedRedirectUri(redirectUri);\n\n            // We try to check validity also for original (encoded) redirectUrl, but just in case it exactly matches some \"Valid Redirect URL\" specified for client (not wildcards allowed)\n            if (!valid) {\n                valid = matchesRedirects(resolveValidRedirects, redirectUri, false);\n            }\n\n            if (valid && redirectUri.startsWith(\"/\")) {\n                redirectUri = relativeToAbsoluteURI(session, rootUrl, redirectUri);\n            }\n            redirectUri = valid ? redirectUri : null;\n        }\n\n        if (Constants.INSTALLED_APP_URN.equals(redirectUri)) {\n            return Urls.realmInstalledAppUrnCallback(uriInfo.getBaseUri(), realm.getName()).toString();\n        } else {\n            return redirectUri;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          92,
          154
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "resolveValidRedirects",
        "signature": "Set resolveValidRedirects(KeycloakSession,String,Set)",
        "lines_hint_csv": [
          67,
          79
        ],
        "code": "    public static Set<String> resolveValidRedirects(KeycloakSession session, String rootUrl, Set<String> validRedirects) {\n        // If the valid redirect URI is relative (no scheme, host, port) then use the request's scheme, host, and port\n        Set<String> resolveValidRedirects = new HashSet<>();\n        for (String validRedirect : validRedirects) {\n            if (validRedirect.startsWith(\"/\")) {\n                validRedirect = relativeToAbsoluteURI(session, rootUrl, validRedirect);\n                logger.debugv(\"replacing relative valid redirect with: {0}\", validRedirect);\n                resolveValidRedirects.add(validRedirect);\n            } else {\n                resolveValidRedirects.add(validRedirect);\n            }\n        }\n        return resolveValidRedirects;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          67,
          80
        ]
      },
      {
        "file_path": "services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java",
        "class_name": "RedirectUtils",
        "method_name": "getNormalizedRedirectUri",
        "signature": "String getNormalizedRedirectUri(String)",
        "lines_hint_csv": [
          156,
          170
        ],
        "code": "    private static String getNormalizedRedirectUri(String redirectUri) {\n        if (redirectUri != null) {\n            try {\n                URI uri = URI.create(redirectUri);\n                redirectUri = uri.normalize().toString();\n            } catch (IllegalArgumentException cause) {\n                logger.debug(\"Invalid redirect uri\", cause);\n                return null;\n            } catch (Exception cause) {\n                logger.debug(\"Unexpected error when parsing redirect uri\", cause);\n                return null;\n            }\n            redirectUri = lowerCaseHostname(redirectUri);\n        }\n        return redirectUri;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          156,
          171
        ]
      },
      {
        "file_path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/AuthorizationCodeTest.java",
        "class_name": "AuthorizationCodeTest",
        "method_name": "authorizationRequestFragmentResponseModeNotKept",
        "signature": "void authorizationRequestFragmentResponseModeNotKept()",
        "lines_hint_csv": [
          250,
          272
        ],
        "code": "    public void authorizationRequestFragmentResponseModeNotKept() throws Exception {\n        // Set response_mode=fragment and login\n        oauth.responseMode(OIDCResponseMode.FRAGMENT.value());\n        OAuthClient.AuthorizationEndpointResponse response = oauth.doLogin(\"test-user@localhost\", \"password\");\n\n        Assert.assertNotNull(response.getCode());\n        Assert.assertNotNull(response.getState());\n\n        URI currentUri = new URI(driver.getCurrentUrl());\n        Assert.assertNull(currentUri.getRawQuery());\n        Assert.assertNotNull(currentUri.getRawFragment());\n\n        // Unset response_mode. The initial OIDC AuthenticationRequest won't contain \"response_mode\" parameter now and hence it should fallback to \"query\".\n        oauth.responseMode(null);\n        oauth.openLoginForm();\n        response = new OAuthClient.AuthorizationEndpointResponse(oauth);\n\n        Assert.assertNotNull(response.getCode());\n        Assert.assertNotNull(response.getState());\n\n        currentUri = new URI(driver.getCurrentUrl());\n        Assert.assertNotNull(currentUri.getRawQuery());\n        Assert.assertNull(currentUri.getRawFragment());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          250,
          273
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-36471",
    "project_slug": "xwiki__xwiki-commons_CVE-2023-36471_14.10.5",
    "buggy_commit_id": "8dfb9fcb4f456c70f82ea670ca0e2f3dee373ee4",
    "github_url": "https://github.com/xwiki/xwiki-commons",
    "nvd_metadata": {
      "description": "Xwiki commons is the common modules used by other XWiki top level projects. The HTML sanitizer that is included in XWiki since version 14.6RC1 allowed form and input HTML tags. In the context of XWiki, this allows an attacker without script right to either create forms that can be used for phishing attacks or also in the context of a sheet, the attacker could add an input like `{{html}}<input type=\"hidden\" name=\"content\" value=\"{{groovy}}println(&quot;Hello from Groovy!&quot;)\" />{{/html}}` that would allow remote code execution when it is submitted by an admin (the sheet is rendered as part of the edit form). The attacker would need to ensure that the edit form looks plausible, though, which can be non-trivial as without script right the attacker cannot display the regular content of the document. This has been patched in XWiki 14.10.6 and 15.2RC1 by removing the central form-related tags from the list of allowed tags. Users are advised to upgrade. As a workaround an admin can manually disallow the tags by adding `form, input, select, textarea, button` to the configuration option `xml.htmlElementSanitizer.forbidTags` in the `xwiki.properties` configuration file.",
      "published_date": "2023-06-29T20:15:10.003",
      "cvss_v3_score": 9.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/HTMLDefinitions.java",
        "class_name": "HTMLDefinitions",
        "method_name": "HTMLDefinitions",
        "signature": "HTMLDefinitions()",
        "lines_hint_csv": [
          61,
          90
        ],
        "code": "    public HTMLDefinitions()\n    {\n        this.htmlTags = new HashSet<>(\n            Arrays.asList(\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\",\n                \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\",\n                \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\",\n                \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\",\n                \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\",\n                \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\",\n                \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\",\n                \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\",\n                \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\",\n                \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"));\n\n        // Attributes that are in general allowed. Note that \"target\" is not generally safe, but XWiki contains code\n        // that already adds the necessary attributes to make it safe both in HTMLCleaner and in XHTML rendering.\n        this.htmlAttributes = new HashSet<>(\n            Arrays.asList(\"accept\", \"action\", \"align\", \"alt\", \"autocapitalize\", \"autocomplete\", \"autopictureinpicture\",\n                \"autoplay\", \"background\", \"bgcolor\", \"border\", \"capture\", \"cellpadding\", \"cellspacing\", \"checked\",\n                \"cite\", \"class\", \"clear\", \"color\", \"cols\", \"colspan\", \"controls\", \"controlslist\", \"coords\",\n                \"crossorigin\", \"datetime\", \"decoding\", \"default\", \"dir\", \"disabled\", \"disablepictureinpicture\",\n                \"disableremoteplayback\", \"download\", \"draggable\", \"enctype\", \"enterkeyhint\", \"face\", \"for\", \"headers\",\n                \"height\", \"hidden\", \"high\", \"href\", \"hreflang\", \"id\", \"inputmode\", \"integrity\", \"ismap\", \"kind\",\n                \"label\", \"lang\", \"list\", \"loading\", \"loop\", \"low\", \"max\", \"maxlength\", \"media\", \"method\", \"min\",\n                \"minlength\", \"multiple\", \"muted\", \"name\", \"nonce\", \"noshade\", \"novalidate\", \"nowrap\", \"open\", \"optimum\",\n                \"pattern\", \"placeholder\", \"playsinline\", \"poster\", \"preload\", \"pubdate\", \"radiogroup\", \"readonly\",\n                \"rel\", \"required\", \"rev\", \"reversed\", \"role\", \"rows\", \"rowspan\", \"spellcheck\", \"scope\", \"selected\",\n                \"shape\", \"size\", \"sizes\", \"span\", \"srclang\", \"start\", \"src\", \"srcset\", \"step\", \"style\", \"summary\",\n                \"tabindex\", \"title\", \"translate\", \"type\", \"usemap\", \"valign\", \"value\", \"width\", \"xmlns\", \"slot\",\n                \"target\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          61,
          91
        ]
      },
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/test/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizerTest.java",
        "class_name": "SecureHTMLElementSanitizerTest",
        "method_name": "extraAllowedTags",
        "signature": "void extraAllowedTags()",
        "lines_hint_csv": [
          99,
          101
        ],
        "code": "    void extraAllowedTags()\n    {\n        assertTrue(this.secureHTMLElementSanitizer.isElementAllowed(HTMLConstants.TAG_SCRIPT));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          99,
          102
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-33962",
    "project_slug": "jstachio__jstachio_CVE-2023-33962_1.0.0",
    "buggy_commit_id": "9ce20009d6bf726086fc528fceb174933077bff4",
    "github_url": "https://github.com/jstachio/jstachio",
    "nvd_metadata": {
      "description": "JStachio is a  type-safe Java Mustache templating engine. Prior to version 1.0.1, JStachio fails to escape single quotes `'` in HTML, allowing an attacker to inject malicious code. This vulnerability can be exploited by an attacker to execute arbitrary JavaScript code in the context of other users visiting pages that use this template engine. This can lead to various consequences, including session hijacking, defacement of web pages, theft of sensitive information, or even the propagation of malware.\n\nVersion 1.0.1 contains a patch for this issue. To mitigate this vulnerability, the template engine should properly escape special characters, including single quotes. Common practice is to escape `'` as `&#39`. As a workaround, users can avoid this issue by using only double quotes `\"` for HTML attributes.",
      "published_date": "2023-05-30T22:15:10.933",
      "cvss_v3_score": 5.4,
      "severity": "MEDIUM"
    },
    "code_snippets": []
  },
  {
    "cve_id": "CVE-2023-37908",
    "project_slug": "xwiki__xwiki-rendering_CVE-2023-37908_14.10.3",
    "buggy_commit_id": "0b0286c4caeab4cc1fdd617ec5bf0a91e6f46762",
    "github_url": "https://github.com/xwiki/xwiki-rendering",
    "nvd_metadata": {
      "description": "XWiki Rendering is a generic Rendering system that converts textual input in a given syntax into another syntax. The cleaning of attributes during XHTML rendering, introduced in version 14.6-rc-1, allowed the injection of arbitrary HTML code and thus cross-site scripting via invalid attribute names. This can be exploited, e.g., via the link syntax in any content that supports XWiki syntax like comments in XWiki. When a user moves the mouse over a malicious link, the malicious JavaScript code is executed in the context of the user session. When this user is a privileged user who has programming rights, this allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. While this attribute was correctly recognized as not allowed, the attribute was still printed with a prefix `data-xwiki-translated-attribute-` without further cleaning or validation. This problem has been patched in XWiki 14.10.4 and 15.0 RC1 by removing characters not allowed in data attributes and then validating the cleaned attribute again. There are no known workarounds apart from upgrading to a version including the fix.",
      "published_date": "2023-10-25T18:17:28.333",
      "cvss_v3_score": 9.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "xwiki-commons-core/xwiki-commons-xml/src/test/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizerTest.java",
        "class_name": "SecureHTMLElementSanitizer",
        "method_name": "isAttributeAllowed",
        "signature": "boolean isAttributeAllowed(String elementName, String attributeName, String attributeValue)",
        "lines_hint_csv": [
          189,
          205
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "cleanAttributes",
        "signature": "Map<String, String> cleanAttributes(String elementName, Map<String, String> attributes)",
        "lines_hint_csv": [
          264,
          288
        ],
        "code": "    private Map<String, String> cleanAttributes(String elementName, Map<String, String> attributes)\n    {\n        Map<String, String> cleanAttributes;\n\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            cleanAttributes = attributes;\n        } else {\n            cleanAttributes = new LinkedHashMap<>();\n            for (Map.Entry<String, String> e : attributes.entrySet()) {\n                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, e.getKey(), e.getValue())) {\n                    cleanAttributes.put(e.getKey(), e.getValue());\n                } else {\n                    cleanAttributes.put(TRANSLATED_ATTRIBUTE_PREFIX + e.getKey(), e.getValue());\n                }\n            }\n        }\n\n        return cleanAttributes;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          251,
          269
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "cleanAttributes",
        "signature": "String[][] cleanAttributes(String elementName, String[][] attributes)",
        "lines_hint_csv": [
          290,
          317
        ],
        "code": "    private Attributes cleanAttributes(String elementName, Attributes attributes)\n    {\n        Attributes allowedAttribute;\n\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            allowedAttribute = attributes;\n        } else {\n            allowedAttribute = new AttributesImpl();\n\n            for (int i = 0; i < attributes.getLength(); ++i) {\n                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, attributes.getQName(i),\n                    attributes.getValue(i)))\n                {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null, attributes.getQName(i),\n                        null, attributes.getValue(i));\n                } else {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null,\n                        TRANSLATED_ATTRIBUTE_PREFIX + attributes.getQName(i), null, attributes.getValue(i));\n                }\n            }\n        }\n\n        return allowedAttribute;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          291,
          314
        ]
      },
      {
        "file_path": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java",
        "class_name": "XHTMLWikiPrinter",
        "method_name": "cleanAttributes",
        "signature": "Attributes cleanAttributes(String elementName, Attributes attributes)",
        "lines_hint_csv": [
          319,
          350
        ],
        "code": "    private Attributes cleanAttributes(String elementName, Attributes attributes)\n    {\n        Attributes allowedAttribute;\n\n        if (this.htmlElementSanitizer == null || attributes == null) {\n            allowedAttribute = attributes;\n        } else {\n            allowedAttribute = new AttributesImpl();\n\n            for (int i = 0; i < attributes.getLength(); ++i) {\n                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, attributes.getQName(i),\n                    attributes.getValue(i)))\n                {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null, attributes.getQName(i),\n                        null, attributes.getValue(i));\n                } else {\n                    ((AttributesImpl) allowedAttribute).addAttribute(null, null,\n                        TRANSLATED_ATTRIBUTE_PREFIX + attributes.getQName(i), null, attributes.getValue(i));\n                }\n            }\n        }\n\n        return allowedAttribute;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          291,
          314
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2018-1260",
    "project_slug": "SpringSource__spring-security-oauth_CVE-2018-1260_2.3.2.RELEASE",
    "buggy_commit_id": "97e39dde7e88aae802be98de084a382886ca4255",
    "github_url": "https://github.com/spring-attic/spring-security-oauth",
    "nvd_metadata": {
      "description": "Spring Security OAuth, versions 2.3 prior to 2.3.3, 2.2 prior to 2.2.2, 2.1 prior to 2.1.2, 2.0 prior to 2.0.15 and older unsupported versions contains a remote code execution vulnerability. A malicious user or attacker can craft an authorization request to the authorization endpoint that can lead to remote code execution when the resource owner is forwarded to the approval endpoint.",
      "published_date": "2018-05-11T20:29:00.353",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "spring-security-oauth2/src/main/java/org/springframework/security/oauth2/client/DefaultOAuth2RequestAuthenticator.java",
        "class_name": "DefaultOAuth2RequestAuthenticator",
        "method_name": "authenticate",
        "signature": "void authenticate(OAuth2ProtectedResourceDetails,OAuth2ClientContext,ClientHttpRequest)",
        "lines_hint_csv": [
          29,
          39
        ],
        "code": "\tpublic void authenticate(OAuth2ProtectedResourceDetails resource, OAuth2ClientContext clientContext,\n\t\t\tClientHttpRequest request) {\n\t\tOAuth2AccessToken accessToken = clientContext.getAccessToken();\n\t\tif (accessToken == null) {\n\t\t\tthrow new AccessTokenRequiredException(resource);\n\t\t}\n\t\tString tokenType = accessToken.getTokenType();\n\t\tif (!StringUtils.hasText(tokenType)) {\n\t\t\ttokenType = OAuth2AccessToken.BEARER_TYPE; // we'll assume basic bearer token type if none is specified.\n\t\t}\n\t\trequest.getHeaders().set(\"Authorization\", String.format(\"%s %s\", tokenType, accessToken.getValue()));\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          29,
          40
        ]
      },
      {
        "file_path": "spring-security-oauth2/src/test/java/org/springframework/security/oauth2/client/DefaultOAuth2RequestAuthenticatorTests.java",
        "class_name": "DefaultOAuth2RequestAuthenticatorTests",
        "method_name": "addsAccessToken",
        "signature": "void addsAccessToken()",
        "lines_hint_csv": [
          43,
          48
        ],
        "code": "\tpublic void addsAccessToken() {\n\t\tcontext.setAccessToken(new DefaultOAuth2AccessToken(\"FOO\"));\n\t\tBaseOAuth2ProtectedResourceDetails resource = new BaseOAuth2ProtectedResourceDetails();\n\t\tauthenticator.authenticate(resource, context, request);\n\t\tString header = request.getHeaders().getFirst(\"Authorization\");\n\t\tassertEquals(\"bearer FOO\", header);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          43,
          49
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2019-0222",
    "project_slug": "apache__activemq_CVE-2019-0222_5.15.8",
    "buggy_commit_id": "bcad7e1f6a6dd078d87787a03b56560e995ef773",
    "github_url": "https://github.com/apache/activemq",
    "nvd_metadata": {
      "description": "In Apache ActiveMQ 5.0.0 - 5.15.8, unmarshalling corrupt MQTT frame can lead to broker Out of Memory exception making it unresponsive.",
      "published_date": "2019-03-28T22:29:00.433",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "activemq-mqtt/src/test/java/org/apache/activemq/transport/mqtt/MQTTCodecTest.java",
        "class_name": "MQTTCodecTest",
        "method_name": "testMessageDecodingPerformance",
        "signature": "void testMessageDecodingPerformance()",
        "lines_hint_csv": [
          258,
          290
        ],
        "code": "    public void testMessageDecodingPerformance() throws Exception {\n\n        byte[] CONTENTS = new byte[MESSAGE_SIZE];\n        for (int i = 0; i < MESSAGE_SIZE; i++) {\n            CONTENTS[i] = 'a';\n        }\n\n        PUBLISH publish = new PUBLISH();\n\n        publish.dup(false);\n        publish.messageId((short) 127);\n        publish.qos(QoS.AT_LEAST_ONCE);\n        publish.payload(new Buffer(CONTENTS));\n        publish.topicName(new UTF8Buffer(\"TOPIC\"));\n\n        DataByteArrayOutputStream output = new DataByteArrayOutputStream();\n        wireFormat.marshal(publish.encode(), output);\n        Buffer marshalled = output.toBuffer();\n\n        long startTime = System.currentTimeMillis();\n\n        for (int i = 0; i < ITERATIONS; ++i) {\n            DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);\n            codec.parse(input, marshalled.length());\n\n            assertTrue(!frames.isEmpty());\n            publish = new PUBLISH().decode(frames.get(0));\n            frames.clear();\n        }\n\n        long duration = System.currentTimeMillis() - startTime;\n\n        LOG.info(\"Total time to process: {}\", TimeUnit.MILLISECONDS.toSeconds(duration));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          258,
          291
        ]
      },
      {
        "file_path": "activemq-mqtt/src/test/java/org/apache/activemq/transport/mqtt/MQTTCodecTest.java",
        "class_name": "MQTTCodecTest",
        "method_name": "testMessageDecodingPerformance",
        "signature": "void testMessageDecodingPerformance()",
        "lines_hint_csv": [
          258,
          290
        ],
        "code": "    public void testMessageDecodingPerformance() throws Exception {\n\n        byte[] CONTENTS = new byte[MESSAGE_SIZE];\n        for (int i = 0; i < MESSAGE_SIZE; i++) {\n            CONTENTS[i] = 'a';\n        }\n\n        PUBLISH publish = new PUBLISH();\n\n        publish.dup(false);\n        publish.messageId((short) 127);\n        publish.qos(QoS.AT_LEAST_ONCE);\n        publish.payload(new Buffer(CONTENTS));\n        publish.topicName(new UTF8Buffer(\"TOPIC\"));\n\n        DataByteArrayOutputStream output = new DataByteArrayOutputStream();\n        wireFormat.marshal(publish.encode(), output);\n        Buffer marshalled = output.toBuffer();\n\n        long startTime = System.currentTimeMillis();\n\n        for (int i = 0; i < ITERATIONS; ++i) {\n            DataByteArrayInputStream input = new DataByteArrayInputStream(marshalled);\n            codec.parse(input, marshalled.length());\n\n            assertTrue(!frames.isEmpty());\n            publish = new PUBLISH().decode(frames.get(0));\n            frames.clear();\n        }\n\n        long duration = System.currentTimeMillis() - startTime;\n\n        LOG.info(\"Total time to process: {}\", TimeUnit.MILLISECONDS.toSeconds(duration));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          258,
          291
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2021-41269",
    "project_slug": "jmrozanec__cron-utils_CVE-2021-41269_9.1.5",
    "buggy_commit_id": "34493c66edb490396202edad66c5f8cc5717d494",
    "github_url": "https://github.com/jmrozanec/cron-utils",
    "nvd_metadata": {
      "description": "cron-utils is a Java library to define, parse, validate, migrate crons as well as get human readable descriptions for them. In affected versions A template Injection was identified in cron-utils enabling attackers to inject arbitrary Java EL expressions, leading to unauthenticated Remote Code Execution (RCE) vulnerability. Versions up to 9.1.2 are susceptible to this vulnerability. Please note, that only projects using the @Cron annotation to validate untrusted Cron expressions are affected. The issue was patched and a new version was released. Please upgrade to version 9.1.6. There are no known workarounds known.",
      "published_date": "2021-11-15T21:15:07.393",
      "cvss_v3_score": 10.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/com/cronutils/parser/CronParser.java",
        "class_name": "CronParser",
        "method_name": "parse",
        "signature": "Cron parse(String)",
        "lines_hint_csv": [
          84,
          131
        ],
        "code": "    public Cron parse(final String expression) {\n        Preconditions.checkNotNull(expression, \"Expression must not be null\");\n        final String replaced = expression.replaceAll(\"\\\\s+\", \" \").trim();\n        if (StringUtils.isEmpty(replaced)) {\n            throw new IllegalArgumentException(\"Empty expression!\");\n        }\n\n        if(expression.contains(\"||\")) {\n            List<Cron> crons = Arrays.stream(expression.split(\"\\\\|\\\\|\")).map(this::parse).collect(Collectors.toList());\n            return new CompositeCron(crons);\n        }\n        if(expression.contains(\"|\")){\n            List<String> crons = new ArrayList<>();\n            int cronscount = Arrays.stream(expression.split(\"\\\\s+\")).mapToInt(s->s.split(\"\\\\|\").length).max().orElse(0);\n            for(int j=0; j<cronscount; j++){\n                StringBuilder builder = new StringBuilder();\n                for(String s : expression.split(\"\\\\s+\")){\n                    if(s.contains(\"|\")){\n                        builder.append(String.format(\"%s \", s.split(\"\\\\|\")[j]));\n                    }else{\n                        builder.append(String.format(\"%s \", s));\n                    }\n                }\n                crons.add(builder.toString().trim());\n            }\n            return new CompositeCron(crons.stream().map(this::parse).collect(Collectors.toList()));\n        }else{\n            final String[] expressionParts = replaced.toUpperCase().split(\" \");\n            final int expressionLength = expressionParts.length;\n            String fieldWithTrailingCommas = Arrays.stream(expressionParts).filter(x -> x.endsWith(\",\")).findAny().orElse(null);\n            if(fieldWithTrailingCommas!=null){\n                throw new IllegalArgumentException(String.format(\"Invalid field value! Trailing commas not permitted! '%s'\", fieldWithTrailingCommas));\n            }\n            final List<CronParserField> fields = expressions.get(expressionLength);\n            if (fields == null) {\n                throw new IllegalArgumentException(\n                        String.format(\"Cron expression contains %s parts but we expect one of %s\", expressionLength, expressions.keySet()));\n            }\n            try {\n\n                final int size = expressionParts.length;\n                final List<CronField> results = new ArrayList<>(size + 1);\n                for (int j = 0; j < size; j++) {\n                    results.add(fields.get(j).parse(expressionParts[j]));\n                }\n                return new SingleCron(cronDefinition, results).validate();\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(String.format(\"Failed to parse '%s'. %s\", expression, e.getMessage()), e);\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          84,
          134
        ]
      },
      {
        "file_path": "src/test/java/com/cronutils/Issue418Test.java",
        "class_name": "Issue418Test",
        "method_name": "testInvalidWeekDayStart",
        "signature": "void testInvalidWeekDayStart()",
        "lines_hint_csv": [
          55,
          62
        ],
        "code": "    public void testInvalidWeekDayStart() {\n        try {\n            final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n            final CronParser parser = new CronParser(cronDefinition);\n            parser.parse(\"0 0 2 ? * 0/7 *\");\n            fail(\"Expected exception for invalid expression\");\n        } catch (IllegalArgumentException expected) {\n            assertEquals(\"Failed to parse '0 0 2 ? * 0/7 *'. Value 0 not in range [1, 7]\", expected.getMessage());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          55,
          64
        ]
      },
      {
        "file_path": "src/test/java/com/cronutils/Issue418Test.java",
        "class_name": "Issue418Test",
        "method_name": "testInvalidWeekDayEnd",
        "signature": "void testInvalidWeekDayEnd()",
        "lines_hint_csv": [
          67,
          74
        ],
        "code": "    public void testInvalidWeekDayEnd() {\n        try {\n            final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n            final CronParser parser = new CronParser(cronDefinition);\n            parser.parse(\"0 0 2 ? * 1/8 *\");\n            fail(\"Expected exception for invalid expression\");\n        } catch (IllegalArgumentException expected) {\n            assertEquals(\"Failed to parse '0 0 2 ? * 1/8 *'. Period 8 not in range [1, 7]\", expected.getMessage());\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          67,
          76
        ]
      },
      {
        "file_path": "src/test/java/com/cronutils/parser/CronParserQuartzIntegrationTest.java",
        "class_name": "CronParserQuartzIntegrationTest",
        "method_name": "testMissingExpressionAndInvalidCharsInErrorMessage",
        "signature": "void testMissingExpressionAndInvalidCharsInErrorMessage()",
        "lines_hint_csv": [
          248,
          254
        ],
        "code": "    public void testMissingExpressionAndInvalidCharsInErrorMessage() {\n        thrown.expect(IllegalArgumentException.class);\n        final String cronexpression = \"* * -1 * * ?\";\n        thrown.expectMessage(\n                String.format(\"Failed to parse '%s'. Invalid expression! Expression: -1 does not describe a range. Negative numbers are not allowed.\",\n                        cronexpression));\n        assertNotNull(ExecutionTime.forCron(parser.parse(cronexpression)));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          248,
          255
        ]
      },
      {
        "file_path": "src/test/java/com/cronutils/validation/CronValidatorTest.java",
        "class_name": "CronValidatorTest",
        "method_name": "CronValidatorTest",
        "signature": "CronValidatorTest(String,boolean)",
        "lines_hint_csv": [
          24,
          26
        ],
        "code": "    public CronValidatorTest(String expression, boolean valid) {\n        this.expression = expression;\n        this.valid = valid;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          24,
          27
        ]
      },
      {
        "file_path": "src/main/java/com/cronutils/validation/CronValidator.java",
        "class_name": "CronValidator",
        "method_name": "isValid",
        "signature": "boolean isValid(String,ConstraintValidatorContext)",
        "lines_hint_csv": [
          21,
          34
        ],
        "code": "    public boolean isValid(String value, ConstraintValidatorContext context) {\n        if (value == null) {\n            return true;\n        }\n\n        CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(type);\n        CronParser cronParser = new CronParser(cronDefinition);\n        try {\n            cronParser.parse(value).validate();\n            return true;\n        } catch (IllegalArgumentException e) {\n            context.disableDefaultConstraintViolation();\n            context.buildConstraintViolationWithTemplate(e.getMessage()).addConstraintViolation();\n            return false;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          21,
          36
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-17530",
    "project_slug": "apache__struts_CVE-2020-17530_2.5.25",
    "buggy_commit_id": "b3a9d82d5830ef9cd7811cfa3f86a373ae52fada",
    "github_url": "https://github.com/apache/struts",
    "nvd_metadata": {
      "description": "Forced OGNL evaluation, when evaluated on raw user input in tag attributes, may lead to remote code execution. Affected software : Apache Struts 2.0.0 - Struts 2.5.25.",
      "published_date": "2020-12-11T02:15:10.883",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "core/src/main/java/com/opensymphony/xwork2/interceptor/StaticParametersInterceptor.java",
        "class_name": "StaticParametersInterceptor",
        "method_name": "addParametersToContext",
        "signature": "void addParametersToContext(ActionContext,Map)",
        "lines_hint_csv": [
          227,
          246
        ],
        "code": "    protected void addParametersToContext(ActionContext ac, Map<String, ?> newParams) {\n        HttpParameters previousParams = ac.getParameters();\n\n        HttpParameters.Builder combinedParams = HttpParameters.create();\n        if (overwrite) {\n            if (previousParams != null) {\n                combinedParams = combinedParams.withParent(previousParams);\n            }\n            if (newParams != null) {\n                combinedParams = combinedParams.withExtraParams(newParams);\n            }\n        } else {\n            if (newParams != null) {\n                combinedParams = combinedParams.withExtraParams(newParams);\n            }\n            if (previousParams != null) {\n                combinedParams = combinedParams.withParent(previousParams);\n            }\n        }\n        ac.setParameters(combinedParams.build());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          227,
          247
        ]
      },
      {
        "file_path": "core/src/main/java/org/apache/struts2/dispatcher/HttpParameters.java",
        "class_name": "Builder",
        "method_name": "build",
        "signature": "HttpParameters build()",
        "lines_hint_csv": [
          187,
          198
        ],
        "code": "        public HttpParameters build() {\n            Map<String, Parameter> parameters = (parent == null)\n                    ? new HashMap<String, Parameter>()\n                    : new HashMap<>(parent.parameters);\n\n            for (Map.Entry<String, Object> entry : requestParameterMap.entrySet()) {\n                String name = entry.getKey();\n                Object value = entry.getValue();\n                parameters.put(name, new Parameter.Request(name, value));\n            }\n\n            return new HttpParameters(parameters);\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          187,
          199
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2020-11998",
    "project_slug": "apache__activemq_CVE-2020-11998_5.15.12",
    "buggy_commit_id": "cebbd7fdea0633e6a0cbbef427f9b753949fa531",
    "github_url": "https://github.com/apache/activemq",
    "nvd_metadata": {
      "description": "A regression has been introduced in the commit preventing JMX re-bind. By passing an empty environment map to RMIConnectorServer, instead of the map that contains the authentication credentials, it leaves ActiveMQ open to the following attack: https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html \"A remote client could create a javax.management.loading.MLet MBean and use it to create new MBeans from arbitrary URLs, at least if there is no security manager. In other words, a rogue remote client could make your Java application execute arbitrary code.\" Mitigation: Upgrade to Apache ActiveMQ 5.15.13",
      "published_date": "2020-09-10T19:15:13.083",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "activemq-broker/src/main/java/org/apache/activemq/broker/jmx/ManagementContext.java",
        "class_name": "ManagementContext",
        "method_name": "createConnector",
        "signature": "void createConnector(MBeanServer)",
        "lines_hint_csv": [
          559,
          597
        ],
        "code": "    private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {\n        // Create the NamingService, needed by JSR 160\n        try {\n            if (registry == null) {\n                LOG.debug(\"Creating RMIRegistry on port {}\", connectorPort);\n                registry = new JmxRegistry(connectorPort);\n            }\n\n            namingServiceObjectName = ObjectName.getInstance(\"naming:type=rmiregistry\");\n\n            // Do not use the createMBean as the mx4j jar may not be in the\n            // same class loader than the server\n            Class<?> cl = Class.forName(\"mx4j.tools.naming.NamingService\");\n            mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);\n\n            // set the naming port\n            Attribute attr = new Attribute(\"Port\", Integer.valueOf(connectorPort));\n            mbeanServer.setAttribute(namingServiceObjectName, attr);\n        } catch(ClassNotFoundException e) {\n            LOG.debug(\"Probably not using JRE 1.4: {}\", e.getLocalizedMessage());\n        } catch (Throwable e) {\n            LOG.debug(\"Failed to create local registry. This exception will be ignored.\", e);\n        }\n\n        // Create the JMXConnectorServer\n        String rmiServer = \"\";\n        if (rmiServerPort != 0) {\n            // This is handy to use if you have a firewall and need to force JMX to use fixed ports.\n            rmiServer = \"\"+getConnectorHost()+\":\" + rmiServerPort;\n        }\n\n        final Map<String,Object> env = new HashMap<>();\n        server = new RMIJRMPServerImpl(connectorPort, null, null, environment);\n\n        final String serviceURL = \"service:jmx:rmi://\" + rmiServer + \"/jndi/rmi://\" +getConnectorHost()+\":\" + connectorPort + connectorPath;\n        final JMXServiceURL url = new JMXServiceURL(serviceURL);\n\n        connectorServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n        LOG.debug(\"Created JMXConnectorServer {}\", connectorServer);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          559,
          598
        ]
      },
      {
        "file_path": "activemq-broker/src/main/java/org/apache/activemq/broker/jmx/ManagementContext.java",
        "class_name": "ManagementContext",
        "method_name": "createConnector",
        "signature": "void createConnector(MBeanServer)",
        "lines_hint_csv": [
          559,
          597
        ],
        "code": "    private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {\n        // Create the NamingService, needed by JSR 160\n        try {\n            if (registry == null) {\n                LOG.debug(\"Creating RMIRegistry on port {}\", connectorPort);\n                registry = new JmxRegistry(connectorPort);\n            }\n\n            namingServiceObjectName = ObjectName.getInstance(\"naming:type=rmiregistry\");\n\n            // Do not use the createMBean as the mx4j jar may not be in the\n            // same class loader than the server\n            Class<?> cl = Class.forName(\"mx4j.tools.naming.NamingService\");\n            mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);\n\n            // set the naming port\n            Attribute attr = new Attribute(\"Port\", Integer.valueOf(connectorPort));\n            mbeanServer.setAttribute(namingServiceObjectName, attr);\n        } catch(ClassNotFoundException e) {\n            LOG.debug(\"Probably not using JRE 1.4: {}\", e.getLocalizedMessage());\n        } catch (Throwable e) {\n            LOG.debug(\"Failed to create local registry. This exception will be ignored.\", e);\n        }\n\n        // Create the JMXConnectorServer\n        String rmiServer = \"\";\n        if (rmiServerPort != 0) {\n            // This is handy to use if you have a firewall and need to force JMX to use fixed ports.\n            rmiServer = \"\"+getConnectorHost()+\":\" + rmiServerPort;\n        }\n\n        final Map<String,Object> env = new HashMap<>();\n        server = new RMIJRMPServerImpl(connectorPort, null, null, environment);\n\n        final String serviceURL = \"service:jmx:rmi://\" + rmiServer + \"/jndi/rmi://\" +getConnectorHost()+\":\" + connectorPort + connectorPath;\n        final JMXServiceURL url = new JMXServiceURL(serviceURL);\n\n        connectorServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n        LOG.debug(\"Created JMXConnectorServer {}\", connectorServer);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          559,
          598
        ]
      },
      {
        "file_path": "activemq-broker/src/main/java/org/apache/activemq/broker/jmx/ManagementContext.java",
        "class_name": "ManagementContext",
        "method_name": "createConnector",
        "signature": "void createConnector(MBeanServer)",
        "lines_hint_csv": [
          559,
          597
        ],
        "code": "    private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {\n        // Create the NamingService, needed by JSR 160\n        try {\n            if (registry == null) {\n                LOG.debug(\"Creating RMIRegistry on port {}\", connectorPort);\n                registry = new JmxRegistry(connectorPort);\n            }\n\n            namingServiceObjectName = ObjectName.getInstance(\"naming:type=rmiregistry\");\n\n            // Do not use the createMBean as the mx4j jar may not be in the\n            // same class loader than the server\n            Class<?> cl = Class.forName(\"mx4j.tools.naming.NamingService\");\n            mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);\n\n            // set the naming port\n            Attribute attr = new Attribute(\"Port\", Integer.valueOf(connectorPort));\n            mbeanServer.setAttribute(namingServiceObjectName, attr);\n        } catch(ClassNotFoundException e) {\n            LOG.debug(\"Probably not using JRE 1.4: {}\", e.getLocalizedMessage());\n        } catch (Throwable e) {\n            LOG.debug(\"Failed to create local registry. This exception will be ignored.\", e);\n        }\n\n        // Create the JMXConnectorServer\n        String rmiServer = \"\";\n        if (rmiServerPort != 0) {\n            // This is handy to use if you have a firewall and need to force JMX to use fixed ports.\n            rmiServer = \"\"+getConnectorHost()+\":\" + rmiServerPort;\n        }\n\n        final Map<String,Object> env = new HashMap<>();\n        server = new RMIJRMPServerImpl(connectorPort, null, null, environment);\n\n        final String serviceURL = \"service:jmx:rmi://\" + rmiServer + \"/jndi/rmi://\" +getConnectorHost()+\":\" + connectorPort + connectorPath;\n        final JMXServiceURL url = new JMXServiceURL(serviceURL);\n\n        connectorServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n        LOG.debug(\"Created JMXConnectorServer {}\", connectorServer);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          559,
          598
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-22965",
    "project_slug": "spring-projects__spring-framework_CVE-2022-22965_5.2.19.RELEASE",
    "buggy_commit_id": "925b07826067d57a8a057837a1b5973cb6fad186",
    "github_url": "https://github.com/spring-projects/spring-framework",
    "nvd_metadata": {
      "description": "A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE) via data binding. The specific exploit requires the application to run on Tomcat as a WAR deployment. If the application is deployed as a Spring Boot executable jar, i.e. the default, it is not vulnerable to the exploit. However, the nature of the vulnerability is more general, and there may be other ways to exploit it.",
      "published_date": "2022-04-01T23:15:13.870",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java",
        "class_name": "CachedIntrospectionResults",
        "method_name": "CachedIntrospectionResults",
        "signature": "CachedIntrospectionResults(Class)",
        "lines_hint_csv": [
          272,
          324
        ],
        "code": "\tprivate CachedIntrospectionResults(Class<?> beanClass) throws BeansException {\n\t\ttry {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Getting BeanInfo for class [\" + beanClass.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.beanInfo = getBeanInfo(beanClass);\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Caching PropertyDescriptors for class [\" + beanClass.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.propertyDescriptors = new LinkedHashMap<>();\n\n\t\t\t// This call is slow so we do it once.\n\t\t\tPropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();\n\t\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\t\tif (Class.class == beanClass &&\n\t\t\t\t\t\t(\"classLoader\".equals(pd.getName()) ||  \"protectionDomain\".equals(pd.getName()))) {\n\t\t\t\t\t// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Found bean property '\" + pd.getName() + \"'\" +\n\t\t\t\t\t\t\t(pd.getPropertyType() != null ? \" of type [\" + pd.getPropertyType().getName() + \"]\" : \"\") +\n\t\t\t\t\t\t\t(pd.getPropertyEditorClass() != null ?\n\t\t\t\t\t\t\t\t\t\"; editor [\" + pd.getPropertyEditorClass().getName() + \"]\" : \"\"));\n\t\t\t\t}\n\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\tthis.propertyDescriptors.put(pd.getName(), pd);\n\t\t\t}\n\n\t\t\t// Explicitly check implemented interfaces for setter/getter methods as well,\n\t\t\t// in particular for Java 8 default methods...\n\t\t\tClass<?> currClass = beanClass;\n\t\t\twhile (currClass != null && currClass != Object.class) {\n\t\t\t\tintrospectInterfaces(beanClass, currClass);\n\t\t\t\tcurrClass = currClass.getSuperclass();\n\t\t\t}\n\n\t\t\tthis.typeDescriptorCache = new ConcurrentReferenceHashMap<>();\n\t\t}\n\t\tcatch (IntrospectionException ex) {\n\t\t\tthrow new FatalBeanException(\"Failed to obtain BeanInfo for class [\" + beanClass.getName() + \"]\", ex);\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          269,
          312
        ]
      },
      {
        "file_path": "spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java",
        "class_name": "CachedIntrospectionResults",
        "method_name": "introspectInterfaces",
        "signature": "void introspectInterfaces(Class,Class,Set)",
        "lines_hint_csv": [
          328,
          347
        ],
        "code": "\tprivate void introspectInterfaces(Class<?> beanClass, Class<?> currClass) throws IntrospectionException {\n\t\tfor (Class<?> ifc : currClass.getInterfaces()) {\n\t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n\t\t\t\tfor (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {\n\t\t\t\t\tPropertyDescriptor existingPd = this.propertyDescriptors.get(pd.getName());\n\t\t\t\t\tif (existingPd == null ||\n\t\t\t\t\t\t\t(existingPd.getReadMethod() == null && pd.getReadMethod() != null)) {\n\t\t\t\t\t\t// GenericTypeAwarePropertyDescriptor leniently resolves a set* write method\n\t\t\t\t\t\t// against a declared read method, so we prefer read method descriptors here.\n\t\t\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\t\t\tthis.propertyDescriptors.put(pd.getName(), pd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tintrospectInterfaces(ifc, ifc);\n\t\t\t}\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          314,
          330
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-22947",
    "project_slug": "spring-cloud__spring-cloud-gateway_CVE-2022-22947_3.0.6",
    "buggy_commit_id": "da0f9014bcc9131d8f15141be74011b89a01420f",
    "github_url": "https://github.com/spring-cloud/spring-cloud-gateway",
    "nvd_metadata": {
      "description": "In spring cloud gateway versions prior to 3.1.1+ and 3.0.7+ , applications are vulnerable to a code injection attack when the Gateway Actuator endpoint is enabled, exposed and unsecured. A remote attacker could make a maliciously crafted request that could allow arbitrary remote execution on the remote host.",
      "published_date": "2022-03-03T22:15:08.673",
      "cvss_v3_score": 10.0,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/support/ShortcutConfigurable.java",
        "class_name": "GatewayEvaluationContext",
        "method_name": "getConstructorResolvers",
        "signature": "List getConstructorResolvers()",
        "lines_hint_csv": [
          182,
          183
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/support/ShortcutConfigurable.java",
        "class_name": "ShortcutConfigurable",
        "method_name": "getValue",
        "signature": "Object getValue(SpelExpressionParser parser, BeanFactory beanFactory, String entryValue)",
        "lines_hint_csv": [
          182,
          183
        ],
        "code": "\tstatic Object getValue(SpelExpressionParser parser, BeanFactory beanFactory, String entryValue) {\n\t\tObject value;\n\t\tString rawValue = entryValue;\n\t\tif (rawValue != null) {\n\t\t\trawValue = rawValue.trim();\n\t\t}\n\t\tif (rawValue != null && rawValue.startsWith(\"#{\") && entryValue.endsWith(\"}\")) {\n\t\t\t// assume it's spel\n\t\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\t\t\tcontext.setBeanResolver(new BeanFactoryResolver(beanFactory));\n\t\t\tExpression expression = parser.parseExpression(entryValue, new TemplateParserContext());\n\t\t\tvalue = expression.getValue(context);\n\t\t}\n\t\telse {\n\t\t\tvalue = entryValue;\n\t\t}\n\t\treturn value;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          49,
          66
        ]
      },
      {
        "file_path": "spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/support/ShortcutConfigurableTests.java",
        "class_name": "ShortcutConfigurableTests",
        "method_name": "testNormalizeDefaultTypeWithSpel",
        "signature": "void testNormalizeDefaultTypeWithSpel()",
        "lines_hint_csv": [
          67,
          79
        ],
        "code": "\tpublic void testNormalizeDefaultTypeWithSpel() {\n\t\tparser = new SpelExpressionParser();\n\t\tShortcutConfigurable shortcutConfigurable = new ShortcutConfigurable() {\n\t\t\t@Override\n\t\t\tpublic List<String> shortcutFieldOrder() {\n\t\t\t\treturn Arrays.asList(\"bean\", \"arg1\");\n\t\t\t}\n\t\t};\n\t\tMap<String, String> args = new HashMap<>();\n\t\targs.put(\"bean\", \"#{@foo}\");\n\t\targs.put(\"arg1\", \"val1\");\n\t\tMap<String, Object> map = ShortcutType.DEFAULT.normalize(args, shortcutConfigurable, parser, this.beanFactory);\n\t\tassertThat(map).isNotNull().containsEntry(\"bean\", 42).containsEntry(\"arg1\", \"val1\");\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          48,
          61
        ]
      },
      {
        "file_path": "spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/support/ShortcutConfigurableTests.java",
        "class_name": "ShortcutConfigurableTests",
        "method_name": "testNormalizeDefaultTypeWithSpelAndInvalidInputFails",
        "signature": "void testNormalizeDefaultTypeWithSpelAndInvalidInputFails()",
        "lines_hint_csv": [
          50,
          63
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/support/ShortcutConfigurableTests.java",
        "class_name": "ShortcutConfigurableTests",
        "method_name": "testNormalizeGatherListTailFlagFlagExists",
        "signature": "void testNormalizeGatherListTailFlagFlagExists()",
        "lines_hint_csv": [
          108,
          109
        ],
        "code": "\tpublic void testNormalizeGatherListTailFlagFlagExists() {\n\t\tassertListTailFlag(true);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          89,
          91
        ]
      },
      {
        "file_path": "spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/support/ShortcutConfigurableTests.java",
        "class_name": "ShortcutConfigurableTests",
        "method_name": "assertListTailFlag",
        "signature": "void assertListTailFlag(boolean)",
        "lines_hint_csv": [
          118,
          146
        ],
        "code": "\tprivate void assertListTailFlag(boolean hasTailFlag) {\n\t\tparser = new SpelExpressionParser();\n\t\tShortcutConfigurable shortcutConfigurable = new ShortcutConfigurable() {\n\t\t\t@Override\n\t\t\tpublic List<String> shortcutFieldOrder() {\n\t\t\t\treturn Arrays.asList(\"values\", \"flag\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ShortcutType shortcutType() {\n\t\t\t\treturn ShortcutType.GATHER_LIST_TAIL_FLAG;\n\t\t\t}\n\t\t};\n\t\tMap<String, String> args = new HashMap<>();\n\t\targs.put(\"1\", \"val0\");\n\t\targs.put(\"2\", \"val1\");\n\t\targs.put(\"3\", \"val2\");\n\t\tif (hasTailFlag) {\n\t\t\targs.put(\"4\", \"false\");\n\t\t}\n\t\tMap<String, Object> map = ShortcutType.GATHER_LIST_TAIL_FLAG.normalize(args, shortcutConfigurable, parser,\n\t\t\t\tthis.beanFactory);\n\t\tassertThat(map).isNotNull().containsKey(\"values\");\n\t\tassertThat((List) map.get(\"values\")).containsExactly(\"val0\", \"val1\", \"val2\");\n\t\tif (hasTailFlag) {\n\t\t\tassertThat(map.get(\"flag\")).isEqualTo(\"false\");\n\t\t}\n\t\telse {\n\t\t\tassertThat(map).doesNotContainKeys(\"flag\");\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          99,
          129
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2021-30180",
    "project_slug": "apache__dubbo_CVE-2021-30180_2.7.9",
    "buggy_commit_id": "f0483b80a32e813a4393879744e30d0084c3eafd",
    "github_url": "https://github.com/apache/dubbo",
    "nvd_metadata": {
      "description": "Apache Dubbo prior to 2.7.9 support Tag routing which will enable a customer to route the request to the right server. These rules are used by the customers when making a request in order to find the right endpoint. When parsing these YAML rules, Dubbo customers may enable calling arbitrary constructors.",
      "published_date": "2021-06-01T14:15:09.937",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParser.java",
        "class_name": "ConfigParser",
        "method_name": "parseObject",
        "signature": "T parseObject(String)",
        "lines_hint_csv": [
          75,
          82
        ],
        "code": "    private static <T> T parseObject(String rawConfig) {\n        Constructor constructor = new Constructor(ConfiguratorConfig.class);\n        TypeDescription itemDescription = new TypeDescription(ConfiguratorConfig.class);\n        itemDescription.addPropertyParameters(\"items\", ConfigItem.class);\n        constructor.addTypeDescription(itemDescription);\n\n        Yaml yaml = new Yaml(constructor);\n        return yaml.load(rawConfig);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          75,
          83
        ]
      },
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParser.java",
        "class_name": "ConfigParser",
        "method_name": "parseConfigurators",
        "signature": "List parseConfigurators(String)",
        "lines_hint_csv": [
          45,
          63
        ],
        "code": "    public static List<URL> parseConfigurators(String rawConfig) {\n        // compatible url JsonArray, such as [ \"override://xxx\", \"override://xxx\" ]\n        if (isJsonArray(rawConfig)) {\n            return parseJsonArray(rawConfig);\n        }\n\n        List<URL> urls = new ArrayList<>();\n        ConfiguratorConfig configuratorConfig = parseObject(rawConfig);\n\n        String scope = configuratorConfig.getScope();\n        List<ConfigItem> items = configuratorConfig.getConfigs();\n\n        if (ConfiguratorConfig.SCOPE_APPLICATION.equals(scope)) {\n            items.forEach(item -> urls.addAll(appItemToUrls(item, configuratorConfig)));\n        } else {\n            // service scope by default.\n            items.forEach(item -> urls.addAll(serviceItemToUrls(item, configuratorConfig)));\n        }\n        return urls;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          45,
          64
        ]
      },
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParser.java",
        "class_name": "ConfigParser",
        "method_name": "parseJsonArray",
        "signature": "List parseJsonArray(String)",
        "lines_hint_csv": [
          66,
          72
        ],
        "code": "    private static List<URL> parseJsonArray(String rawConfig) {\n        List<URL> urls = new ArrayList<>();\n        List<String> list = JSON.parseArray(rawConfig, String.class);\n        if (!CollectionUtils.isEmpty(list)) {\n            list.forEach(u -> urls.add(URL.valueOf(u)));\n        }\n        return urls;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          66,
          73
        ]
      },
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/condition/config/model/ConditionRuleParser.java",
        "class_name": "ConditionRuleParser",
        "method_name": "parse",
        "signature": "ConditionRouterRule parse(String)",
        "lines_hint_csv": [
          40,
          50
        ],
        "code": "    public static ConditionRouterRule parse(String rawRule) {\n        Constructor constructor = new Constructor(ConditionRouterRule.class);\n\n        Yaml yaml = new Yaml(constructor);\n        ConditionRouterRule rule = yaml.load(rawRule);\n        rule.setRawRule(rawRule);\n        if (CollectionUtils.isEmpty(rule.getConditions())) {\n            rule.setValid(false);\n        }\n\n        return rule;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          40,
          51
        ]
      },
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRuleParser.java",
        "class_name": "TagRuleParser",
        "method_name": "parse",
        "signature": "TagRouterRule parse(String)",
        "lines_hint_csv": [
          29,
          43
        ],
        "code": "    public static TagRouterRule parse(String rawRule) {\n        Constructor constructor = new Constructor(TagRouterRule.class);\n        TypeDescription tagDescription = new TypeDescription(TagRouterRule.class);\n        tagDescription.addPropertyParameters(\"tags\", Tag.class);\n        constructor.addTypeDescription(tagDescription);\n\n        Yaml yaml = new Yaml(constructor);\n        TagRouterRule rule = yaml.load(rawRule);\n        rule.setRawRule(rawRule);\n        if (CollectionUtils.isEmpty(rule.getTags())) {\n            rule.setValid(false);\n        }\n\n        rule.init();\n        return rule;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          29,
          44
        ]
      },
      {
        "file_path": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java",
        "class_name": "ConfigParserTest",
        "method_name": "parseConsumerSpecificProvidersTest",
        "signature": "void parseConsumerSpecificProvidersTest()",
        "lines_hint_csv": [
          162,
          173
        ],
        "code": "    public void parseConsumerSpecificProvidersTest() throws IOException {\n        try (InputStream yamlStream = this.getClass().getResourceAsStream(\"/ConsumerSpecificProviders.yml\")) {\n            List<URL> urls = ConfigParser.parseConfigurators(streamToString(yamlStream));\n            Assertions.assertNotNull(urls);\n            Assertions.assertEquals(1, urls.size());\n            URL url = urls.get(0);\n            Assertions.assertEquals(\"127.0.0.1\", url.getAddress());\n            Assertions.assertEquals(\"*\", url.getServiceInterface());\n            Assertions.assertEquals(6666, url.getParameter(TIMEOUT_KEY, 0));\n            Assertions.assertEquals(\"random\", url.getParameter(LOADBALANCE_KEY));\n            Assertions.assertEquals(\"127.0.0.1:20880\", url.getParameter(OVERRIDE_PROVIDERS_KEY));\n            Assertions.assertEquals(url.getParameter(APPLICATION_KEY), \"demo-consumer\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          162,
          175
        ]
      },
      {
        "file_path": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java",
        "class_name": "ConfigParserTest",
        "method_name": "parseConfiguratorsServiceMultiAppsTest",
        "signature": "void parseConfiguratorsServiceMultiAppsTest()",
        "lines_hint_csv": [
          92,
          100
        ],
        "code": "    public void parseConfiguratorsServiceMultiAppsTest() throws IOException {\n        try (InputStream yamlStream = this.getClass().getResourceAsStream(\"/ServiceMultiApps.yml\")) {\n            List<URL> urls = ConfigParser.parseConfigurators(streamToString(yamlStream));\n            Assertions.assertNotNull(urls);\n            Assertions.assertEquals(4, urls.size());\n            URL url = urls.get(0);\n            Assertions.assertEquals(\"127.0.0.1\", url.getAddress());\n            Assertions.assertEquals(6666, url.getParameter(TIMEOUT_KEY, 0));\n            Assertions.assertNotNull(url.getParameter(APPLICATION_KEY));\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          92,
          102
        ]
      },
      {
        "file_path": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java",
        "class_name": "ConfigParserTest",
        "method_name": "parseConfiguratorsAppAnyServicesTest",
        "signature": "void parseConfiguratorsAppAnyServicesTest()",
        "lines_hint_csv": [
          132,
          142
        ],
        "code": "    public void parseConfiguratorsAppAnyServicesTest() throws IOException {\n        try (InputStream yamlStream = this.getClass().getResourceAsStream(\"/AppAnyServices.yml\")) {\n            List<URL> urls = ConfigParser.parseConfigurators(streamToString(yamlStream));\n            Assertions.assertNotNull(urls);\n            Assertions.assertEquals(2, urls.size());\n            URL url = urls.get(0);\n            Assertions.assertEquals(\"127.0.0.1\", url.getAddress());\n            Assertions.assertEquals(\"*\", url.getServiceInterface());\n            Assertions.assertEquals(6666, url.getParameter(TIMEOUT_KEY, 0));\n            Assertions.assertEquals(\"random\", url.getParameter(LOADBALANCE_KEY));\n            Assertions.assertEquals(url.getParameter(APPLICATION_KEY), \"demo-consumer\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          132,
          144
        ]
      },
      {
        "file_path": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java",
        "class_name": "ConfigParserTest",
        "method_name": "parseConfiguratorsAppMultiServicesTest",
        "signature": "void parseConfiguratorsAppMultiServicesTest()",
        "lines_hint_csv": [
          115,
          126
        ],
        "code": "    public void parseConfiguratorsAppMultiServicesTest() throws IOException {\n        try (InputStream yamlStream = this.getClass().getResourceAsStream(\"/AppMultiServices.yml\")) {\n            String yamlFile = streamToString(yamlStream);\n            List<URL> urls = ConfigParser.parseConfigurators(yamlFile);\n            Assertions.assertNotNull(urls);\n            Assertions.assertEquals(4, urls.size());\n            URL url = urls.get(0);\n            Assertions.assertEquals(\"127.0.0.1\", url.getAddress());\n            Assertions.assertEquals(\"service1\", url.getServiceInterface());\n            Assertions.assertEquals(6666, url.getParameter(TIMEOUT_KEY, 0));\n            Assertions.assertEquals(\"random\", url.getParameter(LOADBALANCE_KEY));\n            Assertions.assertEquals(url.getParameter(APPLICATION_KEY), \"demo-consumer\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          115,
          128
        ]
      },
      {
        "file_path": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java",
        "class_name": "ConfigParserTest",
        "method_name": "parseConfiguratorsAppNoServiceTest",
        "signature": "void parseConfiguratorsAppNoServiceTest()",
        "lines_hint_csv": [
          147,
          157
        ],
        "code": "    public void parseConfiguratorsAppNoServiceTest() throws IOException {\n        try (InputStream yamlStream = this.getClass().getResourceAsStream(\"/AppNoService.yml\")) {\n            List<URL> urls = ConfigParser.parseConfigurators(streamToString(yamlStream));\n            Assertions.assertNotNull(urls);\n            Assertions.assertEquals(1, urls.size());\n            URL url = urls.get(0);\n            Assertions.assertEquals(\"127.0.0.1\", url.getAddress());\n            Assertions.assertEquals(\"*\", url.getServiceInterface());\n            Assertions.assertEquals(6666, url.getParameter(TIMEOUT_KEY, 0));\n            Assertions.assertEquals(\"random\", url.getParameter(LOADBALANCE_KEY));\n            Assertions.assertEquals(url.getParameter(APPLICATION_KEY), \"demo-consumer\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          147,
          159
        ]
      },
      {
        "file_path": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParserTest.java",
        "class_name": "ConfigParserTest",
        "method_name": "parseURLJsonArrayCompatible",
        "signature": "void parseURLJsonArrayCompatible()",
        "lines_hint_csv": [
          178,
          190
        ],
        "code": "    public void parseURLJsonArrayCompatible() {\n\n        String configData = \"[\\\"override://0.0.0.0/com.xx.Service?category=configurators&timeout=6666&disabled=true&dynamic=false&enabled=true&group=dubbo&priority=1&version=1.0\\\" ]\";\n\n        List<URL> urls = ConfigParser.parseConfigurators(configData);\n\n        Assertions.assertNotNull(urls);\n        Assertions.assertEquals(1, urls.size());\n        URL url = urls.get(0);\n\n        Assertions.assertEquals(\"0.0.0.0\", url.getAddress());\n        Assertions.assertEquals(\"com.xx.Service\", url.getServiceInterface());\n        Assertions.assertEquals(6666, url.getParameter(TIMEOUT_KEY, 0));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          178,
          191
        ]
      },
      {
        "file_path": "dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/TagRouterTest.java",
        "class_name": "TagRouterTest",
        "method_name": "tagRouterRuleParseTest",
        "signature": "void tagRouterRuleParseTest()",
        "lines_hint_csv": [
          79,
          110
        ],
        "code": "    public void tagRouterRuleParseTest(){\n        String tagRouterRuleConfig = \"---\\n\" +\n                \"force: false\\n\" +\n                \"runtime: true\\n\" +\n                \"enabled: false\\n\" +\n                \"priority: 1\\n\" +\n                \"key: demo-provider\\n\" +\n                \"tags:\\n\" +\n                \"  - name: tag1\\n\" +\n                \"    addresses: null\\n\" +\n                \"  - name: tag2\\n\" +\n                \"    addresses: [\\\"30.5.120.37:20880\\\"]\\n\" +\n                \"  - name: tag3\\n\" +\n                \"    addresses: []\\n\" +\n                \"  - name: tag4\\n\" +\n                \"    addresses: ~\\n\" +\n                \"...\";\n\n        TagRouterRule tagRouterRule = TagRuleParser.parse(tagRouterRuleConfig);\n\n        // assert tags\n        assert tagRouterRule.getTagNames().contains(\"tag1\");\n        assert tagRouterRule.getTagNames().contains(\"tag2\");\n        assert tagRouterRule.getTagNames().contains(\"tag3\");\n        assert tagRouterRule.getTagNames().contains(\"tag4\");\n        // assert addresses\n        assert tagRouterRule.getAddresses().contains(\"30.5.120.37:20880\");\n        assert tagRouterRule.getTagnameToAddresses().get(\"tag1\")==null;\n        assert tagRouterRule.getTagnameToAddresses().get(\"tag2\").size()==1;\n        assert tagRouterRule.getTagnameToAddresses().get(\"tag3\")==null;\n        assert tagRouterRule.getTagnameToAddresses().get(\"tag4\")==null;\n        assert tagRouterRule.getAddresses().size()==1;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          79,
          111
        ]
      },
      {
        "file_path": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java",
        "class_name": "PojoUtils",
        "method_name": "realize",
        "signature": "Object realize(Object,Class)",
        "lines_hint_csv": [
          80,
          90
        ],
        "code": "    public static Object[] realize(Object[] objs, Class<?>[] types) {\r\n        if (objs.length != types.length) {\r\n            throw new IllegalArgumentException(\"args.length != types.length\");\r\n        }\r\n\r\n        Object[] dests = new Object[objs.length];\r\n        for (int i = 0; i < objs.length; i++) {\r\n            dests[i] = realize(objs[i], types[i]);\r\n        }\r\n\r\n        return dests;\r\n    }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          80,
          91
        ]
      },
      {
        "file_path": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java",
        "class_name": "PojoUtils",
        "method_name": "generalize",
        "signature": "Object generalize(Object)",
        "lines_hint_csv": [
          72,
          77
        ],
        "code": "    public static Object[] generalize(Object[] objs) {\r\n        Object[] dests = new Object[objs.length];\r\n        for (int i = 0; i < objs.length; i++) {\r\n            dests[i] = generalize(objs[i]);\r\n        }\r\n        return dests;\r\n    }\r\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          72,
          78
        ]
      },
      {
        "file_path": "dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java",
        "class_name": "PojoUtilsTest",
        "method_name": "testRealizeCollectionWithNullElement",
        "signature": "void testRealizeCollectionWithNullElement()",
        "lines_hint_csv": [
          746,
          760
        ],
        "code": "    public void testRealizeCollectionWithNullElement() {\n        LinkedList<String> listStr = new LinkedList<>();\n        listStr.add(\"arrayValue\");\n        listStr.add(null);\n        HashSet<String> setStr = new HashSet<>();\n        setStr.add(\"setValue\");\n        setStr.add(null);\n\n        Object listResult = PojoUtils.realize(listStr, LinkedList.class);\n        assertEquals(LinkedList.class, listResult.getClass());\n        assertEquals(listResult, listStr);\n\n        Object setResult = PojoUtils.realize(setStr, HashSet.class);\n        assertEquals(HashSet.class, setResult.getClass());\n        assertEquals(setResult, setStr);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          741,
          756
        ]
      },
      {
        "file_path": "dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java",
        "class_name": "TestData",
        "method_name": "setList",
        "signature": "void setList(List)",
        "lines_hint_csv": [
          932,
          934
        ],
        "code": "        public void setList(List<Child> list) {\n            if (CollectionUtils.isNotEmpty(list)) {\n                this.list.addAll(list);\n            }\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          927,
          931
        ]
      },
      {
        "file_path": "dubbo-common/src/test/java/org/apache/dubbo/common/utils/PojoUtilsTest.java",
        "class_name": "BasicTestData",
        "method_name": "hashCode",
        "signature": "int hashCode()",
        "lines_hint_csv": [
          790,
          801
        ],
        "code": "        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + (a ? 1 : 2);\n            result = prime * result + b;\n            result = prime * result + c;\n            result = prime * result + c;\n            result = prime * result + e;\n            result = (int) (prime * result + f);\n            result = (int) (prime * result + g);\n            result = (int) (prime * result + h);\n            return result;\n        }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          785,
          797
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2021-30181",
    "project_slug": "apache__incubator-dubbo_CVE-2021-30181_2.6.8",
    "buggy_commit_id": "5a6a069986f3627f2d50720c50024df31a3dc38a",
    "github_url": "https://github.com/apache/dubbo",
    "nvd_metadata": {
      "description": "Apache Dubbo prior to 2.6.9 and 2.7.9 supports Script routing which will enable a customer to route the request to the right server. These rules are used by the customers when making a request in order to find the right endpoint. When parsing these rules, Dubbo customers use ScriptEngine and run the rule provided by the script which by default may enable executing arbitrary code.",
      "published_date": "2021-06-01T14:15:09.967",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouter.java",
        "class_name": "ScriptRouter",
        "method_name": "getRule",
        "signature": "String getRule(URL)",
        "lines_hint_csv": [
          85,
          90
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouter.java",
        "class_name": "ScriptRouter",
        "method_name": "ScriptRouter",
        "signature": "ScriptRouter(URL)",
        "lines_hint_csv": [
          65,
          76
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/ScriptRouter.java",
        "class_name": "ScriptRouter",
        "method_name": "route",
        "signature": "List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)",
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2011-2732",
    "project_slug": "spring-projects__spring-security_CVE-2011-2732_2.0.6.RELEASE",
    "buggy_commit_id": "beb0ec4ba95265a7e3481b3eb8d87f3b922733ae",
    "github_url": "https://github.com/spring-projects/spring-security",
    "nvd_metadata": {
      "description": "CRLF injection vulnerability in the logout functionality in VMware SpringSource Spring Security before 2.0.7 and 3.0.x before 3.0.6 allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via the spring-security-redirect parameter.",
      "published_date": "2012-12-05T17:55:01.537",
      "cvss_v3_score": null,
      "severity": null
    },
    "code_snippets": [
      {
        "file_path": "web/src/main/java/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.java",
        "class_name": "AbstractAuthenticationTargetUrlRequestHandler",
        "method_name": "getTargetUrlParameter",
        "signature": "String getTargetUrlParameter()",
        "lines_hint_csv": [
          161,
          162
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "web/src/main/java/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.java",
        "class_name": "SimpleUrlLogoutSuccessHandler",
        "method_name": "unknown",
        "signature": null,
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      },
      {
        "file_path": "web/src/main/java/org/springframework/security/web/firewall/DefaultHttpFirewall.java",
        "class_name": "DefaultHttpFirewall",
        "method_name": "getFirewalledResponse",
        "signature": "HttpServletResponse getFirewalledResponse(HttpServletResponse response)",
        "lines_hint_csv": [
          161,
          162
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2021-4178",
    "project_slug": "fabric8io__kubernetes-client_CVE-2021-4178_5.0.2",
    "buggy_commit_id": "1d1b3d404836871c4d0fc0a35dafe5d40369b519",
    "github_url": "https://github.com/fabric8io/kubernetes-client",
    "nvd_metadata": {
      "description": "A arbitrary code execution flaw was found in the Fabric 8 Kubernetes client affecting versions 5.0.0-beta-1 and above. Due to an improperly configured YAML parsing, this will allow a local and privileged attacker to supply malicious YAML.",
      "published_date": "2022-08-24T16:15:09.770",
      "cvss_v3_score": 6.7,
      "severity": "MEDIUM"
    },
    "code_snippets": []
  },
  {
    "cve_id": "CVE-2022-42889",
    "project_slug": "asf__commons-text_CVE-2022-42889_1.9",
    "buggy_commit_id": "cb85bed468e99d34b88d0c81fe20eb3b1615660e",
    "github_url": "https://github.com/apache/commons-text",
    "nvd_metadata": {
      "description": "Apache Commons Text performs variable interpolation, allowing properties to be dynamically evaluated and expanded. The standard format for interpolation is \"${prefix:name}\", where \"prefix\" is used to locate an instance of org.apache.commons.text.lookup.StringLookup that performs the interpolation. Starting with version 1.5 and continuing through 1.9, the set of default Lookup instances included interpolators that could result in arbitrary code execution or contact with remote servers. These lookups are: - \"script\" - execute expressions using the JVM script execution engine (javax.script) - \"dns\" - resolve dns records - \"url\" - load values from urls, including from remote servers Applications using the interpolation defaults in the affected versions may be vulnerable to remote code execution or unintentional contact with remote servers if untrusted configuration values are used. Users are recommended to upgrade to Apache Commons Text 1.10.0, which disables the problematic interpolators by default.",
      "published_date": "2022-10-13T13:15:10.113",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/apache/commons/text/StringSubstitutor.java",
        "class_name": "StringSubstitutor",
        "method_name": "unknown",
        "signature": null,
        "lines_hint_csv": [
          0,
          0
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java",
        "class_name": "InterpolatorStringLookup",
        "method_name": "InterpolatorStringLookup",
        "signature": "InterpolatorStringLookup(Map,StringLookup,boolean)",
        "lines_hint_csv": [
          70,
          78
        ],
        "code": "    InterpolatorStringLookup(final Map<String, StringLookup> stringLookupMap, final StringLookup defaultStringLookup,\n        final boolean addDefaultLookups) {\n        super();\n        this.defaultStringLookup = defaultStringLookup;\n        this.stringLookupMap = new HashMap<>(stringLookupMap.size());\n        for (final Entry<String, StringLookup> entry : stringLookupMap.entrySet()) {\n            this.stringLookupMap.put(toKey(entry.getKey()), entry.getValue());\n        }\n        if (addDefaultLookups) {\n            StringLookupFactory.INSTANCE.addDefaultStringLookups(this.stringLookupMap);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          69,
          80
        ]
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java",
        "class_name": "InterpolatorStringLookup",
        "method_name": "lookup",
        "signature": "String lookup(String)",
        "lines_hint_csv": [
          123,
          146
        ],
        "code": "    public String lookup(String var) {\n        if (var == null) {\n            return null;\n        }\n\n        final int prefixPos = var.indexOf(PREFIX_SEPARATOR);\n        if (prefixPos >= 0) {\n            final String prefix = toKey(var.substring(0, prefixPos));\n            final String name = var.substring(prefixPos + 1);\n            final StringLookup lookup = stringLookupMap.get(prefix);\n            String value = null;\n            if (lookup != null) {\n                value = lookup.lookup(name);\n            }\n\n            if (value != null) {\n                return value;\n            }\n            var = var.substring(prefixPos + 1);\n        }\n        if (defaultStringLookup != null) {\n            return defaultStringLookup.lookup(var);\n        }\n        return null;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          123,
          147
        ]
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/InterpolatorStringLookup.java",
        "class_name": "InterpolatorStringLookup",
        "method_name": "toKey",
        "signature": "String toKey(String)",
        "lines_hint_csv": [
          43,
          44
        ],
        "code": "    static String toKey(final String key) {\n        return key.toLowerCase(Locale.ROOT);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          42,
          44
        ]
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "class_name": "StringLookupFactory",
        "method_name": "addDefaultStringLookups",
        "signature": "void addDefaultStringLookups(Map)",
        "lines_hint_csv": [
          445,
          449
        ],
        "code": "    public void addDefaultStringLookups(final Map<String, StringLookup> stringLookupMap) {\n        if (stringLookupMap != null) {\n            // \"base64\" is deprecated in favor of KEY_BASE64_DECODER.\n            stringLookupMap.put(\"base64\", StringLookupFactory.INSTANCE_BASE64_DECODER);\n            for (final DefaultStringLookup stringLookup : DefaultStringLookup.values()) {\n                stringLookupMap.put(InterpolatorStringLookup.toKey(stringLookup.getKey()),\n                    stringLookup.getStringLookup());\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          407,
          416
        ]
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "class_name": "StringLookupFactory",
        "method_name": "interpolatorStringLookup",
        "signature": "StringLookup interpolatorStringLookup()",
        "lines_hint_csv": [
          742,
          743
        ],
        "code": "    public StringLookup interpolatorStringLookup(final StringLookup defaultStringLookup) {\n        return new InterpolatorStringLookup(defaultStringLookup);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          745,
          747
        ]
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "class_name": "StringLookupFactory",
        "method_name": "toMap",
        "signature": "Map toMap(Map)",
        "lines_hint_csv": [
          428,
          429
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "class_name": "StringLookupFactory",
        "method_name": "xmlStringLookup",
        "signature": "StringLookup xmlStringLookup()",
        "lines_hint_csv": [
          1170,
          1171
        ],
        "code": "    public StringLookup xmlStringLookup() {\n        return XmlStringLookup.INSTANCE;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          1134,
          1136
        ]
      },
      {
        "file_path": "src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java",
        "class_name": "StringLookupFactory",
        "method_name": "environmentVariableStringLookup",
        "signature": "StringLookup environmentVariableStringLookup()",
        "lines_hint_csv": [
          673,
          674
        ],
        "code": "    public StringLookup environmentVariableStringLookup() {\n        return StringLookupFactory.INSTANCE_ENVIRONMENT_VARIABLES;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          637,
          639
        ]
      },
      {
        "file_path": "src/test/java/org/apache/commons/text/StringSubstitutorWithInterpolatorStringLookupTest.java",
        "class_name": "StringSubstitutorWithInterpolatorStringLookupTest",
        "method_name": "testDefaultValueForMissingKeyInResourceBundle",
        "signature": "void testDefaultValueForMissingKeyInResourceBundle()",
        "lines_hint_csv": [
          127,
          133
        ],
        "code": "    public void testDefaultValueForMissingKeyInResourceBundle() {\n        final StringLookup interpolatorStringLookup = StringLookupFactory.INSTANCE.interpolatorStringLookup(\n            StringLookupFactory.INSTANCE.resourceBundleStringLookup(\"org.example.testResourceBundleLookup\"));\n        assertEquals(\"${missingKey:-defaultValue}\", interpolatorStringLookup.lookup(\"keyWithMissingKey\"));\n        final StringSubstitutor stringSubstitutor = new StringSubstitutor(interpolatorStringLookup);\n        // The following would throw a MissingResourceException before TEXT-165.\n        assertEquals(\"defaultValue\", stringSubstitutor.replace(\"${keyWithMissingKey}\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          127,
          134
        ]
      },
      {
        "file_path": "src/test/java/org/apache/commons/text/StringSubstitutorWithInterpolatorStringLookupTest.java",
        "class_name": "StringSubstitutorWithInterpolatorStringLookupTest",
        "method_name": "testLocalHostLookup_Name",
        "signature": "void testLocalHostLookup_Name()",
        "lines_hint_csv": [
          205,
          207
        ],
        "code": "    public void testLocalHostLookup_Name() throws UnknownHostException {\n        final StringSubstitutor strSubst = StringSubstitutor.createInterpolator();\n        Assertions.assertEquals(InetAddress.getLocalHost().getHostName(), strSubst.replace(\"${localhost:name}\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          205,
          208
        ]
      },
      {
        "file_path": "src/test/java/org/apache/commons/text/StringSubstitutorWithInterpolatorStringLookupTest.java",
        "class_name": "StringSubstitutorWithInterpolatorStringLookupTest",
        "method_name": "testDefaultInterpolator",
        "signature": "void testDefaultInterpolator()",
        "lines_hint_csv": [
          90,
          123
        ],
        "code": "    public void testDefaultInterpolator() {\n        // Used to cut and paste into the docs.\n        // @formatter:off\n        final StringSubstitutor interpolator = StringSubstitutor.createInterpolator();\n        interpolator.setEnableSubstitutionInVariables(true); // Allows for nested $'s.\n        final String text = interpolator.replace(\n                \"Base64 Decoder:        ${base64Decoder:SGVsbG9Xb3JsZCE=}\\n\"\n              + \"Base64 Encoder:        ${base64Encoder:HelloWorld!}\\n\"\n              + \"Java Constant:         ${const:java.awt.event.KeyEvent.VK_ESCAPE}\\n\"\n              + \"Date:                  ${date:yyyy-MM-dd}\\n\"\n              + \"DNS:                   ${dns:address|apache.org}\\n\"\n              + \"Environment Variable:  ${env:USERNAME}\\n\"\n              + \"File Content:          ${file:UTF-8:src/test/resources/document.properties}\\n\"\n              + \"Java:                  ${java:version}\\n\"\n              + \"Localhost:             ${localhost:canonical-name}\\n\"\n              + \"Properties File:       ${properties:src/test/resources/document.properties::mykey}\\n\"\n              + \"Resource Bundle:       ${resourceBundle:org.example.testResourceBundleLookup:mykey}\\n\"\n              + \"Script:                ${script:javascript:3 + 4}\\n\"\n              + \"System Property:       ${sys:user.dir}\\n\"\n              + \"URL Decoder:           ${urlDecoder:Hello%20World%21}\\n\"\n              + \"URL Encoder:           ${urlEncoder:Hello World!}\\n\"\n              + \"URL Content (HTTP):    ${url:UTF-8:http://www.apache.org}\\n\"\n              + \"URL Content (HTTPS):   ${url:UTF-8:https://www.apache.org}\\n\"\n              + \"URL Content (File):    ${url:UTF-8:file:///${sys:user.dir}/src/test/resources/document.properties}\\n\"\n              + \"XML XPath:             ${xml:src/test/resources/document.xml:/root/path/to/node}\\n\"\n        );\n        // @formatter:on\n        Assertions.assertNotNull(text);\n        // TEXT-171:\n        Assertions.assertFalse(text.contains(\"${base64Decoder:SGVsbG9Xb3JsZCE=}\"));\n        Assertions.assertFalse(text.contains(\"${base64Encoder:HelloWorld!}\"));\n        Assertions.assertFalse(text.contains(\"${urlDecoder:Hello%20World%21}\"));\n        Assertions.assertFalse(text.contains(\"${urlEncoder:Hello World!}\"));\n        Assertions.assertFalse(text.contains(\"${resourceBundle:org.example.testResourceBundleLookup:mykey}\"));\n        // System.out.println(text);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          90,
          125
        ]
      },
      {
        "file_path": "src/test/java/org/apache/commons/text/StringSubstitutorWithInterpolatorStringLookupTest.java",
        "class_name": "StringSubstitutorWithInterpolatorStringLookupTest",
        "method_name": "testDnsLookupCanonicalName",
        "signature": "void testDnsLookupCanonicalName()",
        "lines_hint_csv": [
          152,
          157
        ],
        "code": "    public void testDnsLookupCanonicalName() throws UnknownHostException {\n        final StringSubstitutor strSubst = StringSubstitutor.createInterpolator();\n        final String address = InetAddress.getLocalHost().getHostAddress();\n        final InetAddress inetAddress = InetAddress.getByName(address);\n        Assertions.assertEquals(inetAddress.getCanonicalHostName(),\n            strSubst.replace(\"${dns:canonical-name|\" + address + \"}\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          152,
          158
        ]
      },
      {
        "file_path": "src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java",
        "class_name": "StringLookupFactoryTest",
        "method_name": "testSingletons",
        "signature": "void testSingletons()",
        "lines_hint_csv": [
          69,
          91
        ],
        "code": "    public void testSingletons() {\n        final StringLookupFactory stringLookupFactory = StringLookupFactory.INSTANCE;\n        Assertions.assertSame(StringLookupFactory.INSTANCE_BASE64_DECODER,\n            stringLookupFactory.base64DecoderStringLookup());\n        Assertions.assertSame(StringLookupFactory.INSTANCE_BASE64_ENCODER,\n            stringLookupFactory.base64EncoderStringLookup());\n        Assertions.assertSame(ConstantStringLookup.INSTANCE, stringLookupFactory.constantStringLookup());\n        Assertions.assertSame(DateStringLookup.INSTANCE, stringLookupFactory.dateStringLookup());\n        Assertions.assertSame(DnsStringLookup.INSTANCE, stringLookupFactory.dnsStringLookup());\n        Assertions.assertSame(StringLookupFactory.INSTANCE_ENVIRONMENT_VARIABLES,\n            stringLookupFactory.environmentVariableStringLookup());\n        Assertions.assertSame(InterpolatorStringLookup.INSTANCE, stringLookupFactory.interpolatorStringLookup());\n        Assertions.assertSame(JavaPlatformStringLookup.INSTANCE, stringLookupFactory.javaPlatformStringLookup());\n        Assertions.assertSame(LocalHostStringLookup.INSTANCE, stringLookupFactory.localHostStringLookup());\n        Assertions.assertSame(StringLookupFactory.INSTANCE_NULL, stringLookupFactory.nullStringLookup());\n        Assertions.assertSame(ResourceBundleStringLookup.INSTANCE, stringLookupFactory.resourceBundleStringLookup());\n        Assertions.assertSame(ScriptStringLookup.INSTANCE, stringLookupFactory.scriptStringLookup());\n        Assertions.assertSame(StringLookupFactory.INSTANCE_SYSTEM_PROPERTIES,\n            stringLookupFactory.systemPropertyStringLookup());\n        Assertions.assertSame(UrlDecoderStringLookup.INSTANCE, stringLookupFactory.urlDecoderStringLookup());\n        Assertions.assertSame(UrlEncoderStringLookup.INSTANCE, stringLookupFactory.urlEncoderStringLookup());\n        Assertions.assertSame(UrlStringLookup.INSTANCE, stringLookupFactory.urlStringLookup());\n        Assertions.assertSame(XmlStringLookup.INSTANCE, stringLookupFactory.xmlStringLookup());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          69,
          92
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-44262",
    "project_slug": "ff4j__ff4j_CVE-2022-44262_1.8.13",
    "buggy_commit_id": "7c34409d320ed1c917c4ec4ac72a99661c4e446f",
    "github_url": "https://github.com/ff4j/ff4j",
    "nvd_metadata": {
      "description": "ff4j 1.8.1 is vulnerable to Remote Code Execution (RCE).",
      "published_date": "2022-12-01T05:15:11.973",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "ff4j-config-properties/src/main/java/org/ff4j/parser/properties/PropertiesParser.java",
        "class_name": "PropertiesParser",
        "method_name": "parseFeatures",
        "signature": "void parseFeatures(FF4jConfiguration,Map)",
        "lines_hint_csv": [
          276,
          333
        ],
        "code": "    private void parseFeatures(FF4jConfiguration ff4jConfig, Map<String, String> mapConf) {\n        int idx = 0;\n        String currentFeatureKey = FF4J_TAG + \".\" + FEATURES_TAG  + \".\" + idx;\n        while (mapConf.containsKey(currentFeatureKey +  \".\" + FEATURE_ATT_UID)) {\n            assertKeyNotEmpty(mapConf, currentFeatureKey +  \".\" + FEATURE_ATT_UID);\n            Feature f = new Feature(mapConf.get(currentFeatureKey +  \".\" + FEATURE_ATT_UID));\n            // Enabled\n            assertKeyNotEmpty(mapConf, currentFeatureKey +  \".\" + FEATURE_ATT_ENABLE);\n            f.setEnable(Boolean.valueOf(mapConf.get(currentFeatureKey +  \".\" + FEATURE_ATT_ENABLE)));\n            // Description\n            String description = mapConf.get(currentFeatureKey +  \".\" + FEATURE_ATT_DESC);\n            if (null != description && !\"\".equals(description)) {\n                f.setDescription(description);\n            }\n            // Group\n            String groupName = mapConf.get(currentFeatureKey +  \".\" + FEATURE_ATT_GROUP);\n            if (null != groupName && !\"\".equals(groupName)) {\n                f.setGroup(groupName);\n            }\n            // Permissions\n            String strPermissions = mapConf.get(currentFeatureKey +  \".\" + FEATURE_ATT_PERMISSIONS);\n            if (null != strPermissions && !\"\".equals(strPermissions)) {\n                f.setPermissions(\n                        Arrays.asList(strPermissions.split(\",\"))\n                              .stream()\n                              .map(String::trim)\n                              .collect(Collectors.toSet()));\n            }\n            // Custom Properties\n            f.setCustomProperties(parseProperties(currentFeatureKey + \".\" + FEATURE_ATT_PROPERTIES, mapConf));\n            // FlipStrategy\n            String flipStrategyClass = mapConf.get(currentFeatureKey +  \".\" + TOGGLE_STRATEGY_TAG + \".\" + TOGGLE_STRATEGY_ATTCLASS);\n            if (null != flipStrategyClass && !\"\".equals(flipStrategyClass)) {\n                FlippingStrategy flipStrategy = null;\n                try {\n                    flipStrategy = (FlippingStrategy) Class.forName(flipStrategyClass).newInstance();\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Cannot parse flipStrategy for feature '\" + f.getUid() + \n                            \"' -> check key [\" + currentFeatureKey +  \".\" + TOGGLE_STRATEGY_TAG + \".\" + TOGGLE_STRATEGY_ATTCLASS + \"]\", e);\n                }\n                int idxParam = 0;\n                String currentParamKey = currentFeatureKey +  \".\" + TOGGLE_STRATEGY_TAG + \".\" + TOGGLE_STRATEGY_PARAMTAG + \".\" + idxParam;\n                Map<String, String> params = new HashMap<>();\n                while (mapConf.containsKey(currentParamKey+  \".\" + TOGGLE_STRATEGY_PARAMNAME)) {\n                    assertKeyNotEmpty(mapConf, currentParamKey + \".\" + TOGGLE_STRATEGY_PARAMNAME);\n                    assertKeyNotEmpty(mapConf, currentParamKey + \".\" + TOGGLE_STRATEGY_PARAMVALUE);\n                    params.put(mapConf.get(currentParamKey + \".\" + TOGGLE_STRATEGY_PARAMNAME), \n                               mapConf.get(currentParamKey + \".\" + TOGGLE_STRATEGY_PARAMVALUE));\n                    currentParamKey = currentFeatureKey +  \".\" + TOGGLE_STRATEGY_TAG + \".\" + TOGGLE_STRATEGY_PARAMTAG + \".\" + ++idxParam;\n                }\n                flipStrategy.init(f.getUid(), params);\n                f.setFlippingStrategy(flipStrategy);\n                \n            }\n            ff4jConfig.getFeatures().put(f.getUid(), f);\n            \n            // ff4j.features.X\n            currentFeatureKey = FF4J_TAG + \".\" + FEATURES_TAG  + \".\" + ++idx;\n        }\n        \n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          276,
          336
        ]
      },
      {
        "file_path": "ff4j-config-properties/src/main/java/org/ff4j/parser/properties/PropertiesParser.java",
        "class_name": "PropertiesParser",
        "method_name": "parseProperties",
        "signature": "Map parseProperties(String,Map)",
        "lines_hint_csv": [
          213,
          265
        ],
        "code": "    private Map < String, Property<?>> parseProperties(String prefix, Map<String, String> mapConfigProperties) {\n        Map < String, Property<?>> result = new HashMap<>();\n        int idx = 0;\n        String currentPropertyKey = prefix  + \".\" + idx;\n        while (mapConfigProperties.containsKey(currentPropertyKey +  \".\" + PROPERTY_PARAMNAME)) {\n            \n            assertKeyNotEmpty(mapConfigProperties, currentPropertyKey +  \".\" + PROPERTY_PARAMNAME);\n            String name     = mapConfigProperties.get(currentPropertyKey +  \".\" + PROPERTY_PARAMNAME);\n            \n            assertKeyNotEmpty(mapConfigProperties, currentPropertyKey +  \".\" + PROPERTY_PARAMVALUE);\n            String strValue = mapConfigProperties.get(currentPropertyKey +  \".\" + PROPERTY_PARAMVALUE);\n            \n            Property<?> ap      = new PropertyString(name, strValue);\n            String optionalType = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMTYPE);\n            // If specific type defined ?\n            if (null != optionalType) {\n                // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')\n                optionalType = MappingUtil.mapPropertyType(optionalType);\n                try {\n                    // Constructor (String, String) is mandatory in Property interface\n                    Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\n                    ap = (Property<?>) constr.newInstance(name, strValue);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);\n                }\n            }\n            // Description\n            String description = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMDESCRIPTION);\n            if (null != description) {\n                ap.setDescription(description);\n            } \n            // Fixed Values\n            String strFixedValues = mapConfigProperties.get(currentPropertyKey + \".\" + PROPERTY_PARAMFIXED_VALUES);\n            if (null != strFixedValues && !\"\".equals(strFixedValues)) {\n                Arrays.asList(strValue.split(\",\"))\n                      .stream()\n                      .map(String::trim)\n                      .forEach(ap::add2FixedValueFromString);\n            }\n          \n            // Check fixed value\n            if (ap.getFixedValues() != null &&  \n               !ap.getFixedValues().isEmpty() && \n               !ap.getFixedValues().contains(ap.getValue())) {\n                throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \n                        \"> invalid value <\" + ap.getValue() + \n                        \"> expected one of \" + ap.getFixedValues());\n            }\n            result.put(ap.getName(), ap);\n            // ff4j.properties.X\n            currentPropertyKey = prefix + \".\" + ++idx;\n        }\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          213,
          266
        ]
      },
      {
        "file_path": "ff4j-config-properties/src/test/java/org/ff4j/parser/properties/PropertiesParserTest.java",
        "class_name": "PropertiesParserTest",
        "method_name": "importProperties_should_be_same_asXMLImport",
        "signature": "void importProperties_should_be_same_asXMLImport()",
        "lines_hint_csv": [
          51,
          79
        ],
        "code": "    public void importProperties_should_be_same_asXMLImport() {\n        // Give XML an YAML files\n        InputStream xmlFile = getClass().getClassLoader().getResourceAsStream(\"test-ff4j-features.xml\");\n        InputStream ymlFile = getClass().getClassLoader().getResourceAsStream(\"test-ff4j-features.properties\");\n        // When parsing those files\n        XmlConfig xmlConfig = new XmlParser().parseConfigurationFile(xmlFile);\n        FF4jConfiguration propsConfig = new PropertiesParser().parseConfigurationFile(ymlFile);\n        // Than both config are even\n        assertEquals(xmlConfig.getFeatures().size(), propsConfig.getFeatures().size());\n        assertEquals(xmlConfig.getProperties().size(), propsConfig.getProperties().size());\n        \n        // Custom-properties\n        Feature f1Xml = xmlConfig.getFeatures().get(\"first\");\n        Feature f1props = propsConfig.getFeatures().get(\"first\");\n        assertEquals(f1Xml.getDescription(), f1props.getDescription());\n        assertEquals(f1Xml.getCustomProperties().size(), f1props.getCustomProperties().size());\n        \n        // FlipStrategy & Permission\n        Feature f3Xml = xmlConfig.getFeatures().get(\"third\");\n        Feature f3Props = propsConfig.getFeatures().get(\"third\");\n        assertEquals(\n                f3Xml.getFlippingStrategy().getClass(), \n                f3Props.getFlippingStrategy().getClass());\n        assertEquals(\n                f3Xml.getFlippingStrategy().getInitParams().get(\"expression\"), \n                f3Props.getFlippingStrategy().getInitParams().get(\"expression\"));\n        assertEquals(\n                f3Xml.getPermissions(), \n                f3Props.getPermissions());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          51,
          80
        ]
      },
      {
        "file_path": "ff4j-config-properties/src/test/java/org/ff4j/parser/properties/PropertiesParserTest.java",
        "class_name": "PropertiesParserTest",
        "method_name": "should_export_anyConfig_asProperties",
        "signature": "void should_export_anyConfig_asProperties()",
        "lines_hint_csv": [
          41,
          47
        ],
        "code": "    public void should_export_anyConfig_asProperties() {\n        // Given an XML file\n        InputStream xmlFile = getClass().getClassLoader().getResourceAsStream(\"test-ff4j-features.xml\");\n        // When loading config\n        XmlConfig xmlConfig = new XmlParser().parseConfigurationFile(xmlFile);\n        // Then it possible to export as YAML\n        new PropertiesParser().export(xmlConfig);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          41,
          48
        ]
      },
      {
        "file_path": "ff4j-config-properties/src/test/java/org/ff4j/parser/properties/PropertiesParserTest.java",
        "class_name": "PropertiesParserTest",
        "method_name": "propertiesFile_shouldExist",
        "signature": "void propertiesFile_shouldExist()",
        "lines_hint_csv": [
          36,
          37
        ],
        "code": "    public void propertiesFile_shouldExist() {\n        new PropertiesParser().parseConfigurationFile(null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          36,
          38
        ]
      },
      {
        "file_path": "ff4j-config-yaml/src/main/java/org/ff4j/parser/yaml/YamlParser.java",
        "class_name": "YamlParser",
        "method_name": "parseProperties",
        "signature": "Map parseProperties(List)",
        "lines_hint_csv": [
          147,
          202
        ],
        "code": "    private Map < String, Property<?>> parseProperties(List<Map<String, Object>> properties) {\n        Map < String, Property<?>> result = new HashMap<>();\n        if (null != properties) {\n            properties.forEach(property -> {\n                // Initiate with name and value\n                String name     = (String) property.get(PROPERTY_PARAMNAME);\n                if (null == name) { \n                    throw new IllegalArgumentException(\"Invalid YAML File: 'name' is expected for properties\");\n                }\n                \n                Object objValue = property.get(PROPERTY_PARAMVALUE);\n                if (null == objValue) {\n                    throw new IllegalArgumentException(\"Invalid YAML File: 'value' is expected for properties\");\n                }\n                // Convert as a String\n                String strValue = String.valueOf(objValue);\n                if (objValue instanceof Date) {\n                    strValue = SIMPLE_DATE_FORMAT.format((Date) objValue);\n                }\n                \n                Property<?> ap = new PropertyString(name, strValue);\n                String optionalType = (String) property.get(PROPERTY_PARAMTYPE);\n                // If specific type defined ?\n                if (null != optionalType) {\n                    // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')\n                    optionalType = MappingUtil.mapPropertyType(optionalType);\n                    try {\n                        // Constructor (String, String) is mandatory in Property interface\n                        Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\n                        ap = (Property<?>) constr.newInstance(name, strValue);\n                    } catch (Exception e) {\n                        throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);\n                    }\n                }\n                // Description\n                String description = (String) property.get(PROPERTY_PARAMDESCRIPTION);\n                if (null != description) {\n                    ap.setDescription(description);\n                } \n                // Fixed Values\n                List<Object> fixedValues = (List<Object>) property.get(PROPERTY_PARAMFIXED_VALUES);\n                if (null != fixedValues && fixedValues.size() > 0) {\n                    fixedValues.stream().map(Object::toString).forEach(ap::add2FixedValueFromString);\n                }\n                // Check fixed value\n                if (ap.getFixedValues() != null &&  \n                   !ap.getFixedValues().isEmpty() && \n                   !ap.getFixedValues().contains(ap.getValue())) {\n                    throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \n                            \"> invalid value <\" + ap.getValue() + \n                            \"> expected one of \" + ap.getFixedValues());\n                }\n                result.put(ap.getName(), ap);\n            });\n        }\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          147,
          203
        ]
      },
      {
        "file_path": "ff4j-config-yaml/src/main/java/org/ff4j/parser/yaml/YamlParser.java",
        "class_name": "YamlParser",
        "method_name": "parseFlipStrategy",
        "signature": "FlippingStrategy parseFlipStrategy(Feature,Map)",
        "lines_hint_csv": [
          250,
          266
        ],
        "code": "    private FlippingStrategy parseFlipStrategy(Feature feature, Map<String, Object> toggleStrategy) {\n        try {\n            // Parse class\n            String clazzName = (String) toggleStrategy.get(TOGGLE_STRATEGY_ATTCLASS);\n            FlippingStrategy flipStrategy = (FlippingStrategy) Class.forName(clazzName).newInstance();\n            // Parse Params\n            List<Map<String, Object>> mapYamlParam = (List<Map<String, Object>>) toggleStrategy.get(TOGGLE_STRATEGY_PARAMTAG);\n            Map<String,String> params = new HashMap<>();\n            for (Map<String, Object> currentParam : mapYamlParam) {\n                params.put(\n                        currentParam.get(TOGGLE_STRATEGY_PARAMNAME).toString(), \n                        currentParam.get(TOGGLE_STRATEGY_PARAMVALUE).toString());\n            }\n            flipStrategy.init(feature.getUid(), params);\n            return flipStrategy;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"An error occurs during flipstrategy parsing TAG\" + feature.getUid(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          250,
          268
        ]
      },
      {
        "file_path": "ff4j-config-yaml/src/test/java/org/ff4j/parser/yaml/YamlParserTest.java",
        "class_name": "YamlParserTest",
        "method_name": "yamlFile_shouldExist",
        "signature": "void yamlFile_shouldExist()",
        "lines_hint_csv": [
          36,
          37
        ],
        "code": "    public void yamlFile_shouldExist() {\n        new YamlParser().parseConfigurationFile(null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          36,
          38
        ]
      },
      {
        "file_path": "ff4j-config-yaml/src/test/java/org/ff4j/parser/yaml/YamlParserTest.java",
        "class_name": "YamlParserTest",
        "method_name": "importYaml_should_be_same_asXMLImport",
        "signature": "void importYaml_should_be_same_asXMLImport()",
        "lines_hint_csv": [
          51,
          79
        ],
        "code": "    public void importYaml_should_be_same_asXMLImport() {\n        // Give XML an YAML files\n        InputStream xmlFile = getClass().getClassLoader().getResourceAsStream(\"test-ff4j-features.xml\");\n        InputStream ymlFile = getClass().getClassLoader().getResourceAsStream(\"test-ff4j-features.yml\");\n        // When parsing those files\n        XmlConfig xmlConfig = new XmlParser().parseConfigurationFile(xmlFile);\n        FF4jConfiguration ymlConfig = new YamlParser().parseConfigurationFile(ymlFile);\n        // Than both config are even\n        assertEquals(xmlConfig.getFeatures().size(), ymlConfig.getFeatures().size());\n        assertEquals(xmlConfig.getProperties().size(), ymlConfig.getProperties().size());\n        \n        // Custom-properties\n        Feature f1Xml = xmlConfig.getFeatures().get(\"first\");\n        Feature f1Yml = ymlConfig.getFeatures().get(\"first\");\n        assertEquals(f1Xml.getDescription(), f1Yml.getDescription());\n        assertEquals(f1Xml.getCustomProperties().size(), f1Yml.getCustomProperties().size());\n        \n        // FlipStrategy & Permission\n        Feature f3Xml = xmlConfig.getFeatures().get(\"third\");\n        Feature f3Yml = ymlConfig.getFeatures().get(\"third\");\n        assertEquals(\n                f3Xml.getFlippingStrategy().getClass(), \n                f3Yml.getFlippingStrategy().getClass());\n        assertEquals(\n                f3Xml.getFlippingStrategy().getInitParams().get(\"expression\"), \n                f3Yml.getFlippingStrategy().getInitParams().get(\"expression\"));\n        assertEquals(\n                f3Xml.getPermissions(), \n                f3Yml.getPermissions());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          51,
          80
        ]
      },
      {
        "file_path": "ff4j-core/src/main/java/org/ff4j/conf/XmlParser.java",
        "class_name": "XmlParser",
        "method_name": "parsePropertiesTag",
        "signature": "Map parsePropertiesTag(Element)",
        "lines_hint_csv": [
          358,
          420
        ],
        "code": "    private Map < String , Property<?>> parsePropertiesTag(Element propertiesTag) {\n        Map< String , Property<?>> properties = new HashMap<String, Property<?>>(); \n        // <properties>\n        NodeList lisOfProperties = propertiesTag.getElementsByTagName(PROPERTY_TAG);\n        for (int k = 0; k < lisOfProperties.getLength(); k++) {\n            // <property name='' value='' (type='') >\n            Element propertyTag = (Element) lisOfProperties.item(k);\n            NamedNodeMap attMap = propertyTag.getAttributes();\n            if (attMap.getNamedItem(PROPERTY_PARAMNAME) == null) {\n                throw new IllegalArgumentException(\"Invalid XML Syntax, \"\n                        + \"'name' is a required attribute of 'property' TAG\");\n            }\n            if (attMap.getNamedItem(PROPERTY_PARAMVALUE) == null) {\n                throw new IllegalArgumentException(\"Invalid XML Syntax, \"\n                        + \"'value' is a required attribute of 'property' TAG\");\n            }\n            String name  = attMap.getNamedItem(PROPERTY_PARAMNAME).getNodeValue();\n            String value = unEscapeXML(attMap.getNamedItem(PROPERTY_PARAMVALUE).getNodeValue());\n            Property<?> ap = new PropertyString(name, value);\n            \n            // If specific type defined ?\n            if (null != attMap.getNamedItem(PROPERTY_PARAMTYPE)) {\n                String optionalType = attMap.getNamedItem(PROPERTY_PARAMTYPE).getNodeValue();\n               \n                // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')\n                optionalType = MappingUtil.mapPropertyType(optionalType);\n                \n                try {\n                    // Constructor (String, String) is mandatory in Property interface\n                    Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\n                    ap = (Property<?>) constr.newInstance(name, value);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);\n                }\n            }\n            \n            if (null != attMap.getNamedItem(PROPERTY_PARAMDESCRIPTION)) {\n                ap.setDescription(unEscapeXML(\n                        attMap.getNamedItem(PROPERTY_PARAMDESCRIPTION)\n                              .getNodeValue()));\n            }\n            \n            // Is there any fixed Value ?\n            NodeList listOfFixedValue = propertyTag.getElementsByTagName(PROPERTY_PARAMFIXED_VALUES);\n            if (listOfFixedValue.getLength() != 0) {\n                Element fixedValueTag = (Element) listOfFixedValue.item(0);\n                NodeList listOfValues =  fixedValueTag.getElementsByTagName(PROPERTY_PARAMVALUE);\n                for (int l = 0; l < listOfValues.getLength(); l++) {\n                    Element valueTag = (Element) listOfValues.item(l);\n                    ap.add2FixedValueFromString(unEscapeXML(valueTag.getTextContent()));\n                }\n            }\n            \n            // Check fixed value\n            if (ap.getFixedValues() != null && !ap.getFixedValues().contains(ap.getValue())) {\n                throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \n                        \"> invalid value <\" + ap.getValue() + \n                        \"> expected one of \" + ap.getFixedValues());\n            }\n            \n            properties.put(name, ap);\n        }\n        return properties;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          358,
          421
        ]
      },
      {
        "file_path": "ff4j-core/src/main/java/org/ff4j/conf/XmlParser.java",
        "class_name": "XmlParser",
        "method_name": "parseFlipStrategy",
        "signature": "FlippingStrategy parseFlipStrategy(Element,String)",
        "lines_hint_csv": [
          432,
          476
        ],
        "code": "    private FlippingStrategy parseFlipStrategy(Element flipStrategyTag, String uid) {\n        NamedNodeMap nnm = flipStrategyTag.getAttributes();\n        FlippingStrategy flipStrategy;\n        if (nnm.getNamedItem(FLIPSTRATEGY_ATTCLASS) == null) {\n            throw new IllegalArgumentException(\"Error syntax in configuration file : '\" + FLIPSTRATEGY_ATTCLASS\n                    + \"' is required for each flipstrategy (feature=\" + uid + \")\");\n        }\n\n        try {\n            // Attribute CLASS\n            String clazzName = nnm.getNamedItem(FLIPSTRATEGY_ATTCLASS).getNodeValue();\n            flipStrategy = (FlippingStrategy) Class.forName(clazzName).newInstance();\n\n            // LIST OF PARAMS\n            Map<String, String> parameters = new LinkedHashMap<String, String>();\n            NodeList initparamsNodes = flipStrategyTag.getElementsByTagName(FLIPSTRATEGY_PARAMTAG);\n            for (int k = 0; k < initparamsNodes.getLength(); k++) {\n                Element param = (Element) initparamsNodes.item(k);\n                NamedNodeMap nnmap = param.getAttributes();\n                // Check for required attribute name\n                String currentParamName;\n                if (nnmap.getNamedItem(FLIPSTRATEGY_PARAMNAME) == null) {\n                    throw new IllegalArgumentException(ERROR_SYNTAX_IN_CONFIGURATION_FILE\n                            + \"'name' is required for each param in flipstrategy(check \" + uid + \")\");\n                }\n                currentParamName = nnmap.getNamedItem(FLIPSTRATEGY_PARAMNAME).getNodeValue();\n                // Check for value attribute\n                if (nnmap.getNamedItem(FLIPSTRATEGY_PARAMVALUE) != null) {\n                    parameters.put(currentParamName, unEscapeXML(\n                            nnmap.getNamedItem(FLIPSTRATEGY_PARAMVALUE)\n                                 .getNodeValue()));\n                } else if (param.getFirstChild() != null) {\n                    parameters.put(currentParamName, unEscapeXML(\n                            param.getFirstChild().getNodeValue()));\n                } else {\n                    throw new IllegalArgumentException(\"Parameter '\" + currentParamName + \"' in feature '\" + uid\n                            + \"' has no value, please check XML\");\n                }\n            }\n\n            flipStrategy.init(uid, parameters);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"An error occurs during flipstrategy parsing TAG\" + uid, e);\n        }\n        return flipStrategy;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          432,
          477
        ]
      },
      {
        "file_path": "ff4j-core/src/main/java/org/ff4j/property/util/PropertyFactory.java",
        "class_name": "PropertyFactory",
        "method_name": "createProperty",
        "signature": "Property createProperty(String,String,String,String,Set)",
        "lines_hint_csv": [
          158,
          179
        ],
        "code": "    public static Property<?> createProperty(String pName, String pType, String pValue, String desc, Set < String > fixedValues) {\n        Util.assertNotNull(pName);\n        Util.assertNotNull(pType);\n        Property<?> ap = null;\n        try {\n            Constructor<?> constr = Class.forName(pType).getConstructor(String.class, String.class);\n            ap = (Property<?>) constr.newInstance(pName, pValue);\n            ap.setDescription(desc);\n            // Is there any fixed Value ?\n            if (fixedValues != null && !fixedValues.isEmpty()) {\n                for (String v : fixedValues) {\n                    ap.add2FixedValueFromString(v.trim());\n                }\n                // Should be filled before test\n                if (!ap.getFixedValues().contains(ap.getValue())) {\n                    throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \"> invalid value <\"\n                                + ap.getValue() + \"> expected one of \" + ap.getFixedValues());\n                }\n            }\n            return ap;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Cannot instantiate '\" + pType + \"' check default constructor : \" + e.getMessage(), e);\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          158,
          181
        ]
      },
      {
        "file_path": "ff4j-core/src/main/java/org/ff4j/utils/MappingUtil.java",
        "class_name": "MappingUtil",
        "method_name": "instanceFlippingStrategy",
        "signature": "FlippingStrategy instanceFlippingStrategy(String,String,Map)",
        "lines_hint_csv": [
          181,
          188
        ],
        "code": "\tpublic static FlippingStrategy instanceFlippingStrategy(String uid, String className,  Map<String, String> initparams) {\n        try {\n            Class<FlippingStrategy> clazz = (Class<FlippingStrategy>) (classLoader == null ? Class.forName(className) : classLoader.loadClass(className));\n            FlippingStrategy flipStrategy = clazz.newInstance();\n            flipStrategy.init(uid, initparams);\n            return flipStrategy;\n        } catch (Exception ie) {\n            throw new FeatureAccessException(\"Cannot instantiate Strategy, no default constructor available\", ie);\n        } \n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          181,
          190
        ]
      },
      {
        "file_path": "ff4j-core/src/test/java/org/ff4j/test/parser/XmlParserTest.java",
        "class_name": "XmlParserTest",
        "method_name": "testParsingFeatureInvalidTag",
        "signature": "void testParsingFeatureInvalidTag()",
        "lines_hint_csv": [
          83,
          84
        ],
        "code": "    public void testParsingFeatureInvalidTag() throws IOException {\n        parseFile(\"test-feature-ko3.xml\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          83,
          85
        ]
      },
      {
        "file_path": "ff4j-core/src/test/java/org/ff4j/test/parser/XmlParserTest.java",
        "class_name": "XmlParserTest",
        "method_name": "testParseXMLWithSpecialCharacters",
        "signature": "void testParseXMLWithSpecialCharacters()",
        "lines_hint_csv": [
          108,
          136
        ],
        "code": "    public void testParseXMLWithSpecialCharacters() throws IOException {\n        // Given a config file with Special Characters in XML\n        XmlConfig xmlConfig1 = parseFile(\"test-parser-specialchars.xml\");\n        // When parsed the special characters are replaced by expected values \n        Assert.assertEquals(\"description \\\"&>OK<'\", xmlConfig1\n                .getFeatures().get(\"first\").getDescription());\n        // When parsed values protected by CDATA to interpret special chars\n        Assert.assertTrue(xmlConfig1\n                .getFeatures().get(\"first\")\n                .getCustomProperties().get(\"prop2\").getFixedValues()\n                .contains(\"https://en.wikipedia.org/w/index.php?title=XML&action=edit&section=4\"));\n        \n        // Given XmlConfig with special char\n        ByteArrayInputStream bais = (ByteArrayInputStream) new XmlParser().exportAll(xmlConfig1);\n        // When converting back to XML data\n        int n = bais.available();\n        byte[] bytes = new byte[n];\n        bais.read(bytes, 0, n);\n        String s = new String(bytes, StandardCharsets.UTF_8);\n        // Then special characters are escaped and values without quotes are protected with CDATA.\n        Assert.assertTrue(s.contains(\"description &quot;&amp;&gt;OK&lt;&apos;\"));\n        Assert.assertTrue(s.contains(\"<![CDATA[https://en.wikipedia.org/w/index.php?title=XML&action=edit&section=4]]>\"));\n        // When parsing back to XML\n        InputStream is = new ByteArrayInputStream(s.getBytes(StandardCharsets.UTF_8));\n        XmlConfig xmlConfig2 = new XmlParser().parseConfigurationFile(is);\n        // Then I get back the same values\n        Assert.assertEquals(\n           xmlConfig2.getFeatures().get(\"first\").getDescription(), \n           xmlConfig1.getFeatures().get(\"first\").getDescription());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          108,
          137
        ]
      },
      {
        "file_path": "ff4j-core/src/test/java/org/ff4j/test/property/PropertyFactoryTest.java",
        "class_name": "PropertyFactoryTest",
        "method_name": "testPropertyFactory9",
        "signature": "void testPropertyFactory9()",
        "lines_hint_csv": [
          99,
          100
        ],
        "code": "    public void testPropertyFactory9() {\n        PropertyFactory.createProperty(\"p1\", PropertyString.class.getName(), \"s1\", \"desc\", Util.set(\"s3\", \"s2\"));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          99,
          101
        ]
      },
      {
        "file_path": "ff4j-core/src/test/java/org/ff4j/test/utils/MappingUtilsTest.java",
        "class_name": "MappingUtilsTest",
        "method_name": "testIntanciateInvalidFlippingStrategy",
        "signature": "void testIntanciateInvalidFlippingStrategy()",
        "lines_hint_csv": [
          81,
          82
        ],
        "code": "    public void testIntanciateInvalidFlippingStrategy() {\n       MappingUtil.instanceFlippingStrategy(\"f1\", \"com.class.invalid\", new HashMap<String, String>());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          81,
          83
        ]
      },
      {
        "file_path": "ff4j-core/src/test/java/org/ff4j/test/utils/MappingUtilsTest.java",
        "class_name": "MappingUtilsTest",
        "method_name": "testAssert4",
        "signature": "void testAssert4()",
        "lines_hint_csv": [
          96,
          97
        ],
        "code": "    public void testAssert4() {\n        Util.assertParamHasLength(null, \"tata\");\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          96,
          98
        ]
      },
      {
        "file_path": "ff4j-web/src/main/java/org/ff4j/web/embedded/ConsoleOperations.java",
        "class_name": "ConsoleOperations",
        "method_name": "createFeature",
        "signature": "void createFeature(FF4j,HttpServletRequest)",
        "lines_hint_csv": [
          85,
          150
        ],
        "code": "    public static void createFeature(FF4j ff4j, HttpServletRequest req) {\n        // uid\n        final String featureId = req.getParameter(FEATID);\n        if (featureId != null && !featureId.isEmpty()) {\n            Feature fp = new Feature(featureId, false);\n\n            // Description\n            final String featureDesc = req.getParameter(DESCRIPTION);\n            if (null != featureDesc && !featureDesc.isEmpty()) {\n                fp.setDescription(featureDesc);\n            }\n\n            // GroupName\n            final String groupName = req.getParameter(GROUPNAME);\n            if (null != groupName && !groupName.isEmpty()) {\n                fp.setGroup(groupName);\n            }\n\n            // Strategy\n            final String strategy = req.getParameter(STRATEGY);\n            if (null != strategy && !strategy.isEmpty()) {\n                try {\n                    Class<?> strategyClass = Class.forName(strategy);\n                    FlippingStrategy fstrategy = (FlippingStrategy) strategyClass.newInstance();\n\n                    final String strategyParams = req.getParameter(STRATEGY_INIT);\n                    if (null != strategyParams && !strategyParams.isEmpty()) {\n                        Map<String, String> initParams = new HashMap<String, String>();\n                        String[] params = strategyParams.split(\";\");\n                        for (String currentP : params) {\n                            String[] cur = currentP.split(\"=\");\n                            if (cur.length < 2) {\n                                throw new IllegalArgumentException(\"Invalid Syntax : param1=val1,val2;param2=val3,val4\");\n                            }\n                            initParams.put(cur[0], cur[1]);\n                        }\n                        fstrategy.init(featureId, initParams);\n                    }\n                    fp.setFlippingStrategy(fstrategy);\n\n                } catch (ClassNotFoundException e) {\n                    throw new IllegalArgumentException(\"Cannot find strategy class\", e);\n                } catch (InstantiationException e) {\n                    throw new IllegalArgumentException(\"Cannot instantiate strategy\", e);\n                } catch (IllegalAccessException e) {\n                    throw new IllegalArgumentException(\"Cannot instantiate : no public constructor\", e);\n                }\n            }\n\n            // Permissions\n            final String permission = req.getParameter(PERMISSION);\n            if (null != permission && PERMISSION_RESTRICTED.equals(permission)) {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, Object> parameters = req.getParameterMap();\n                Set<String> permissions = new HashSet<String>();\n                for (String key : parameters.keySet()) {\n                    if (key.startsWith(PREFIX_CHECKBOX)) {\n                        permissions.add(key.replace(PREFIX_CHECKBOX, \"\"));\n                    }\n                }\n                fp.setPermissions(permissions);\n            }\n\n            // Creation\n            ff4j.getFeatureStore().create(fp);\n            LOGGER.info(featureId + \" has been created\");\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          85,
          152
        ]
      },
      {
        "file_path": "ff4j-web/src/main/java/org/ff4j/web/embedded/ConsoleOperations.java",
        "class_name": "ConsoleOperations",
        "method_name": "updateFlippingStrategy",
        "signature": "void updateFlippingStrategy(Feature,String,String)",
        "lines_hint_csv": [
          244,
          270
        ],
        "code": "    private static void updateFlippingStrategy(Feature fp, String strategy, String strategyParams) {\n        \n        if (null != strategy && !strategy.isEmpty()) {\n            try {\n                Class<?> strategyClass = Class.forName(strategy);\n                FlippingStrategy fstrategy = (FlippingStrategy) strategyClass.newInstance();\n               \n                if (null != strategyParams && !strategyParams.isEmpty()) {\n                    Map<String, String> initParams = new HashMap<String, String>();\n                    String[] params = strategyParams.split(\";\");\n                    for (String currentP : params) {\n                        String[] cur = currentP.split(\"=\");\n                        if (cur.length < 2) {\n                            throw new IllegalArgumentException(\"Invalid Syntax : param1=val1,val2;param2=val3,val4\");\n                        }\n                        initParams.put(cur[0], cur[1]);\n                    }\n                    fstrategy.init(fp.getUid(), initParams);\n                }\n                fp.setFlippingStrategy(fstrategy);\n\n            } catch (ClassNotFoundException e) {\n                throw new IllegalArgumentException(\"Cannot find strategy class\", e);\n            } catch (InstantiationException e) {\n                throw new IllegalArgumentException(\"Cannot instantiate strategy\", e);\n            } catch (IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Cannot instantiate : no public constructor\", e);\n            }\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          244,
          273
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2022-46166",
    "project_slug": "codecentric__spring-boot-admin_CVE-2022-46166_2.6.9",
    "buggy_commit_id": "650db9e89d80f54b41ebd18f8c27389e8741516d",
    "github_url": "https://github.com/codecentric/spring-boot-admin",
    "nvd_metadata": {
      "description": "Spring boot admins is an open source administrative user interface for management of spring boot applications. All users who run Spring Boot Admin Server, having enabled Notifiers (e.g. Teams-Notifier) and write access to environment variables via UI are affected. Users are advised to upgrade to the most recent releases of Spring Boot Admin 2.6.10 and 2.7.8 to resolve this issue. Users unable to upgrade may disable any notifier or disable write access (POST request) on `/env` actuator endpoint.\n\n",
      "published_date": "2022-12-09T21:15:14.843",
      "cvss_v3_score": 8.0,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/DingTalkNotifier.java",
        "class_name": "DingTalkNotifier",
        "method_name": "getText",
        "signature": "Object getText(InstanceEvent,Instance)",
        "lines_hint_csv": [
          99,
          106
        ],
        "code": "\tprivate Object getText(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\treturn message.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          99,
          107
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/DingTalkNotifier.java",
        "class_name": "DingTalkNotifier",
        "method_name": "getSign",
        "signature": "String getSign(Long)",
        "lines_hint_csv": [
          109,
          120
        ],
        "code": "\tprivate String getSign(Long timestamp) {\n\t\ttry {\n\t\t\tString stringToSign = timestamp + \"\\n\" + secret;\n\t\t\tMac mac = Mac.getInstance(\"HmacSHA256\");\n\t\t\tmac.init(new SecretKeySpec(secret.getBytes(\"UTF-8\"), \"HmacSHA256\"));\n\t\t\tbyte[] signData = mac.doFinal(stringToSign.getBytes(\"UTF-8\"));\n\t\t\treturn URLEncoder.encode(new String(Base64.encodeBase64(signData)), \"UTF-8\");\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t\treturn \"\";\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          109,
          121
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/DiscordNotifier.java",
        "class_name": "DiscordNotifier",
        "method_name": "createContent",
        "signature": "String createContent(InstanceEvent,Instance)",
        "lines_hint_csv": [
          115,
          122
        ],
        "code": "\tprotected String createContent(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\treturn message.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          115,
          123
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "buildUrl",
        "signature": "String buildUrl()",
        "lines_hint_csv": [
          95,
          99
        ],
        "code": "\tprotected String buildUrl() {\n\t\tif (url == null) {\n\t\t\tthrow new IllegalStateException(\"'url' must not be null.\");\n\t\t}\n\t\treturn String.format(\"%s/room/%s/notification?auth_token=%s\", url.toString(), roomId, authToken);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          95,
          100
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "createHipChatNotification",
        "signature": "HttpEntity createHipChatNotification(InstanceEvent,Instance)",
        "lines_hint_csv": [
          102,
          111
        ],
        "code": "\tprotected HttpEntity<Map<String, Object>> createHipChatNotification(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> body = new HashMap<>();\n\t\tbody.put(\"color\", getColor(event));\n\t\tbody.put(\"message\", getMessage(event, instance));\n\t\tbody.put(\"notify\", getNotify());\n\t\tbody.put(\"message_format\", \"html\");\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.setContentType(MediaType.APPLICATION_JSON);\n\t\treturn new HttpEntity<>(body, headers);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          102,
          112
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "getMessage",
        "signature": "String getMessage(InstanceEvent,Instance)",
        "lines_hint_csv": [
          119,
          126
        ],
        "code": "\tprotected String getMessage(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\treturn description.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          119,
          127
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "getColor",
        "signature": "String getColor(InstanceEvent)",
        "lines_hint_csv": [
          129,
          135
        ],
        "code": "\tprotected String getColor(InstanceEvent event) {\n\t\tif (event instanceof InstanceStatusChangedEvent) {\n\t\t\treturn StatusInfo.STATUS_UP.equals(((InstanceStatusChangedEvent) event).getStatusInfo().getStatus())\n\t\t\t\t\t? \"green\" : \"red\";\n\t\t}\n\t\telse {\n\t\t\treturn \"gray\";\n\t\t}\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          129,
          137
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "setUrl",
        "signature": "void setUrl(URI url)",
        "lines_hint_csv": [
          95,
          99
        ],
        "code": "\tpublic void setUrl(@Nullable URI url) {\n\t\tthis.url = url;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          139,
          141
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "setAuthToken",
        "signature": "void setAuthToken(String authToken)",
        "lines_hint_csv": [
          95,
          99
        ],
        "code": "\tpublic void setAuthToken(@Nullable String authToken) {\n\t\tthis.authToken = authToken;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          148,
          150
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "setRoomId",
        "signature": "void setRoomId(String roomId)",
        "lines_hint_csv": [
          95,
          99
        ],
        "code": "\tpublic void setRoomId(@Nullable String roomId) {\n\t\tthis.roomId = roomId;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          157,
          159
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "setNotify",
        "signature": "void setNotify(boolean notify)",
        "lines_hint_csv": [
          95,
          99
        ],
        "code": "\tpublic void setNotify(boolean notify) {\n\t\tthis.notify = notify;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          166,
          168
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/HipchatNotifier.java",
        "class_name": "HipchatNotifier",
        "method_name": "setDescription",
        "signature": "void setDescription(String description)",
        "lines_hint_csv": [
          95,
          99
        ],
        "code": "\tpublic void setDescription(String description) {\n\t\tthis.description = parser.parseExpression(description, ParserContext.TEMPLATE_EXPRESSION);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          174,
          176
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/LetsChatNotifier.java",
        "class_name": "LetsChatNotifier",
        "method_name": "getText",
        "signature": "String getText(InstanceEvent,Instance)",
        "lines_hint_csv": [
          117,
          124
        ],
        "code": "\tprotected String getText(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\treturn message.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          117,
          125
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/MicrosoftTeamsNotifier.java",
        "class_name": "MicrosoftTeamsNotifier",
        "method_name": "doNotify",
        "signature": "Mono doNotify(InstanceEvent,Instance)",
        "lines_hint_csv": [
          142,
          166
        ],
        "code": "\tprotected Mono<Void> doNotify(InstanceEvent event, Instance instance) {\n\t\tMessage message;\n\t\tStandardEvaluationContext context = createEvaluationContext(event, instance);\n\t\tif (event instanceof InstanceRegisteredEvent) {\n\t\t\tmessage = getRegisteredMessage(instance, context);\n\t\t}\n\t\telse if (event instanceof InstanceDeregisteredEvent) {\n\t\t\tmessage = getDeregisteredMessage(instance, context);\n\t\t}\n\t\telse if (event instanceof InstanceStatusChangedEvent) {\n\t\t\tmessage = getStatusChangedMessage(instance, context);\n\t\t}\n\t\telse {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\theaders.setContentType(MediaType.APPLICATION_JSON);\n\n\t\tif (webhookUrl == null) {\n\t\t\treturn Mono.error(new IllegalStateException(\"'webhookUrl' must not be null.\"));\n\t\t}\n\n\t\treturn Mono.fromRunnable(() -> this.restTemplate.postForEntity(webhookUrl,\n\t\t\t\tnew HttpEntity<Object>(message, headers), Void.class));\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          142,
          167
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/MicrosoftTeamsNotifier.java",
        "class_name": "MicrosoftTeamsNotifier",
        "method_name": "createMessage",
        "signature": "Message createMessage(Instance,String,String,StandardEvaluationContext)",
        "lines_hint_csv": [
          190,
          203
        ],
        "code": "\tprotected Message createMessage(Instance instance, String registeredTitle, String activitySubtitle,\n\t\t\tStandardEvaluationContext context) {\n\t\tList<Fact> facts = new ArrayList<>();\n\t\tfacts.add(new Fact(STATUS_KEY, instance.getStatusInfo().getStatus()));\n\t\tfacts.add(new Fact(SERVICE_URL_KEY, instance.getRegistration().getServiceUrl()));\n\t\tfacts.add(new Fact(HEALTH_URL_KEY, instance.getRegistration().getHealthUrl()));\n\t\tfacts.add(new Fact(MANAGEMENT_URL_KEY, instance.getRegistration().getManagementUrl()));\n\t\tfacts.add(new Fact(SOURCE_KEY, instance.getRegistration().getSource()));\n\n\t\tSection section = Section.builder().activityTitle(instance.getRegistration().getName())\n\t\t\t\t.activitySubtitle(activitySubtitle).facts(facts).build();\n\n\t\treturn Message.builder().title(registeredTitle).summary(messageSummary)\n\t\t\t\t.themeColor(evaluateExpression(context, themeColor)).sections(singletonList(section)).build();\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          190,
          204
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/MicrosoftTeamsNotifier.java",
        "class_name": "MicrosoftTeamsNotifier",
        "method_name": "getWebhookUrl",
        "signature": "URI getWebhookUrl()",
        "lines_hint_csv": [
          221,
          222
        ],
        "code": "\tpublic URI getWebhookUrl() {\n\t\treturn webhookUrl;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          221,
          223
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/OpsGenieNotifier.java",
        "class_name": "OpsGenieNotifier",
        "method_name": "getDescription",
        "signature": "String getDescription(InstanceEvent,Instance)",
        "lines_hint_csv": [
          180,
          183
        ],
        "code": "\tprotected String getDescription(InstanceEvent event, Instance instance) {\n\t\treturn String.format(\"Instance %s (%s) went from %s to %s\", instance.getRegistration().getName(),\n\t\t\t\tinstance.getId(), getLastStatus(instance.getId()),\n\t\t\t\t((InstanceStatusChangedEvent) event).getStatusInfo().getStatus());\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          180,
          184
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/OpsGenieNotifier.java",
        "class_name": "OpsGenieNotifier",
        "method_name": "buildUrl",
        "signature": "String buildUrl(InstanceEvent,Instance)",
        "lines_hint_csv": [
          118,
          123
        ],
        "code": "\tprotected String buildUrl(InstanceEvent event, Instance instance) {\n\t\tif ((event instanceof InstanceStatusChangedEvent)\n\t\t\t\t&& (StatusInfo.STATUS_UP.equals(((InstanceStatusChangedEvent) event).getStatusInfo().getStatus()))) {\n\t\t\treturn String.format(\"%s/%s/close\", url.toString(), generateAlias(instance));\n\t\t}\n\t\treturn url.toString();\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          118,
          124
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/OpsGenieNotifier.java",
        "class_name": "OpsGenieNotifier",
        "method_name": "getMessage",
        "signature": "String getMessage()",
        "lines_hint_csv": [
          199,
          200
        ],
        "code": "\tpublic String getMessage() {\n\t\treturn description.getExpressionString();\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          199,
          201
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/OpsGenieNotifier.java",
        "class_name": "OpsGenieNotifier",
        "method_name": "getMessage",
        "signature": "String getMessage(InstanceEvent,Instance)",
        "lines_hint_csv": [
          170,
          177
        ],
        "code": "\tprotected String getMessage(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\treturn description.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          170,
          178
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/OpsGenieNotifier.java",
        "class_name": "OpsGenieNotifier",
        "method_name": "setApiKey",
        "signature": null,
        "lines_hint_csv": [
          170,
          177
        ],
        "code": "\tpublic void setApiKey(@Nullable String apiKey) {\n\t\tthis.apiKey = apiKey;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          186,
          188
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/PagerdutyNotifier.java",
        "class_name": "PagerdutyNotifier",
        "method_name": "getDescription",
        "signature": "String getDescription(InstanceEvent,Instance)",
        "lines_hint_csv": [
          130,
          138
        ],
        "code": "\tprotected String getDescription(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\n\t\treturn description.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          130,
          139
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/PagerdutyNotifier.java",
        "class_name": "PagerdutyNotifier",
        "method_name": "setUrl",
        "signature": "void setUrl(URI url)",
        "lines_hint_csv": [
          130,
          138
        ],
        "code": "\tpublic void setUrl(URI url) {\n\t\tthis.url = url;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          150,
          152
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/PagerdutyNotifier.java",
        "class_name": "PagerdutyNotifier",
        "method_name": "setClient",
        "signature": null,
        "lines_hint_csv": [
          130,
          138
        ],
        "code": "\tpublic void setClient(@Nullable String client) {\n\t\tthis.client = client;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          158,
          160
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/PagerdutyNotifier.java",
        "class_name": "PagerdutyNotifier",
        "method_name": "setClientUrl",
        "signature": null,
        "lines_hint_csv": [
          130,
          138
        ],
        "code": "\tpublic void setClientUrl(@Nullable URI clientUrl) {\n\t\tthis.clientUrl = clientUrl;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          167,
          169
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/PagerdutyNotifier.java",
        "class_name": "PagerdutyNotifier",
        "method_name": "setServiceKey",
        "signature": null,
        "lines_hint_csv": [
          130,
          138
        ],
        "code": "\tpublic void setServiceKey(@Nullable String serviceKey) {\n\t\tthis.serviceKey = serviceKey;\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          176,
          178
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/PagerdutyNotifier.java",
        "class_name": "PagerdutyNotifier",
        "method_name": "setDescription",
        "signature": null,
        "lines_hint_csv": [
          130,
          138
        ],
        "code": "\tpublic void setDescription(String description) {\n\t\tthis.description = parser.parseExpression(description, ParserContext.TEMPLATE_EXPRESSION);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          185,
          187
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/SlackNotifier.java",
        "class_name": "SlackNotifier",
        "method_name": "getText",
        "signature": "String getText(InstanceEvent,Instance)",
        "lines_hint_csv": [
          126,
          133
        ],
        "code": "\tprotected String getText(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\treturn message.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          126,
          134
        ]
      },
      {
        "file_path": "spring-boot-admin-server/src/main/java/de/codecentric/boot/admin/server/notify/TelegramNotifier.java",
        "class_name": "TelegramNotifier",
        "method_name": "getText",
        "signature": "String getText(InstanceEvent,Instance)",
        "lines_hint_csv": [
          105,
          112
        ],
        "code": "\tprotected String getText(InstanceEvent event, Instance instance) {\n\t\tMap<String, Object> root = new HashMap<>();\n\t\troot.put(\"event\", event);\n\t\troot.put(\"instance\", instance);\n\t\troot.put(\"lastStatus\", getLastStatus(event.getInstance()));\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(root);\n\t\tcontext.addPropertyAccessor(new MapAccessor());\n\t\treturn message.getValue(context, String.class);\n\t}\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          105,
          113
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-32697",
    "project_slug": "xerial__sqlite-jdbc_CVE-2023-32697_3.41.2.1",
    "buggy_commit_id": "a3322b2ae802b28624bcd4e2e20c55558e46cf99",
    "github_url": "https://github.com/xerial/sqlite-jdbc",
    "nvd_metadata": {
      "description": "SQLite JDBC is a library for accessing and creating SQLite database files in Java. Sqlite-jdbc addresses a remote code execution vulnerability via JDBC URL. This issue impacting versions 3.6.14.1 through 3.41.2.1 and has been fixed in version 3.41.2.2.\n",
      "published_date": "2023-05-23T23:15:09.337",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "src/main/java/org/sqlite/SQLiteConnection.java",
        "class_name": "SQLiteConnection",
        "method_name": "extractResource",
        "signature": "File extractResource(URL)",
        "lines_hint_csv": [
          297,
          339
        ],
        "code": "    private static File extractResource(URL resourceAddr) throws IOException {\n        if (resourceAddr.getProtocol().equals(\"file\")) {\n            try {\n                return new File(resourceAddr.toURI());\n            } catch (URISyntaxException e) {\n                throw new IOException(e.getMessage());\n            }\n        }\n\n        String tempFolder = new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath();\n        String dbFileName = String.format(\"sqlite-jdbc-tmp-%d.db\", resourceAddr.hashCode());\n        File dbFile = new File(tempFolder, dbFileName);\n\n        if (dbFile.exists()) {\n            long resourceLastModified = resourceAddr.openConnection().getLastModified();\n            long tmpFileLastModified = dbFile.lastModified();\n            if (resourceLastModified < tmpFileLastModified) {\n                return dbFile;\n            } else {\n                // remove the old DB file\n                boolean deletionSucceeded = dbFile.delete();\n                if (!deletionSucceeded) {\n                    throw new IOException(\n                            \"failed to remove existing DB file: \" + dbFile.getAbsolutePath());\n                }\n            }\n\n            //            String md5sum1 = SQLiteJDBCLoader.md5sum(resourceAddr.openStream());\n            //            String md5sum2 = SQLiteJDBCLoader.md5sum(new FileInputStream(dbFile));\n            //\n            //            if (md5sum1.equals(md5sum2))\n            //                return dbFile; // no need to extract the DB file\n            //            else\n            //            {\n            //            }\n        }\n\n        URLConnection conn = resourceAddr.openConnection();\n        // Disable caches to avoid keeping unnecessary file references after the single-use copy\n        conn.setUseCaches(false);\n        try (InputStream reader = conn.getInputStream()) {\n            Files.copy(reader, dbFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n            return dbFile;\n        }\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          297,
          341
        ]
      },
      {
        "file_path": "src/main/java/org/sqlite/SQLiteConnection.java",
        "class_name": "SQLiteConnection",
        "method_name": "open",
        "signature": "DB open(String url, String origFileName, Properties props)",
        "lines_hint_csv": [
          219,
          275
        ],
        "code": "    private static DB open(String url, String origFileName, Properties props) throws SQLException {\n        // Create a copy of the given properties\n        Properties newProps = new Properties();\n        newProps.putAll(props);\n\n        // Extract pragma as properties\n        String fileName = extractPragmasFromFilename(url, origFileName, newProps);\n        SQLiteConfig config = new SQLiteConfig(newProps);\n\n        // check the path to the file exists\n        if (!fileName.isEmpty()\n                && !\":memory:\".equals(fileName)\n                && !fileName.startsWith(\"file:\")\n                && !fileName.contains(\"mode=memory\")) {\n            if (fileName.startsWith(RESOURCE_NAME_PREFIX)) {\n                String resourceName = fileName.substring(RESOURCE_NAME_PREFIX.length());\n\n                // search the class path\n                ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n                URL resourceAddr = contextCL.getResource(resourceName);\n                if (resourceAddr == null) {\n                    try {\n                        resourceAddr = new URL(resourceName);\n                    } catch (MalformedURLException e) {\n                        throw new SQLException(\n                                String.format(\"resource %s not found: %s\", resourceName, e));\n                    }\n                }\n\n                try {\n                    fileName = extractResource(resourceAddr).getAbsolutePath();\n                } catch (IOException e) {\n                    throw new SQLException(String.format(\"failed to load %s: %s\", resourceName, e));\n                }\n            } else {\n                File file = new File(fileName).getAbsoluteFile();\n                File parent = file.getParentFile();\n                if (parent != null && !parent.exists()) {\n                    for (File up = parent; up != null && !up.exists(); ) {\n                        parent = up;\n                        up = up.getParentFile();\n                    }\n                    throw new SQLException(\n                            \"path to '\" + fileName + \"': '\" + parent + \"' does not exist\");\n                }\n\n                // check write access if file does not exist\n                try {\n                    // The extra check to exists() is necessary as createNewFile()\n                    // does not follow the JavaDoc when used on read-only shares.\n                    if (!file.exists() && file.createNewFile()) file.delete();\n                } catch (Exception e) {\n                    throw new SQLException(\"opening db: '\" + fileName + \"': \" + e.getMessage());\n                }\n                fileName = file.getAbsolutePath();\n            }\n        }\n\n        // load the native DB\n        DB db = null;\n        try {\n            NativeDB.load();\n            db = new NativeDB(url, fileName, config);\n        } catch (Exception e) {\n            SQLException err = new SQLException(\"Error opening connection\");\n            err.initCause(e);\n            throw err;\n        }\n        db.open(fileName, config.getOpenModeFlags());\n        return db;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          218,
          288
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-34468",
    "project_slug": "asf__nifi_CVE-2023-34468_1.21.0",
    "buggy_commit_id": "892f822107da84ca0dcfefdb5c91c5bc11dc3dc1",
    "github_url": "https://github.com/apache/nifi",
    "nvd_metadata": {
      "description": "The DBCPConnectionPool and HikariCPConnectionPool Controller Services in Apache NiFi 0.0.2 through 1.21.0 allow an authenticated and authorized user to configure a Database URL with the H2 driver that enables custom code execution.\n\nThe resolution validates the Database URL and rejects H2 JDBC locations.\n\nYou are recommended to upgrade to version 1.22.0 or later which fixes this issue.",
      "published_date": "2023-06-12T16:15:10.130",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "nifi-nar-bundles/nifi-standard-services/nifi-dbcp-service-bundle/nifi-dbcp-service/src/test/java/org/apache/nifi/dbcp/DBCPServiceTest.java",
        "class_name": "DBCPServiceTest",
        "method_name": "testCustomValidateOfKerberosProperties",
        "signature": "void testCustomValidateOfKerberosProperties()",
        "lines_hint_csv": [
          103,
          131
        ],
        "code": "    public void testCustomValidateOfKerberosProperties() throws InitializationException {\n        // direct principal + password and no kerberos services is valid\n        runner.setProperty(service, DBCPConnectionPool.KERBEROS_PRINCIPAL, \"foo@FOO.COM\");\n        runner.setProperty(service, DBCPConnectionPool.KERBEROS_PASSWORD, \"fooPassword\");\n        runner.assertValid(service);\n\n        // direct principal + password with kerberos credential service is invalid\n        final KerberosCredentialsService kerberosCredentialsService = enabledKerberosCredentialsService(runner);\n        runner.setProperty(service, DBCPConnectionPool.KERBEROS_CREDENTIALS_SERVICE, kerberosCredentialsService.getIdentifier());\n        runner.assertNotValid(service);\n\n        // kerberos credential service by itself is valid\n        runner.removeProperty(service, DBCPConnectionPool.KERBEROS_PRINCIPAL);\n        runner.removeProperty(service, DBCPConnectionPool.KERBEROS_PASSWORD);\n        runner.assertValid(service);\n\n        // kerberos credential service with kerberos user service is invalid\n        final KerberosUserService kerberosUserService = enableKerberosUserService(runner);\n        runner.setProperty(service, DBCPProperties.KERBEROS_USER_SERVICE, kerberosUserService.getIdentifier());\n        runner.assertNotValid(service);\n\n        // kerberos user service by itself is valid\n        runner.removeProperty(service, DBCPConnectionPool.KERBEROS_CREDENTIALS_SERVICE);\n        runner.assertValid(service);\n\n        // kerberos user service with direct principal + password is invalid\n        runner.setProperty(service, DBCPConnectionPool.KERBEROS_PRINCIPAL, \"foo@FOO.COM\");\n        runner.setProperty(service, DBCPConnectionPool.KERBEROS_PASSWORD, \"fooPassword\");\n        runner.assertNotValid(service);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          103,
          132
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-standard-services/nifi-dbcp-service-bundle/nifi-hikari-dbcp-service/src/test/java/org/apache/nifi/dbcp/HikariCPConnectionPoolTest.java",
        "class_name": "HikariCPConnectionPoolTest",
        "method_name": "testConnectionTimeoutZero",
        "signature": "void testConnectionTimeoutZero()",
        "lines_hint_csv": [
          51,
          59
        ],
        "code": "    public void testConnectionTimeoutZero() throws InitializationException {\n        final HikariCPConnectionPool service = new HikariCPConnectionPool();\n        runner.addControllerService(SERVICE_ID, service);\n\n        setDatabaseProperties(service);\n        runner.setProperty(service, HikariCPConnectionPool.MAX_WAIT_TIME, \"0 millis\");\n\n        runner.enableControllerService(service);\n        runner.assertValid(service);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          51,
          60
        ]
      },
      {
        "file_path": "nifi-nar-bundles/nifi-extension-utils/nifi-dbcp-base/src/main/java/org/apache/nifi/dbcp/utils/DBCPProperties.java",
        "class_name": "DBCPProperties",
        "method_name": "unknown",
        "signature": null,
        "lines_hint_csv": [
          103,
          131
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "nifi-nar-bundles/nifi-standard-services/nifi-dbcp-service-bundle/nifi-hikari-dbcp-service/src/main/java/org/apache/nifi/dbcp/HikariCPConnectionPool.java",
        "class_name": "HikariCPConnectionPool",
        "method_name": "unknown",
        "signature": null,
        "lines_hint_csv": [
          103,
          131
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2023-37582",
    "project_slug": "apache__rocketmq_CVE-2023-37582_4.9.6",
    "buggy_commit_id": "db4ba459bec9392ac37647ff1a4d24d30466814d",
    "github_url": "https://github.com/apache/rocketmq",
    "nvd_metadata": {
      "description": "The RocketMQ NameServer component still has a remote command execution vulnerability as the CVE-2023-33246 issue was not completely fixed in version 5.1.1. \n\nWhen NameServer address are leaked on the extranet and lack permission verification, an attacker can exploit this vulnerability by using the update configuration function on the NameServer component to execute commands as the system users that RocketMQ is running as. \n\nIt is recommended for users to upgrade their NameServer version to 5.1.2 or above for RocketMQ 5.x or 4.9.7 or above for RocketMQ 4.x to prevent these attacks.",
      "published_date": "2023-07-12T10:15:11.197",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java",
        "class_name": "DefaultRequestProcessor",
        "method_name": "updateConfig",
        "signature": "RemotingCommand updateConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          603,
          641
        ],
        "code": "    private RemotingCommand updateConfig(ChannelHandlerContext ctx, RemotingCommand request) {\n        if (ctx != null) {\n            log.info(\"updateConfig called by {}\", RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        byte[] body = request.getBody();\n        if (body != null) {\n            String bodyStr;\n            try {\n                bodyStr = new String(body, MixAll.DEFAULT_CHARSET);\n            } catch (UnsupportedEncodingException e) {\n                log.error(\"updateConfig byte array to string error: \", e);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"UnsupportedEncodingException \" + e);\n                return response;\n            }\n\n            Properties properties = MixAll.string2Properties(bodyStr);\n            if (properties == null) {\n                log.error(\"updateConfig MixAll.string2Properties error {}\", bodyStr);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"string2Properties error\");\n                return response;\n            }\n\n            if (properties.containsKey(\"kvConfigPath\") || properties.containsKey(\"configStorePathName\")) {\n                response.setCode(ResponseCode.NO_PERMISSION);\n                response.setRemark(\"Can not update config path\");\n                return response;\n            }\n\n            this.namesrvController.getConfiguration().update(properties);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          557,
          596
        ]
      },
      {
        "file_path": "namesrv/src/test/java/org/apache/rocketmq/namesrv/processor/RequestProcessorTest.java",
        "class_name": "RequestProcessorTest",
        "method_name": "testProcessRequest_UpdateConfigPath",
        "signature": "void testProcessRequest_UpdateConfigPath()",
        "lines_hint_csv": [
          184,
          217
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2023-36542",
    "project_slug": "asf__nifi_CVE-2023-36542_1.22.0",
    "buggy_commit_id": "71e3ea9f2c58d0cf2ce6824c388f2bd3e917dfc8",
    "github_url": "https://github.com/apache/nifi",
    "nvd_metadata": {
      "description": "Apache NiFi 0.0.2 through 1.22.0 include Processors and Controller Services that support HTTP URL references for retrieving drivers, which allows an authenticated and authorized user to configure a location that enables custom code execution. The resolution introduces a new Required Permission for referencing remote resources, restricting configuration of these components to privileged users. The permission prevents unprivileged users from configuring Processors and Controller Services annotated with the new Reference Remote Resources restriction. Upgrading to Apache NiFi 1.23.0 is the recommended mitigation.",
      "published_date": "2023-07-29T08:15:48.833",
      "cvss_v3_score": 8.8,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "nifi-nar-bundles/nifi-jms-bundle/nifi-jms-processors/src/main/java/org/apache/nifi/jms/cf/JMSConnectionFactoryProvider.java",
        "class_name": "JMSConnectionFactoryProvider",
        "method_name": "getSupportedDynamicPropertyDescriptor",
        "signature": "PropertyDescriptor getSupportedDynamicPropertyDescriptor(String)",
        "lines_hint_csv": [
          76,
          77
        ],
        "code": "    protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {\n        return JMSConnectionFactoryProperties.getDynamicPropertyDescriptor(propertyDescriptorName);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          76,
          78
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-33246",
    "project_slug": "apache__rocketmq_CVE-2023-33246_5.1.0",
    "buggy_commit_id": "b8e9334d2a1ed8868a3b15b63b8ef3198fcb81ce",
    "github_url": "https://github.com/apache/rocketmq",
    "nvd_metadata": {
      "description": "For RocketMQ versions 5.1.0 and below, under certain conditions, there is a risk of remote command execution.\n\nSeveral components of RocketMQ, including NameServer, Broker, and Controller, are leaked on the extranet and lack permission verification, an attacker can exploit this vulnerability by using the update configuration function to execute commands as the system users that RocketMQ is running as. Additionally, an attacker can achieve the same effect by forging the RocketMQ protocol content.\n\nTo prevent these attacks, users are recommended to upgrade to version 5.1.1 or abovefor using RocketMQ 5.xor 4.9.6 or above for using RocketMQ 4.x .",
      "published_date": "2023-05-24T15:15:09.553",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessor.java",
        "class_name": "AdminBrokerProcessor",
        "method_name": "updateBrokerConfig",
        "signature": "RemotingCommand updateBrokerConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          766,
          802
        ],
        "code": "    private synchronized RemotingCommand updateBrokerConfig(ChannelHandlerContext ctx, RemotingCommand request) {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        final String callerAddress = RemotingHelper.parseChannelRemoteAddr(ctx.channel());\n        LOGGER.info(\"Broker receive request to update config, caller address={}\", callerAddress);\n\n        byte[] body = request.getBody();\n        if (body != null) {\n            try {\n                String bodyStr = new String(body, MixAll.DEFAULT_CHARSET);\n                Properties properties = MixAll.string2Properties(bodyStr);\n                if (properties != null) {\n                    LOGGER.info(\"updateBrokerConfig, new config: [{}] client: {} \", properties, ctx.channel().remoteAddress());\n                    this.brokerController.getConfiguration().update(properties);\n                    if (properties.containsKey(\"brokerPermission\")) {\n                        this.brokerController.getTopicConfigManager().getDataVersion().nextVersion();\n                        this.brokerController.registerBrokerAll(false, false, true);\n                    }\n                } else {\n                    LOGGER.error(\"string2Properties error\");\n                    response.setCode(ResponseCode.SYSTEM_ERROR);\n                    response.setRemark(\"string2Properties error\");\n                    return response;\n                }\n            } catch (UnsupportedEncodingException e) {\n                LOGGER.error(\"AdminBrokerProcessor#updateBrokerConfig: unexpected error, caller={}\",\n                    callerAddress, e);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"UnsupportedEncodingException \" + e);\n                return response;\n            }\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          765,
          801
        ]
      },
      {
        "file_path": "broker/src/test/java/org/apache/rocketmq/broker/processor/AdminBrokerProcessorTest.java",
        "class_name": "AdminBrokerProcessorTest",
        "method_name": "testGetMinOffset",
        "signature": "void testGetMinOffset()",
        "lines_hint_csv": [
          310,
          319
        ],
        "code": "    public void testGetMinOffset() throws Exception {\n        messageStore = mock(MessageStore.class);\n        when(messageStore.getMinOffsetInQueue(anyString(), anyInt())).thenReturn(Long.MIN_VALUE);\n        when(brokerController.getMessageStore()).thenReturn(messageStore);\n        GetMinOffsetRequestHeader getMinOffsetRequestHeader = new GetMinOffsetRequestHeader();\n        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.GET_MIN_OFFSET, getMinOffsetRequestHeader);\n        request.addExtField(\"topic\", \"topic\");\n        request.addExtField(\"queueId\", \"0\");\n        RemotingCommand response = adminBrokerProcessor.processRequest(handlerContext, request);\n        assertThat(response.getCode()).isEqualTo(ResponseCode.SUCCESS);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          310,
          320
        ]
      },
      {
        "file_path": "controller/src/main/java/org/apache/rocketmq/controller/processor/ControllerRequestProcessor.java",
        "class_name": "ControllerRequestProcessor",
        "method_name": "handleGetControllerConfig",
        "signature": "RemotingCommand handleGetControllerConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          252,
          269
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "controller/src/main/java/org/apache/rocketmq/controller/processor/ControllerRequestProcessor.java",
        "class_name": "ControllerRequestProcessor",
        "method_name": "handleUpdateControllerConfig",
        "signature": "RemotingCommand handleUpdateControllerConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          217,
          249
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "METHOD_MISSING"
      },
      {
        "file_path": "namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java",
        "class_name": "DefaultRequestProcessor",
        "method_name": "getConfig",
        "signature": "RemotingCommand getConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          638,
          655
        ],
        "code": "    private RemotingCommand getConfig(ChannelHandlerContext ctx, RemotingCommand request) {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        String content = this.namesrvController.getConfiguration().getAllConfigsFormatString();\n        if (StringUtils.isNotBlank(content)) {\n            try {\n                response.setBody(content.getBytes(MixAll.DEFAULT_CHARSET));\n            } catch (UnsupportedEncodingException e) {\n                log.error(\"getConfig error, \", e);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"UnsupportedEncodingException \" + e);\n                return response;\n            }\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          638,
          656
        ]
      },
      {
        "file_path": "namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java",
        "class_name": "DefaultRequestProcessor",
        "method_name": "updateConfig",
        "signature": "RemotingCommand updateConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          603,
          635
        ],
        "code": "    private RemotingCommand updateConfig(ChannelHandlerContext ctx, RemotingCommand request) {\n        if (ctx != null) {\n            log.info(\"updateConfig called by {}\", RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        byte[] body = request.getBody();\n        if (body != null) {\n            String bodyStr;\n            try {\n                bodyStr = new String(body, MixAll.DEFAULT_CHARSET);\n            } catch (UnsupportedEncodingException e) {\n                log.error(\"updateConfig byte array to string error: \", e);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"UnsupportedEncodingException \" + e);\n                return response;\n            }\n\n            Properties properties = MixAll.string2Properties(bodyStr);\n            if (properties == null) {\n                log.error(\"updateConfig MixAll.string2Properties error {}\", bodyStr);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"string2Properties error\");\n                return response;\n            }\n\n            this.namesrvController.getConfiguration().update(properties);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          603,
          636
        ]
      },
      {
        "file_path": "namesrv/src/test/java/org/apache/rocketmq/namesrv/processor/RequestProcessorTest.java",
        "class_name": "RequestProcessorTest",
        "method_name": "init",
        "signature": "void init()",
        "lines_hint_csv": [
          73,
          92
        ],
        "code": "    public void init() throws Exception {\n        namesrvConfig = new NamesrvConfig();\n        namesrvConfig.setEnableAllTopicList(true);\n        nettyServerConfig = new NettyServerConfig();\n        routeInfoManager = new RouteInfoManager(new NamesrvConfig(), null);\n\n        namesrvController = new NamesrvController(namesrvConfig, nettyServerConfig);\n\n        Field field = NamesrvController.class.getDeclaredField(\"routeInfoManager\");\n        field.setAccessible(true);\n        field.set(namesrvController, routeInfoManager);\n        defaultRequestProcessor = new DefaultRequestProcessor(namesrvController);\n\n        clientRequestProcessor = new ClientRequestProcessor(namesrvController);\n\n\n        registerRouteInfoManager();\n\n        logger = mock(Logger.class);\n        setFinalStatic(DefaultRequestProcessor.class.getDeclaredField(\"log\"), logger);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          73,
          93
        ]
      },
      {
        "file_path": "namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java",
        "class_name": "DefaultRequestProcessor",
        "method_name": "getConfig",
        "signature": "RemotingCommand getConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          592,
          609
        ],
        "code": "    private RemotingCommand getConfig(ChannelHandlerContext ctx, RemotingCommand request) {\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        String content = this.namesrvController.getConfiguration().getAllConfigsFormatString();\n        if (StringUtils.isNotBlank(content)) {\n            try {\n                response.setBody(content.getBytes(MixAll.DEFAULT_CHARSET));\n            } catch (UnsupportedEncodingException e) {\n                log.error(\"getConfig error, \", e);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"UnsupportedEncodingException \" + e);\n                return response;\n            }\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          638,
          656
        ]
      },
      {
        "file_path": "namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java",
        "class_name": "DefaultRequestProcessor",
        "method_name": "updateConfig",
        "signature": "RemotingCommand updateConfig(ChannelHandlerContext,RemotingCommand)",
        "lines_hint_csv": [
          557,
          589
        ],
        "code": "    private RemotingCommand updateConfig(ChannelHandlerContext ctx, RemotingCommand request) {\n        if (ctx != null) {\n            log.info(\"updateConfig called by {}\", RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n        }\n\n        final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n\n        byte[] body = request.getBody();\n        if (body != null) {\n            String bodyStr;\n            try {\n                bodyStr = new String(body, MixAll.DEFAULT_CHARSET);\n            } catch (UnsupportedEncodingException e) {\n                log.error(\"updateConfig byte array to string error: \", e);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"UnsupportedEncodingException \" + e);\n                return response;\n            }\n\n            Properties properties = MixAll.string2Properties(bodyStr);\n            if (properties == null) {\n                log.error(\"updateConfig MixAll.string2Properties error {}\", bodyStr);\n                response.setCode(ResponseCode.SYSTEM_ERROR);\n                response.setRemark(\"string2Properties error\");\n                return response;\n            }\n\n            this.namesrvController.getConfiguration().update(properties);\n        }\n\n        response.setCode(ResponseCode.SUCCESS);\n        response.setRemark(null);\n        return response;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          603,
          636
        ]
      },
      {
        "file_path": "namesrv/src/test/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessorTest.java",
        "class_name": "DefaultRequestProcessorTest",
        "method_name": "testProcessRequest_RegisterBrokerWithFilterServer",
        "signature": "void testProcessRequest_RegisterBrokerWithFilterServer()",
        "lines_hint_csv": [
          188,
          212
        ],
        "code": "",
        "is_missing_in_buggy_version": true,
        "status": "FILE_MISSING"
      }
    ]
  },
  {
    "cve_id": "CVE-2023-51770",
    "project_slug": "apache__dolphinscheduler_CVE-2023-51770_3.2.0",
    "buggy_commit_id": "f64b254809f21f811eaef780d489a43b490ca327",
    "github_url": "https://github.com/apache/dolphinscheduler",
    "nvd_metadata": {
      "description": "Arbitrary File Read Vulnerability in Apache Dolphinscheduler.\n\nThis issue affects Apache DolphinScheduler: before 3.2.1. \n\nWe recommend users to upgrade Apache DolphinScheduler to version 3.2.1, which fixes the issue.",
      "published_date": "2024-02-20T10:15:08.243",
      "cvss_v3_score": 7.5,
      "severity": "HIGH"
    },
    "code_snippets": [
      {
        "file_path": "dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-mysql/src/main/java/org/apache/dolphinscheduler/plugin/datasource/mysql/param/MySQLDataSourceProcessor.java",
        "class_name": "MySQLDataSourceProcessor",
        "method_name": "checkKeyIsLegitimate",
        "signature": "boolean checkKeyIsLegitimate(String)",
        "lines_hint_csv": [
          180,
          184
        ],
        "code": "    private static boolean checkKeyIsLegitimate(String key) {\n        return !key.contains(ALLOW_LOAD_LOCAL_IN_FILE_NAME)\n                && !key.contains(AUTO_DESERIALIZE)\n                && !key.contains(ALLOW_LOCAL_IN_FILE_NAME)\n                && !key.contains(ALLOW_URL_IN_LOCAL_IN_FILE_NAME);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          174,
          179
        ]
      },
      {
        "file_path": "dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-mysql/src/main/java/org/apache/dolphinscheduler/plugin/datasource/mysql/param/MySQLDataSourceProcessor.java",
        "class_name": "MySQLDataSourceProcessor",
        "method_name": "getConnection",
        "signature": "Connection getConnection(ConnectionParam)",
        "lines_hint_csv": [
          130,
          143
        ],
        "code": "    public Connection getConnection(ConnectionParam connectionParam) throws ClassNotFoundException, SQLException {\n        MySQLConnectionParam mysqlConnectionParam = (MySQLConnectionParam) connectionParam;\n        Class.forName(getDatasourceDriver());\n        String user = mysqlConnectionParam.getUser();\n        if (user.contains(AUTO_DESERIALIZE)) {\n            log.warn(\"sensitive param : {} in username field is filtered\", AUTO_DESERIALIZE);\n            user = user.replace(AUTO_DESERIALIZE, \"\");\n        }\n        String password = PasswordUtils.decodePassword(mysqlConnectionParam.getPassword());\n        if (password.contains(AUTO_DESERIALIZE)) {\n            log.warn(\"sensitive param : {} in password field is filtered\", AUTO_DESERIALIZE);\n            password = password.replace(AUTO_DESERIALIZE, \"\");\n        }\n        return DriverManager.getConnection(getJdbcUrl(connectionParam), user, password);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          129,
          143
        ]
      },
      {
        "file_path": "dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-mysql/src/main/java/org/apache/dolphinscheduler/plugin/datasource/mysql/param/MySQLDataSourceProcessor.java",
        "class_name": "MySQLDataSourceProcessor",
        "method_name": "getJdbcUrl",
        "signature": "String getJdbcUrl(ConnectionParam)",
        "lines_hint_csv": [
          120,
          126
        ],
        "code": "    public String getJdbcUrl(ConnectionParam connectionParam) {\n        MySQLConnectionParam mysqlConnectionParam = (MySQLConnectionParam) connectionParam;\n        String jdbcUrl = mysqlConnectionParam.getJdbcUrl();\n        if (MapUtils.isNotEmpty(mysqlConnectionParam.getOther())) {\n            return String.format(\"%s?%s&%s\", jdbcUrl, transformOther(mysqlConnectionParam.getOther()), APPEND_PARAMS);\n        }\n        return String.format(\"%s?%s\", jdbcUrl, APPEND_PARAMS);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          119,
          126
        ]
      },
      {
        "file_path": "dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-mysql/src/main/java/org/apache/dolphinscheduler/plugin/datasource/mysql/param/MySQLDataSourceProcessor.java",
        "class_name": "MySQLDataSourceProcessor",
        "method_name": "transformOther",
        "signature": "String transformOther(Map)",
        "lines_hint_csv": [
          161,
          177
        ],
        "code": "    private String transformOther(Map<String, String> paramMap) {\n        if (MapUtils.isEmpty(paramMap)) {\n            return null;\n        }\n        Map<String, String> otherMap = new HashMap<>();\n        paramMap.forEach((k, v) -> {\n            if (!checkKeyIsLegitimate(k)) {\n                return;\n            }\n            otherMap.put(k, v);\n        });\n        if (MapUtils.isEmpty(otherMap)) {\n            return null;\n        }\n        List<String> otherList = new ArrayList<>();\n        otherMap.forEach((key, value) -> otherList.add(String.format(\"%s=%s\", key, value)));\n        return String.join(\"&\", otherList);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          155,
          172
        ]
      },
      {
        "file_path": "dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-mysql/src/main/java/org/apache/dolphinscheduler/plugin/datasource/mysql/param/MySQLDataSourceProcessor.java",
        "class_name": "MySQLDataSourceProcessor",
        "method_name": "getValidationQuery",
        "signature": "String getValidationQuery()",
        "lines_hint_csv": [
          115,
          116
        ],
        "code": "    public String getValidationQuery() {\n        return DataSourceConstants.MYSQL_VALIDATION_QUERY;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          114,
          116
        ]
      },
      {
        "file_path": "dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-mysql/src/test/java/org/apache/dolphinscheduler/plugin/datasource/mysql/param/MySQLDataSourceProcessorTest.java",
        "class_name": "MySQLDataSourceProcessorTest",
        "method_name": "testGetJdbcUrl",
        "signature": "void testGetJdbcUrl()",
        "lines_hint_csv": [
          79,
          84
        ],
        "code": "    public void testGetJdbcUrl() {\n        MySQLConnectionParam mysqlConnectionParam = new MySQLConnectionParam();\n        mysqlConnectionParam.setJdbcUrl(\"jdbc:mysql://localhost:3306/default\");\n        Assertions.assertEquals(\n                \"jdbc:mysql://localhost:3306/default?allowLoadLocalInfile=false&autoDeserialize=false&allowLocalInfile=false&allowUrlInLocalInfile=false\",\n                mysqlDatasourceProcessor.getJdbcUrl(mysqlConnectionParam));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          76,
          82
        ]
      },
      {
        "file_path": "dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-mysql/src/test/java/org/apache/dolphinscheduler/plugin/datasource/mysql/utils/DataSourceUtilsTest.java",
        "class_name": "DataSourceUtilsTest",
        "method_name": "testGetJdbcUrl",
        "signature": "void testGetJdbcUrl()",
        "lines_hint_csv": [
          115,
          121
        ],
        "code": "    public void testGetJdbcUrl() {\n        MySQLConnectionParam mysqlConnectionParam = new MySQLConnectionParam();\n        mysqlConnectionParam.setJdbcUrl(\"jdbc:mysql://localhost:3308\");\n        String jdbcUrl = DataSourceUtils.getJdbcUrl(DbType.MYSQL, mysqlConnectionParam);\n        Assertions.assertEquals(\n                \"jdbc:mysql://localhost:3308?allowLoadLocalInfile=false&autoDeserialize=false&allowLocalInfile=false&allowUrlInLocalInfile=false\",\n                jdbcUrl);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          115,
          122
        ]
      }
    ]
  },
  {
    "cve_id": "CVE-2023-49109",
    "project_slug": "apache__dolphinscheduler_CVE-2023-49109_3.2.0",
    "buggy_commit_id": "f64b254809f21f811eaef780d489a43b490ca327",
    "github_url": "https://github.com/apache/dolphinscheduler",
    "nvd_metadata": {
      "description": "Exposure of Remote Code Execution in Apache Dolphinscheduler.\n\nThis issue affects Apache DolphinScheduler: before 3.2.1. \n\nWe recommend users to upgrade Apache DolphinScheduler to version 3.2.1, which fixes the issue. ",
      "published_date": "2024-02-20T10:15:07.927",
      "cvss_v3_score": 9.8,
      "severity": "CRITICAL"
    },
    "code_snippets": [
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/K8sNamespaceController.java",
        "class_name": "K8sNamespaceController",
        "method_name": "createNamespace",
        "signature": "Result createNamespace(User,String,Long,Double,Integer)",
        "lines_hint_csv": [
          121,
          128
        ],
        "code": "    public Result createNamespace(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                  @RequestParam(value = \"namespace\") String namespace,\n                                  @RequestParam(value = \"clusterCode\") Long clusterCode,\n                                  @RequestParam(value = \"limitsCpu\", required = false) Double limitsCpu,\n                                  @RequestParam(value = \"limitsMemory\", required = false) Integer limitsMemory) {\n        Map<String, Object> result =\n                k8sNamespaceService.createK8sNamespace(loginUser, namespace, clusterCode, limitsCpu, limitsMemory);\n        return returnDataList(result);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          124,
          132
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/k8s/K8sClientService.java",
        "class_name": "K8sClientService",
        "method_name": "upsertNamespaceAndResourceToK8s",
        "signature": "ResourceQuota upsertNamespaceAndResourceToK8s(K8sNamespace,String)",
        "lines_hint_csv": [
          44,
          51
        ],
        "code": "    public ResourceQuota upsertNamespaceAndResourceToK8s(K8sNamespace k8sNamespace,\n                                                         String yamlStr) throws RemotingException {\n        if (!checkNamespaceToK8s(k8sNamespace.getNamespace(), k8sNamespace.getClusterCode())) {\n            throw new RemotingException(String.format(\n                    \"namespace %s does not exist in k8s cluster, please create namespace in k8s cluster first\",\n                    k8sNamespace.getNamespace()));\n        }\n        return upsertNamespacedResourceToK8s(k8sNamespace, yamlStr);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          45,
          53
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/k8s/K8sClientService.java",
        "class_name": "K8sClientService",
        "method_name": "deleteNamespaceToK8s",
        "signature": "Optional deleteNamespaceToK8s(String,Long)",
        "lines_hint_csv": [
          54,
          65
        ],
        "code": "    public Optional<Namespace> deleteNamespaceToK8s(String name, Long clusterCode) throws RemotingException {\n        Optional<Namespace> result = getNamespaceFromK8s(name, clusterCode);\n        if (result.isPresent()) {\n            KubernetesClient client = k8sManager.getK8sClient(clusterCode);\n            Namespace body = new Namespace();\n            ObjectMeta meta = new ObjectMeta();\n            meta.setNamespace(name);\n            meta.setName(name);\n            body.setMetadata(meta);\n            client.namespaces().delete(body);\n        }\n        return getNamespaceFromK8s(name, clusterCode);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          55,
          67
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/K8SNamespaceServiceImpl.java",
        "class_name": "K8SNamespaceServiceImpl",
        "method_name": "updateK8sNamespace",
        "signature": "Map updateK8sNamespace(User,int,String,Double,Integer)",
        "lines_hint_csv": [
          222,
          268
        ],
        "code": "    public Map<String, Object> updateK8sNamespace(User loginUser, int id, String userName, Double limitsCpu,\n                                                  Integer limitsMemory) {\n        Map<String, Object> result = new HashMap<>();\n        if (isNotAdmin(loginUser, result)) {\n            log.warn(\"Only admin can update K8s namespace, current login user name:{}.\", loginUser.getUserName());\n            return result;\n        }\n\n        if (limitsCpu != null && limitsCpu < 0.0) {\n            log.warn(\"Parameter limitsCpu is invalid.\");\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, Constants.LIMITS_CPU);\n            return result;\n        }\n\n        if (limitsMemory != null && limitsMemory < 0) {\n            log.warn(\"Parameter limitsMemory is invalid.\");\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, Constants.LIMITS_MEMORY);\n            return result;\n        }\n\n        K8sNamespace k8sNamespaceObj = k8sNamespaceMapper.selectById(id);\n        if (k8sNamespaceObj == null) {\n            log.error(\"K8s namespace does not exist, namespaceId:{}.\", id);\n            putMsg(result, Status.K8S_NAMESPACE_NOT_EXIST, id);\n            return result;\n        }\n\n        Date now = new Date();\n        k8sNamespaceObj.setLimitsCpu(limitsCpu);\n        k8sNamespaceObj.setLimitsMemory(limitsMemory);\n        k8sNamespaceObj.setUpdateTime(now);\n\n        if (!Constants.K8S_LOCAL_TEST_CLUSTER_CODE.equals(k8sNamespaceObj.getClusterCode())) {\n            try {\n                String yamlStr = genDefaultResourceYaml(k8sNamespaceObj);\n                k8sClientService.upsertNamespaceAndResourceToK8s(k8sNamespaceObj, yamlStr);\n            } catch (Exception e) {\n                log.error(\"Namespace update to k8s error\", e);\n                putMsg(result, Status.K8S_CLIENT_OPS_ERROR, e.getMessage());\n                return result;\n            }\n        }\n        // update to db\n        k8sNamespaceMapper.updateById(k8sNamespaceObj);\n        log.info(\"K8s namespace update complete, namespace:{}.\", k8sNamespaceObj.getNamespace());\n        putMsg(result, Status.SUCCESS);\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          222,
          269
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/K8SNamespaceServiceImpl.java",
        "class_name": "K8SNamespaceServiceImpl",
        "method_name": "queryListPaging",
        "signature": "Result queryListPaging(User,String,Integer,Integer)",
        "lines_hint_csv": [
          89,
          108
        ],
        "code": "    public Result queryListPaging(User loginUser, String searchVal, Integer pageNo, Integer pageSize) {\n        Result result = new Result();\n        if (!isAdmin(loginUser)) {\n            log.warn(\"Only admin can query namespace list, current login user name:{}.\", loginUser.getUserName());\n            putMsg(result, Status.USER_NO_OPERATION_PERM);\n            return result;\n        }\n\n        Page<K8sNamespace> page = new Page<>(pageNo, pageSize);\n\n        IPage<K8sNamespace> k8sNamespaceList = k8sNamespaceMapper.queryK8sNamespacePaging(page, searchVal);\n\n        Integer count = (int) k8sNamespaceList.getTotal();\n        PageInfo<K8sNamespace> pageInfo = new PageInfo<>(pageNo, pageSize);\n        pageInfo.setTotal(count);\n        pageInfo.setTotalList(k8sNamespaceList.getRecords());\n        result.setData(pageInfo);\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          89,
          109
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/K8SNamespaceServiceImpl.java",
        "class_name": "K8SNamespaceServiceImpl",
        "method_name": "createK8sNamespace",
        "signature": "Map createK8sNamespace(User,String,Long,Double,Integer)",
        "lines_hint_csv": [
          122,
          209
        ],
        "code": "    public Map<String, Object> createK8sNamespace(User loginUser, String namespace, Long clusterCode, Double limitsCpu,\n                                                  Integer limitsMemory) {\n        Map<String, Object> result = new HashMap<>();\n        if (isNotAdmin(loginUser, result)) {\n            log.warn(\"Only admin can create K8s namespace, current login user name:{}.\", loginUser.getUserName());\n            return result;\n        }\n\n        if (StringUtils.isEmpty(namespace)) {\n            log.warn(\"Parameter namespace is empty.\");\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, Constants.NAMESPACE);\n            return result;\n        }\n\n        if (clusterCode == null) {\n            log.warn(\"Parameter clusterCode is null.\");\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, Constants.CLUSTER);\n            return result;\n        }\n\n        if (limitsCpu != null && limitsCpu < 0.0) {\n            log.warn(\"Parameter limitsCpu is invalid.\");\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, Constants.LIMITS_CPU);\n            return result;\n        }\n\n        if (limitsMemory != null && limitsMemory < 0) {\n            log.warn(\"Parameter limitsMemory is invalid.\");\n            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, Constants.LIMITS_MEMORY);\n            return result;\n        }\n\n        if (checkNamespaceExistInDb(namespace, clusterCode)) {\n            log.warn(\"K8S namespace already exists.\");\n            putMsg(result, Status.K8S_NAMESPACE_EXIST, namespace, clusterCode);\n            return result;\n        }\n\n        Cluster cluster = clusterMapper.queryByClusterCode(clusterCode);\n        if (cluster == null) {\n            log.error(\"Cluster does not exist, clusterCode:{}\", clusterCode);\n            putMsg(result, Status.CLUSTER_NOT_EXISTS, namespace, clusterCode);\n            return result;\n        }\n\n        long code = 0L;\n        try {\n            code = CodeGenerateUtils.getInstance().genCode();\n            cluster.setCode(code);\n        } catch (CodeGenerateUtils.CodeGenerateException e) {\n            log.error(\"Generate cluster code error.\", e);\n        }\n        if (code == 0L) {\n            putMsg(result, Status.INTERNAL_SERVER_ERROR_ARGS, \"Error generating cluster code\");\n            return result;\n        }\n\n        K8sNamespace k8sNamespaceObj = new K8sNamespace();\n        Date now = new Date();\n\n        k8sNamespaceObj.setCode(code);\n        k8sNamespaceObj.setNamespace(namespace);\n        k8sNamespaceObj.setClusterCode(clusterCode);\n        k8sNamespaceObj.setUserId(loginUser.getId());\n        k8sNamespaceObj.setLimitsCpu(limitsCpu);\n        k8sNamespaceObj.setLimitsMemory(limitsMemory);\n        k8sNamespaceObj.setPodReplicas(0);\n        k8sNamespaceObj.setPodRequestCpu(0.0);\n        k8sNamespaceObj.setPodRequestMemory(0);\n        k8sNamespaceObj.setCreateTime(now);\n        k8sNamespaceObj.setUpdateTime(now);\n\n        if (!Constants.K8S_LOCAL_TEST_CLUSTER_CODE.equals(k8sNamespaceObj.getClusterCode())) {\n            try {\n                String yamlStr = genDefaultResourceYaml(k8sNamespaceObj);\n                k8sClientService.upsertNamespaceAndResourceToK8s(k8sNamespaceObj, yamlStr);\n            } catch (Exception e) {\n                log.error(\"Namespace create to k8s error\", e);\n                putMsg(result, Status.K8S_CLIENT_OPS_ERROR, e.getMessage());\n                return result;\n            }\n        }\n\n        k8sNamespaceMapper.insert(k8sNamespaceObj);\n        log.info(\"K8s namespace create complete, namespace:{}.\", k8sNamespaceObj.getNamespace());\n        putMsg(result, Status.SUCCESS);\n\n        return result;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          122,
          210
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/test/java/org/apache/dolphinscheduler/api/controller/K8sNamespaceControllerTest.java",
        "class_name": "K8sNamespaceControllerTest",
        "method_name": "createNamespace",
        "signature": "void createNamespace()",
        "lines_hint_csv": [
          67,
          83
        ],
        "code": "    public void createNamespace() throws Exception {\n\n        MultiValueMap<String, String> paramsMap = new LinkedMultiValueMap<>();\n        paramsMap.add(\"namespace\", NAMESPACE_CREATE_STRING);\n        paramsMap.add(\"clusterCode\", \"0\");\n\n        MvcResult mvcResult = mockMvc.perform(post(\"/k8s-namespace\")\n                .header(SESSION_ID, sessionId)\n                .params(paramsMap))\n                .andExpect(status().isCreated()) // it can\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n                .andReturn();\n\n        Result result = JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(), Result.class);\n        Assertions.assertEquals(Status.SUCCESS.getCode(), result.getCode().intValue());// because we not have a k8s\n                                                                                       // cluster in test env\n        logger.info(\"create queue return result:{}\", mvcResult.getResponse().getContentAsString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          67,
          84
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/test/java/org/apache/dolphinscheduler/api/controller/K8sNamespaceControllerTest.java",
        "class_name": "K8sNamespaceControllerTest",
        "method_name": "updateNamespace",
        "signature": "void updateNamespace()",
        "lines_hint_csv": [
          87,
          101
        ],
        "code": "    public void updateNamespace() throws Exception {\n        MultiValueMap<String, String> paramsMap = new LinkedMultiValueMap<>();\n        paramsMap.add(\"id\", \"1\");\n        paramsMap.add(\"owner\", \"owmer1\");\n        paramsMap.add(\"tag\", \"flink\");\n\n        MvcResult mvcResult = mockMvc.perform(put(\"/k8s-namespace/{id}\", 1)\n                .header(SESSION_ID, sessionId)\n                .params(paramsMap))\n                .andExpect(status().isCreated())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n                .andReturn();\n        Result result = JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(), Result.class);\n        Assertions.assertEquals(Status.SUCCESS.getCode(), result.getCode().intValue());\n        logger.info(\"update queue return result:{}\", mvcResult.getResponse().getContentAsString());\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          87,
          102
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/test/java/org/apache/dolphinscheduler/api/service/K8SNamespaceServiceTest.java",
        "class_name": "K8SNamespaceServiceTest",
        "method_name": "createK8sNamespace",
        "signature": "void createK8sNamespace()",
        "lines_hint_csv": [
          108,
          126
        ],
        "code": "    public void createK8sNamespace() {\n        // namespace is null\n        Map<String, Object> result =\n                k8sNamespaceService.createK8sNamespace(getLoginUser(), null, clusterCode, 10.0, 100);\n        logger.info(result.toString());\n        Assertions.assertEquals(Status.REQUEST_PARAMS_NOT_VALID_ERROR, result.get(Constants.STATUS));\n        // k8s is null\n        result = k8sNamespaceService.createK8sNamespace(getLoginUser(), namespace, null, 10.0, 100);\n        logger.info(result.toString());\n        Assertions.assertEquals(Status.REQUEST_PARAMS_NOT_VALID_ERROR, result.get(Constants.STATUS));\n        // correct\n        Mockito.when(clusterMapper.queryByClusterCode(Mockito.anyLong())).thenReturn(getCluster());\n        result = k8sNamespaceService.createK8sNamespace(getLoginUser(), namespace, clusterCode, 10.0, 100);\n        logger.info(result.toString());\n        Assertions.assertEquals(Status.SUCCESS, result.get(Constants.STATUS));\n        // null limit cpu and mem\n        result = k8sNamespaceService.createK8sNamespace(getLoginUser(), namespace, clusterCode, null, null);\n        logger.info(result.toString());\n        Assertions.assertEquals(Status.SUCCESS, result.get(Constants.STATUS));\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          108,
          127
        ]
      },
      {
        "file_path": "dolphinscheduler-api/src/test/java/org/apache/dolphinscheduler/api/service/K8SNamespaceServiceTest.java",
        "class_name": "K8SNamespaceServiceTest",
        "method_name": "setUp",
        "signature": "void setUp()",
        "lines_hint_csv": [
          83,
          87
        ],
        "code": "    public void setUp() throws Exception {\n        Mockito.when(\n                k8sClientService.upsertNamespaceAndResourceToK8s(Mockito.any(K8sNamespace.class), Mockito.anyString()))\n                .thenReturn(null);\n        Mockito.when(k8sClientService.deleteNamespaceToK8s(Mockito.anyString(), Mockito.anyLong())).thenReturn(null);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          83,
          88
        ]
      },
      {
        "file_path": "dolphinscheduler-dao/src/test/java/org/apache/dolphinscheduler/dao/mapper/K8sNamespaceMapperTest.java",
        "class_name": "K8sNamespaceMapperTest",
        "method_name": "insertOne",
        "signature": "K8sNamespace insertOne()",
        "lines_hint_csv": [
          45,
          57
        ],
        "code": "    private K8sNamespace insertOne() {\n        // insertOne\n        K8sNamespace k8sNamespace = new K8sNamespace();\n        k8sNamespace.setCode(999L);\n        k8sNamespace.setNamespace(\"testNamespace\");\n        k8sNamespace.setClusterCode(100L);\n        k8sNamespace.setClusterName(\"ds_null_k8s\");\n        k8sNamespace.setLimitsCpu(100.0);\n        k8sNamespace.setLimitsMemory(100);\n        k8sNamespace.setCreateTime(new Date());\n        k8sNamespace.setUpdateTime(new Date());\n        k8sNamespaceMapper.insert(k8sNamespace);\n        return k8sNamespace;\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          45,
          58
        ]
      },
      {
        "file_path": "dolphinscheduler-dao/src/test/java/org/apache/dolphinscheduler/dao/mapper/K8sNamespaceMapperTest.java",
        "class_name": "K8sNamespaceMapperTest",
        "method_name": "testUpdate",
        "signature": "void testUpdate()",
        "lines_hint_csv": [
          80,
          86
        ],
        "code": "    public void testUpdate() {\n        // insertOne\n        K8sNamespace k8sNamespace = insertOne();\n        k8sNamespace.setLimitsMemory(200);\n        // update\n        int update = k8sNamespaceMapper.updateById(k8sNamespace);\n        Assertions.assertEquals(update, 1);\n    }\n",
        "is_missing_in_buggy_version": false,
        "status": "FOUND",
        "lines_extracted": [
          80,
          87
        ]
      }
    ]
  }
]